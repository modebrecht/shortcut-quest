<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Shortcut Ritter-Akademie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f172a;
      --card: #1d273b;
      --border: rgba(148,163,184,0.25);
      --accent: #f59e0b;
      --accent-soft: rgba(245,158,11,0.18);
      --good: #22c55e;
      --good-soft: rgba(34,197,94,0.15);
      --bad: #f87171;
      --bad-soft: rgba(248,113,113,0.18);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --slot-row-height: 200px;
      --icon-visual-size: 116px;
      --inventory-icon-frame: 96px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: rgba(13,22,41,0.85);
      backdrop-filter: blur(8px);
      position: sticky;
      top: 0;
      z-index: 20;
    }
    .title {
      font-weight: 600;
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }
    .header-left { display: flex; align-items: center; gap: 1rem; }
    .header-right { display: flex; align-items: center; gap: 0.6rem; }
    .top-nav { display: flex; gap: 0.5rem; }
    .mobile-nav-toggle {
      display: none;
      align-items: center;
      padding: 0.35rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(148,163,184,0.16);
      color: var(--text);
      font-size: 0.85rem;
    }
    .nav-toggle {
      padding: 0.35rem 0.9rem;
      border-radius: 0.75rem;
      border: 1px solid transparent;
      background: rgba(148,163,184,0.12);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
    }
    .nav-toggle.active {
      border-color: rgba(245,158,11,0.5);
      background: var(--accent-soft);
    }
    .badge {
      border-radius: 999px;
      padding: 0.3rem 0.8rem;
      border: 1px solid var(--border);
      font-size: 0.78rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: rgba(15,23,42,0.4);
    }
    main {
      flex: 1;
      width: min(1100px, 95%);
      margin: 0.8rem auto 2.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .view { display: none; flex-direction: column; gap: 1rem; }
    .view.active { display: flex; }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.2rem 1.4rem;
      box-shadow: 0 18px 36px rgba(8,15,30,0.35);
    }
    .nav-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .section-tab {
      padding: 0.4rem 0.85rem;
      border-radius: 0.75rem;
      border: 1px solid transparent;
      background: rgba(148,163,184,0.12);
      color: var(--text);
      font-size: 0.82rem;
      cursor: pointer;
    }
    .section-tab.active {
      border-color: rgba(245,158,11,0.45);
      background: var(--accent-soft);
    }
    .section {
      display: none;
      flex-direction: column;
      gap: 1rem;
    }
    .section.active { display: flex; }
    h2 { margin: 0; font-size: 1.2rem; }
    .small { font-size: 0.85rem; color: var(--muted); }
    .task-field {
      display: block;
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 0.75rem;
      padding: 0.65rem 0.75rem;
      margin-top: 0.75rem;
      position: relative;
      background: rgba(15,23,42,0.3);
    }
    .task-field.correct {
      border-color: var(--good);
      background: var(--good-soft);
    }
    .task-field.incorrect {
      border-color: var(--bad);
      background: var(--bad-soft);
    }
    .task-field span.question-text {
      display: block;
      font-weight: 500;
      margin-bottom: 0.4rem;
    }
    select, input[type="text"] {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.45);
      color: var(--text);
      font-size: 0.92rem;
    }
    select:focus, input[type="text"]:focus {
      outline: 2px solid rgba(245,158,11,0.45);
      outline-offset: 2px;
    }
    .input-with-hint {
      position: relative;
    }
    .input-with-hint input[type="text"] {
      background: transparent;
    }
    .input-with-hint .input-hint-overlay {
      position: absolute;
      top: 50%;
      left: var(--input-hint-offset, 0.6rem);
      transform: translateY(-50%);
      pointer-events: none;
      color: var(--muted);
      font-size: 0.92rem;
      letter-spacing: 0.01em;
      transition: opacity 0.15s ease;
      white-space: pre;
      opacity: 0.85;
    }
    .input-with-hint .input-hint-overlay.hidden {
      opacity: 0;
    }
    .input-with-hint .input-hint-measure {
      position: absolute;
      visibility: hidden;
      pointer-events: none;
      white-space: pre;
      font: inherit;
    }
    button {
      font-family: inherit;
      cursor: pointer;
      border-radius: 0.75rem;
      border: none;
      font-weight: 600;
    }
    @media (max-width: 720px) {
      header {
        flex-wrap: wrap;
        gap: 0.6rem;
        padding: 0.9rem 1rem;
      }
      .header-left {
        width: 100%;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.4rem 1rem;
      }
      .header-right {
        width: 100%;
        justify-content: flex-start;
      }
      .header-right .badge {
        width: 100%;
        justify-content: center;
      }
      .mobile-nav-toggle {
        display: inline-flex;
      }
      .top-nav {
        display: none;
        width: 100%;
        flex-direction: column;
        gap: 0.4rem;
        padding-top: 0.4rem;
        border-top: 1px solid rgba(148,163,184,0.16);
      }
      .top-nav.open {
        display: flex;
      }
      .nav-toggle {
        width: 100%;
        text-align: left;
      }
    }
    .action-card {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .action-card button {
      padding: 0.55rem 1.1rem;
      background: var(--accent);
      color: #1f2937;
    }
    .reset-section {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
    }
    .result-text { flex: 1 1 100%; margin: 0; }
    .dnd-pool {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-top: 0.9rem;
    }
    .dnd-targets {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 0.75rem;
      margin-top: 1rem;
    }
    .dnd-token {
      padding: 0.3rem 0.7rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(148,163,184,0.15);
      cursor: grab;
      user-select: none;
    }
    .dnd-target {
      width: 100%;
      padding: 0.6rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148,163,184,0.4);
      min-width: 0;
      background: rgba(15,23,42,0.3);
      position: relative;
      box-sizing: border-box;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .dnd-target.correct {
      border-color: var(--good);
      background: var(--good-soft);
    }
    .dnd-target.incorrect {
      border-color: var(--bad);
      background: var(--bad-soft);
    }
    .dnd-target.over {
      border-color: var(--accent);
    }
    .drop-slot {
      margin-top: 0.45rem;
      min-height: 34px;
      border-radius: 0.45rem;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(10,20,40,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
    }
    .drop-slot.correct {
      border-color: rgba(34,197,94,0.6);
      background: rgba(34,197,94,0.12);
      color: var(--good);
    }
    .drop-slot.incorrect {
      border-color: rgba(248,113,113,0.6);
      background: rgba(248,113,113,0.12);
      color: var(--bad);
    }
    @media (max-width: 900px) {
      .dnd-targets {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
    @media (max-width: 520px) {
      .dnd-targets {
        grid-template-columns: 1fr;
      }
    }
    #overviewCard { margin-top: 0.5rem; }
    .hero-wrapper {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      margin-top: 1rem;
    }
    .equipment-layout {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      align-items: center;
      width: 100%;
    }
    .hero-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      width: 100%;
      height: 100%;
      min-height: 0;
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.1);
      box-shadow: inset 0 0 16px rgba(8,15,30,0.35);
    }
    .hero-avatar {
      --atk-low: #5b6ff5;
      --atk-mid: #f59e0b;
      --atk-high: #facc15;
      --def-low: #38bdf8;
      --def-mid: #0ea5e9;
      --def-high: #22c55e;
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: none;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.65rem;
      box-shadow: inset 0 0 16px rgba(8,15,30,0.7);
      overflow: hidden;
      position: relative;
    }
    .hero-avatar .hero-illustration {
      width: 100%;
      height: 100%;
      object-fit: contain;
      object-position: center 60%;
      display: block;
      transform-origin: center 70%;
      transition: transform 180ms ease;
    }
    .hero-avatar .hero-illustration.is-knight {
      transform: translateY(-2px) scale(1.22);
    }
    .hero-avatar .hero-illustration.is-blueprint {
      transform: translateY(-4px) scale(1.16);
    }
    .hero-avatar.no-gear {
      background: linear-gradient(165deg, rgba(45,64,124,0.95), rgba(17,24,39,0.88));
    }
    .hero-svg { width: 120px; height: 160px; }
    .hero-avatar[data-atk-tier="1"] .sword-blade { stroke: var(--atk-low); }
    .hero-avatar[data-atk-tier="2"] .sword-blade { stroke: var(--atk-mid); }
    .hero-avatar[data-atk-tier="3"] .sword-blade { stroke: var(--atk-high); }
    .hero-avatar[data-def-tier="1"] .shield-outline { stroke: var(--def-low); }
    .hero-avatar[data-def-tier="2"] .shield-outline { stroke: var(--def-mid); }
    .hero-avatar[data-def-tier="3"] .shield-outline { stroke: var(--def-high); }
    .hero-avatar.no-gear .sword-group,
    .hero-avatar.no-gear .shield-group,
    .hero-avatar.no-gear .cape-shape {
      opacity: 0;
    }
    .hero-avatar.no-gear .armor-core,
    .hero-avatar.no-gear .leg-piece {
      opacity: 0.35;
      filter: grayscale(0.6);
    }
    .slot-row {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-auto-rows: var(--slot-row-height);
      gap: 0.45rem;
      width: 100%;
      align-items: stretch;
    }
    .slot-row.middle-row {
      align-items: stretch;
      justify-items: stretch;
    }
    .slot-row.middle-row .hero-center {
      min-width: 0;
      width: 100%;
      flex: 1 1 0;
    }
    .equipment-slot {
      border: 1px solid var(--border);
      border-radius: 0.9rem;
      padding: 0.65rem 0.8rem 0.55rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      background: rgba(15,23,42,0.5);
      min-height: 0;
      position: relative;
      width: 100%;
      height: 100%;
    }
    .equipment-slot.equipped {
      border-style: solid;
      /*border-color: rgba(245,158,11,0.55);
      box-shadow: 0 12px 28px rgba(245,158,11,0.18);*/
    }
    .equipment-slot.tier-1 {
      border-color: rgba(148,163,184,0.4);
      background: rgba(148,163,184,0.12);
    }
    .equipment-slot.tier-2 {
      border-color: rgba(34,197,94,0.5);
      background: rgba(34,197,94,0.12);
      box-shadow: 0 6px 14px rgba(34,197,94,0.15);
    }
    .equipment-slot.tier-3 {
      border-color: rgba(37,99,235,0.55);
      background: rgba(37,99,235,0.12);
      box-shadow: 0 6px 14px rgba(37,99,235,0.18);
    }
    .equipment-slot.tier-4 {
      border-color: rgba(192,132,252,0.6);
      background: rgba(192,132,252,0.12);
      box-shadow: 0 6px 18px rgba(192,132,252,0.2);
    }
    .equipment-slot.tier-5 {
      border-color: rgba(251,191,36,0.75);
      background: rgba(251,191,36,0.18);
      box-shadow: 0 8px 20px rgba(251,191,36,0.22);
    }
    .equipment-slot.tier-1 .slot-icon { border-color: rgba(148,163,184,0.55); background: rgba(148,163,184,0.18); }
    .equipment-slot.tier-2 .slot-icon { border-color: rgba(34,197,94,0.65); background: rgba(34,197,94,0.22); }
    .equipment-slot.tier-3 .slot-icon { border-color: rgba(37,99,235,0.7); background: rgba(37,99,235,0.24); }
    .equipment-slot.tier-4 .slot-icon { border-color: rgba(192,132,252,0.75); background: rgba(192,132,252,0.25); }
    .equipment-slot.tier-5 .slot-icon { border-color: rgba(251,191,36,0.8); background: rgba(251,191,36,0.3); }
    .slot-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.78rem;
      color: var(--muted);
    }
    .slot-unequip {
      display: none;
    }
    .slot-body {
      display: flex;
      align-items: stretch;
      gap: 0.85rem;
      flex: 1;
      height: 100%;
    }
    .equipment-slot.equipped .slot-body {
      align-items: stretch;
    }
    .slot-icon {
      width: 130px;
      height: 100%;
      border-radius: 0.9rem;
      border: 1px solid rgba(148,163,184,0.35);
      background:
        radial-gradient(120% 120% at 20% 0%, rgba(255,255,255,0.08), transparent),
        rgba(3,8,23,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      gap: 0.4rem;
      padding: 0.45rem;
      position: relative;
      box-shadow: inset 0 0 32px rgba(2,6,23,0.8);
      align-self: stretch;
    }
    .slot-icon::after {
      content: "";
      position: absolute;
      inset: 0.25rem;
      border-radius: 0.7rem;
      border: 1px solid rgba(148,163,184,0.15);
      pointer-events: none;
    }
    .slot-icon img,
    .slot-icon svg,
    .item-icon img,
    .item-icon svg {
      width: var(--icon-visual-size);
      height: var(--icon-visual-size);
      max-width: none;
      max-height: none;
      transform-origin: center center;
      transform: scale(1.4); /* adjust scale factor as desired */
      object-fit: contain;
      display: block;
    }
    /* Allow the larger visual to overflow the small inventory icon box so sizes match visually */
    .slot-icon,
    .item-icon { overflow: visible; 
      box-shadow: inset 0 0 32px rgba(2,6,23,0.8);
    }

    .inventory-stat-badge {
      padding: 0.24rem 0.65rem;
      font-size: 0.72rem;
    }
    .slot-placeholder {
      font-size: 1.1rem;
      color: rgba(148,163,184,0.5);
    }
    .slot-info {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      gap: 0.6rem;
      flex: 1;
      height: 100%;
      min-width: 0;
      padding: 0.15rem 0;
    }
    .slot-stats {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 0;
    }
    @media (max-width: 720px) {
      .slot-row {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        grid-auto-rows: auto;
      }
      .slot-row.middle-row {
        align-items: stretch;
      }
      .slot-row.middle-row .hero-center {
        min-width: 0;
      }
      .slot-row .equipment-slot,
      .slot-row [data-equip-slot="weapon"],
      .slot-row [data-equip-slot="offhand"] {
        width: 100%;
        flex: 1 1 auto;
        height: auto;
      }
      .equipment-slot.tall {
        min-height: 140px;
      }
    }
    .inventory {
      flex: 1 1 240px;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .inventory-actions {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: wrap;
      margin-left: auto;
    }
    .inventory-filter-bar {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
      padding: 0.4rem 0.1rem;
    }
    .inventory-filter-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      flex: 1 1 auto;
    }
    .inventory-filter-btn {
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.3);
      background: rgba(148,163,184,0.12);
      color: var(--text);
      font-size: 0.8rem;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease, color 0.15s ease;
    }
    .inventory-filter-btn.active {
      border-color: rgba(245,158,11,0.65);
      background: var(--accent-soft);
      color: var(--accent);
    }
    .inventory-filter-bar .primary-btn {
      margin-left: auto;
    }
    .primary-btn {
      padding: 0.55rem 1.1rem;
      background: var(--accent);
      color: #1f2937;
      border: none;
      border-radius: 0.7rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .primary-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(245,158,11,0.25);
    }
    .primary-btn.secondary {
      background: rgba(148,163,184,0.18);
      color: var(--text);
      border: 1px solid rgba(148,163,184,0.35);
    }
    .primary-btn.secondary:hover {
      box-shadow: 0 10px 22px rgba(148,163,184,0.18);
      border-color: rgba(245,158,11,0.5);
    }
    .inventory h3 { margin: 0; font-size: 1rem; }
    .inventory-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .inventory-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.8rem;
      padding: 0.6rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.45);
      transition: border 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }
    .inventory-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(15,23,42,0.4);
    }
    .item-left {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex: 1;
    }
    .item-icon {
      width: var(--inventory-icon-frame);
      height: var(--inventory-icon-frame);
      padding: 0.35rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(148,163,184,0.35);
      background:
        radial-gradient(120% 120% at 20% 0%, rgba(255,255,255,0.08), transparent),
        rgba(3,8,23,0.88);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      flex-shrink: 0;
    }
    .item-icon::after {
      content: "";
      position: absolute;
      inset: 0.25rem;
      border-radius: 0.65rem;
      border: 1px solid rgba(148,163,184,0.2);
      pointer-events: none;
    }
    .item-icon img,
    .item-icon svg {
      width: calc(var(--inventory-icon-frame) - 18px);
      height: calc(var(--inventory-icon-frame) - 18px);
      max-width: 100%;
      max-height: 100%;
      display: block;
      transform: none;
    }
    .item-text { display: flex; flex-direction: column; gap: 0.2rem; }
    .item-text strong { font-size: 0.85rem; }
    .item-text span { font-size: 0.75rem; color: var(--muted); }
    .item-meta { font-size: 0.75rem; color: rgba(226,232,240,0.85); }
    .item-stats { display: flex; gap: 0.4rem; }
    .item-controls {
      display: flex;
      align-items: flex-start;
      gap: 0.6rem;
      flex-wrap: wrap;
    }
    .item-equip {
      padding: 0.4rem 0.9rem;
      border-radius: 0.65rem;
      border: 1px solid rgba(245,158,11,0.5);
      background: rgba(245,158,11,0.15);
      color: var(--text);
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }
    .item-equip:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(245,158,11,0.2);
    }
    .item-equip.equipped {
      background: rgba(245,158,11,0.15);
      color: var(--text);
    }
    .item-equip:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .item-upgrade {
      padding: 0.4rem 0.8rem;
      border-radius: 0.65rem;
      border: 1px solid rgba(248,250,252,0.18);
      background: rgba(248,250,252,0.08);
      color: var(--text);
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
    }
    .item-upgrade.tier-2 { border-color: rgba(34,197,94,0.55); background: rgba(34,197,94,0.18); color: #f8fafc; }
    .item-upgrade.tier-3 { border-color: rgba(37,99,235,0.6); background: rgba(37,99,235,0.2); color: #f8fafc; }
    .item-upgrade.tier-4 { border-color: rgba(192,132,252,0.65); background: rgba(192,132,252,0.2); color: #f8fafc; }
    .item-upgrade.tier-5 { border-color: rgba(251,191,36,0.75); background: rgba(251,191,36,0.25); color: #fff; }
    .item-upgrade.tier-6 { border-color: rgba(248,113,113,0.85); background: rgba(248,113,113,0.3); color: #fff5f5; box-shadow: 0 0 22px rgba(248,113,113,0.35); }
    .item-upgrade:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 26px rgba(59,130,246,0.25);
      border-color: rgba(59,130,246,0.55);
    }
    .item-upgrade:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      border-color: rgba(148,163,184,0.25);
    }
    .skill-bonus-indicator {
      flex: 1 1 220px;
      min-width: 180px;
      padding: 0.55rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(250,204,21,0.35);
      background: rgba(250,204,21,0.08);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      position: relative;
      transition: border 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
      cursor: default;
      user-select: none;
    }
    .skill-bonus-indicator::after {
      content: "";
      position: absolute;
      inset: 0.15rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(250,204,21,0.12);
      pointer-events: none;
    }
    .skill-bonus-indicator .skill-bonus-title {
      font-size: 0.75rem;
      letter-spacing: 0.02em;
      color: rgba(248,250,252,0.85);
    }
    .skill-bonus-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.55rem;
    }
    .skill-bonus-progress {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.55);
      overflow: hidden;
      border: 1px solid rgba(250,204,21,0.3);
    }
    .skill-bonus-progress-fill {
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, rgba(250,204,21,0.9), rgba(250,204,21,0.45));
      width: 0%;
      transition: width 0.35s ease, background-position 1.2s linear;
      background-size: 200% 100%;
      animation: skillBonusStripe 4.5s linear infinite;
    }
    @keyframes skillBonusStripe {
      0% { background-position: 0% 0; }
      100% { background-position: -200% 0; }
    }
    .skill-bonus-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.72rem;
      color: rgba(248,250,252,0.8);
    }
    .skill-bonus-meta span + span {
      margin-left: 0.4rem;
    }
    .skill-bonus-progress-label {
      margin-left: auto;
      font-variant-numeric: tabular-nums;
      font-size: 0.72rem;
      color: rgba(248,250,252,0.85);
    }
    .skill-bonus-ready {
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(250,204,21,0.6);
      background: rgba(250,204,21,0.15);
      font-size: 0.75rem;
      color: #fff;
    }
    .skill-bonus-indicator[data-skill-bonus-ready="true"],
    .skill-bonus-indicator[data-skill-upgrade-ready="true"] {
      border-color: rgba(250,204,21,0.8);
      box-shadow: 0 12px 28px rgba(250,204,21,0.22);
      cursor: pointer;
    }
    .skill-bonus-indicator[data-skill-bonus-ready="true"] .skill-bonus-progress,
    .skill-bonus-indicator[data-skill-upgrade-ready="true"] .skill-bonus-progress {
      border-color: rgba(250,204,21,0.65);
    }
    .skill-bonus-indicator.tier-1 {
      border-color: rgba(148,163,184,0.4);
      background: rgba(148,163,184,0.12);
    }
    .skill-bonus-indicator.tier-2 {
      border-color: rgba(74,222,128,0.4);
      background: rgba(34,197,94,0.12);
    }
    .skill-bonus-indicator.tier-3 {
      border-color: rgba(37,99,235,0.45);
      background: rgba(37,99,235,0.12);
    }
    .skill-bonus-indicator.tier-4 {
      border-color: rgba(192,132,252,0.45);
      background: rgba(192,132,252,0.12);
    }
    .skill-bonus-indicator.tier-5 {
      border-color: rgba(251,191,36,0.5);
      background: rgba(251,191,36,0.12);
    }
    .skill-bonus-indicator.tier-6 {
      border-color: rgba(248,113,113,0.55);
      background: rgba(248,113,113,0.14);
    }
    .inventory-item[data-skill-key] .item-left {
      flex: 0 0 52%;
      min-width: 280px;
    }
    .inventory-item[data-skill-key] .item-icon {
      flex: 0 0 auto;
    }
    .inventory-item[data-skill-key] .item-text {
      flex: 1 1 auto;
      min-width: 200px;
    }
    .inventory-item[data-skill-key] .item-controls {
      flex: 1 1 48%;
    }
    .inventory-item[data-skill-key] .skill-bonus-indicator {
      flex: 1 1 280px;
      max-width: 360px;
    }
    .shop-latest .inventory-item {
      align-items: stretch;
      gap: 0.75rem;
      border-color: rgba(148,163,184,0.35);
      background: linear-gradient(135deg, rgba(148,163,184,0.18), rgba(15,23,42,0.55));
    }
    .shop-latest .inventory-item .item-left {
      flex: 0 0 52%;
      min-width: 240px;
    }
    .shop-latest .inventory-item .item-text {
      flex: 1 1 auto;
      min-width: 180px;
    }
    .shop-latest .inventory-item .item-controls {
      flex: 1 1 48%;
      justify-content: flex-end;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .shop-latest .inventory-item .item-equip {
      display: none;
    }
    .shop-latest .inventory-item .skill-bonus-indicator {
      flex: 1 1 260px;
      max-width: 340px;
    }
    .shop-latest .skill-bonus-ready {
      display: none;
    }
    .inventory-item.tier-1 {
      border-color: rgba(148,163,184,0.35);
      background: linear-gradient(135deg, rgba(148,163,184,0.18), rgba(15,23,42,0.55));
    }
    .inventory-item.tier-2 {
      border-color: rgba(74,222,128,0.55);
      background: linear-gradient(135deg, rgba(34,197,94,0.28), rgba(15,23,42,0.55));
    }
    .inventory-item.tier-3 {
      border-color: rgba(37,99,235,0.66);
      background: linear-gradient(135deg, rgba(37,99,235,0.28), rgba(15,23,42,0.58));
    }
    .inventory-item.tier-4 {
      border-color: rgba(192,132,252,0.65);
      background: linear-gradient(135deg, rgba(168,85,247,0.3), rgba(15,23,42,0.6));
    }
    .inventory-item.tier-5 {
      border-color: rgba(251,191,36,0.75);
      background: linear-gradient(135deg, rgba(251,191,36,0.32), rgba(15,23,42,0.62));
      box-shadow: 0 14px 38px rgba(251,191,36,0.28);
    }
    .inventory-item.tier-6 {
      border-color: rgba(248,113,113,0.85);
      background: linear-gradient(135deg, rgba(248,113,113,0.36), rgba(76,5,25,0.7));
      box-shadow: 0 16px 44px rgba(248,113,113,0.3);
    }
    .inventory-item.tier-1 .item-icon { border-color: rgba(148,163,184,0.55); background: rgba(148,163,184,0.18); }
    .inventory-item.tier-2 .item-icon { border-color: rgba(34,197,94,0.65); background: rgba(34,197,94,0.22); }
    .inventory-item.tier-3 .item-icon { border-color: rgba(37,99,235,0.7); background: rgba(37,99,235,0.24); }
    .inventory-item.tier-4 .item-icon { border-color: rgba(192,132,252,0.75); background: rgba(192,132,252,0.25); }
    .inventory-item.tier-5 .item-icon { border-color: rgba(251,191,36,0.8); background: rgba(251,191,36,0.3); }
    .inventory-item.tier-6 .item-icon { border-color: rgba(248,113,113,0.9); background: rgba(248,113,113,0.35); }
    .badge.atk { background: rgba(248,113,113,0.5); border: 1px solid rgba(248,113,113,0.45); color: #fecaca; }
    .badge.def { background: rgba(96,165,250,0.5); border: 1px solid rgba(96,165,250,0.45); color: #bfdbfe; }
    .game-grid { display: flex; flex-wrap: wrap; gap: 1rem; }
    .game-grid .card { flex: 1 1 280px; }
    .statline { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .statline-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    #gachaBtn {
      padding: 0.6rem 1.2rem;
      background: var(--accent);
      color: #1f2937;
    }
    .battle-card { position: relative; }
    .battle-overview {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: stretch;
    }
    .battle-side {
      flex: 1 1 280px;
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 1rem;
      padding: 1.1rem;
      background: linear-gradient(145deg, rgba(15,23,42,0.92), rgba(15,23,42,0.75));
      box-shadow: inset 0 0 18px rgba(2,6,23,0.5);
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      position: relative;
      overflow: hidden;
    }
    .battle-side.hero {
      border-color: rgba(59,130,246,0.45);
      background: linear-gradient(145deg, rgba(15,23,42,0.95), rgba(30,64,175,0.4));
    }
    .battle-side.enemy {
      border-color: rgba(248,113,113,0.45);
      background: linear-gradient(145deg, rgba(36,12,23,0.95), rgba(153,27,27,0.35));
    }
    .battle-side.attacking {
      box-shadow: 0 18px 38px rgba(248,250,252,0.22);
      border-color: rgba(248,250,252,0.6);
    }
    .battle-side.hit {
      animation: battleHitPulse 0.4s ease;
    }
    @keyframes battleHitPulse {
      0% { transform: translateY(0); box-shadow: 0 0 0 rgba(248,250,252,0); }
      30% { transform: translateY(-2px); box-shadow: 0 12px 26px rgba(248,250,252,0.25); }
      100% { transform: translateY(0); box-shadow: 0 0 0 rgba(248,250,252,0); }
    }
    .battle-side-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
    }
    .battle-side-label {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(248,250,252,0.75);
    }
    .battle-side-head h3 {
      margin: 0.15rem 0 0;
      font-size: 1.1rem;
    }
    .battle-side-tier {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(248,250,252,0.25);
      font-size: 0.75rem;
      color: rgba(248,250,252,0.85);
    }
    .battle-trait {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      border-radius: 999px;
      border: 1px solid rgba(248,250,252,0.25);
      padding: 0.1rem 0.55rem;
      font-size: 0.7rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(248,250,252,0.75);
    }
    .battle-trait::before {
      content: "✧";
      font-size: 0.8rem;
      color: inherit;
    }
    .battle-portrait {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 1px solid rgba(248,250,252,0.25);
      background: radial-gradient(circle at 40% 30%, rgba(248,250,252,0.2), transparent 60%),
        rgba(15,23,42,0.4);
      margin: 0 auto;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 18px 30px rgba(15,23,42,0.45);
    }
    .battle-portrait.hero {
      border-color: rgba(59,130,246,0.55);
    }
    .battle-portrait.enemy {
      border-color: rgba(248,113,113,0.55);
    }
    .battle-portrait-icon {
      font-size: 2rem;
      color: rgba(248,250,252,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }
    .battle-portrait.enemy .battle-portrait-icon {
      font-size: 2.8rem;
    }
    .battle-portrait-icon img {
      width: 70%;
      height: auto;
      filter: drop-shadow(0 6px 12px rgba(15,23,42,0.6));
    }
    .battle-statline {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .battle-stat-badge {
      padding: 0.25rem 0.6rem;
      border-radius: 0.65rem;
      font-size: 0.75rem;
      letter-spacing: 0.03em;
      border: 1px solid rgba(148,163,184,0.35);
      color: rgba(248,250,252,0.9);
    }
    .battle-stat-badge strong {
      margin-left: 0.2rem;
    }
    .battle-side-meta {
      margin: 0;
      font-size: 0.78rem;
      color: rgba(248,250,252,0.75);
    }
    .battle-gear {
      margin-top: 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .battle-gear-label {
      font-size: 0.72rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(248,250,252,0.65);
    }
    .battle-gear-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
    }
    .battle-gear-card {
      border-radius: 0.75rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.4);
      padding: 0.45rem 0.55rem;
      display: flex;
      gap: 0.45rem;
      align-items: center;
      min-height: 80px;
    }
    .battle-gear-card .gear-icon {
      width: 46px;
      height: 46px;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .battle-gear-card .gear-icon img,
    .battle-gear-card .gear-icon svg {
      width: 80%;
      height: 80%;
      object-fit: contain;
    }
    .battle-gear-card .gear-text {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      font-size: 0.74rem;
    }
    .battle-gear-card .gear-text strong {
      font-size: 0.78rem;
      color: rgba(248,250,252,0.95);
    }
    .battle-gear-card .gear-text span {
      color: rgba(226,232,240,0.8);
    }
    .battle-gear-card .gear-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }
    .battle-gear-card .gear-stats .badge {
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
    }
    .battle-gear-empty {
      opacity: 0.65;
      font-style: italic;
      grid-column: 1 / -1;
    }
    .battle-center {
      flex: 1 1 320px;
      min-width: 280px;
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 1rem;
      background: linear-gradient(135deg, rgba(8,47,73,0.9), rgba(15,23,42,0.85));
      box-shadow: inset 0 0 24px rgba(2,6,23,0.55);
      padding: 1.4rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .battle-crest {
      text-align: center;
    }
    .battle-crest-label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: 2px solid rgba(248,250,252,0.35);
      font-size: 1.6rem;
      letter-spacing: 0.1em;
      color: rgba(248,250,252,0.9);
      box-shadow: 0 15px 40px rgba(15,23,42,0.45);
    }
    .battle-crest p {
      margin: 0.7rem 0 0;
      font-size: 0.85rem;
      color: rgba(226,232,240,0.85);
    }
    .battle-center-actions {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }
    .battle-log {
      margin: 0;
    }
    #battleLog {
      display: none;
    }
    @media (max-width: 900px) {
      .battle-side,
      .battle-center {
        flex: 1 1 100%;
      }
      .battle-portrait {
        margin: 0.5rem auto;
      }
      .battle-gear-list {
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      }
    }
    .battle-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }
    .battle-btn {
      flex: 1 1 150px;
      padding: 0.6rem 1rem;
      background: rgba(245,158,11,0.18);
      border: 1px solid rgba(245,158,11,0.45);
      color: var(--text);
      transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
    }
    .battle-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 22px rgba(245,158,11,0.22);
      border-color: rgba(245,158,11,0.7);
    }
    .battle-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
      border-color: rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.35);
    }
    .gacha-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.9rem;
      margin-top: 1rem;
    }
    .gacha-option {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
      padding: 1.2rem 1rem;
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(148,163,184,0.12);
      cursor: pointer;
      color: var(--text);
      transition: all 0.2s ease;
      text-align: center;
      min-height: 150px;
    }
    .gacha-option input { display: none; }
    .gacha-option .gacha-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(15,23,42,0.45);
    }
    .gacha-option .gacha-icon svg {
      width: 40px;
      height: 40px;
      color: var(--accent);
    }
    .gacha-option .gacha-label {
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.01em;
    }
    .gacha-remaining {
      font-size: 0.78rem;
      color: var(--muted);
      letter-spacing: 0.01em;
    }
    .gacha-option.active {
      border-color: rgba(245,158,11,0.6);
      background: rgba(245,158,11,0.18);
      transform: translateY(-2px);
      box-shadow: 0 10px 24px rgba(245,158,11,0.18);
    }
    .shop-buy-btn {
      width: 100%;
      margin-top: 1.2rem;
      padding: 1rem 1.2rem;
      font-size: 1rem;
      border-radius: 1rem;
      background: linear-gradient(135deg, rgba(245,158,11,0.9), rgba(248,196,69,0.95));
      color: #1f2937;
      font-weight: 700;
      border: 1px solid rgba(245,158,11,0.9);
      box-shadow: 0 14px 28px rgba(245,158,11,0.35);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }
    .shop-buy-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 34px rgba(245,158,11,0.4);
    }
    .shop-buy-btn:active {
      transform: translateY(0);
      box-shadow: 0 8px 20px rgba(245,158,11,0.3);
    }
    @media (max-width: 640px) {
      .gacha-options {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .gacha-option {
        min-height: 130px;
        padding: 1rem 0.8rem;
      }
      .gacha-option .gacha-label {
        font-size: 0.9rem;
      }
    }
    .battle-log {
      display: none;
      margin-top: 0;
      background: rgba(8,15,35,0.65);
      border: 1px solid rgba(148,163,184,0.3);
      border-radius: 0.85rem;
      padding: 0.75rem 0.85rem;
      font-size: 0.82rem;
      color: rgba(226,232,240,0.85);
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .battle-entry {
      position: relative;
      padding-left: 1.2rem;
      line-height: 1.35;
    }
    .battle-entry::before {
      content: "";
      position: absolute;
      left: 0.35rem;
      top: 0.55rem;
      width: 0.4rem;
      height: 0.4rem;
      border-radius: 50%;
      border: 2px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
    }
    .battle-entry-hero {
      color: rgba(125,211,252,0.95);
    }
    .battle-entry-hero::before {
      border-color: rgba(59,130,246,0.8);
    }
    .battle-entry-enemy {
      color: rgba(252,165,165,0.95);
    }
    .battle-entry-enemy::before {
      border-color: rgba(248,113,113,0.8);
    }
    .battle-entry-system {
      color: rgba(226,232,240,0.85);
      opacity: 0.85;
    }
    .skill-wrapper {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
      align-items: stretch;
    }
    .skill-avatar {
      --skill-svg-min: 240px;
      --skill-svg-fluid: 28vw;
      --skill-svg-max: 420px;
      min-width: 210px;
      min-height: 252px;
      padding: clamp(0.95rem, 2.2vw, 1.7rem);
      width: fit-content;
      height: fit-content;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: linear-gradient(155deg, rgba(32,27,68,0.95), rgba(15,23,42,0.85));
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: inset 0 0 16px rgba(8,15,30,0.7);
      overflow: hidden;
      align-self: center;
    }
    .skill-avatar::before {
      content: "";
      position: absolute;
      inset: clamp(14px, 2vw, 22px);
      border-radius: 0.85rem;
      background: radial-gradient(circle at 50% 40%, rgba(59,130,246,0.35), rgba(99,102,241,0.2), rgba(15,23,42,0));
      opacity: 0.75;
      filter: blur(0.4px);
    }
    .skill-avatar svg {
      width: clamp(var(--skill-svg-min), var(--skill-svg-fluid), var(--skill-svg-max));
      height: auto;
      display: block;
      position: relative;
      z-index: 1;
      transform: translateY(-4%);
    }
    .skill-svg {
      width: 120px;
      height: 150px;
      position: relative;
      z-index: 1;
    }
    .skill-avatar .spellbook-glow {
      animation: spellbookGlow 6.2s ease-in-out infinite;
      transform-origin: 50% 45%;
    }
    @keyframes spellbookGlow {
      0%, 100% {
        opacity: 0.55;
        transform: scale(0.92);
      }
      45% {
        opacity: 0.98;
        transform: scale(1.07);
      }
    }
    .skill-avatar .spellbook-page {
      stroke: rgba(203,213,225,0.85);
      stroke-width: 1.5;
    }
    .skill-avatar .spellbook-page-turn {
      stroke: rgba(148,163,184,0.55);
      stroke-width: 1.2;
      transform-box: fill-box;
      transform-origin: 55% 55%;
    }
    .skill-avatar .spellbook-bookmark {
      transform-box: fill-box;
      transform-origin: 50% 8%;
      animation: spellbookBookmark 5.8s ease-in-out infinite;
      animation-delay: 0.6s;
    }
    @keyframes spellbookBookmark {
      0%, 100% { transform: rotate(3deg); }
      50% { transform: rotate(-5deg); }
    }
    .skill-avatar .spellbook-rune {
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: 28;
      animation: spellbookRunePulse 7s ease-in-out infinite;
    }
    .skill-avatar .spellbook-rune.rune-2 {
      animation-delay: 1.4s;
    }
    @keyframes spellbookRunePulse {
      0%, 100% {
        stroke-dashoffset: 28;
        opacity: 0.2;
      }
      40% {
        stroke-dashoffset: 12;
        opacity: 0.85;
      }
      65% {
        stroke-dashoffset: 0;
        opacity: 1;
      }
    }
    .skill-avatar .spellbook-sparkle {
      fill: rgba(224,242,254,0.9);
      transform-box: fill-box;
      transform-origin: center;
      animation: spellbookSparkle 6.4s ease-in-out infinite;
    }
    .skill-avatar .spellbook-sparkle.sparkle-2 { animation-delay: 1.8s; }
    .skill-avatar .spellbook-sparkle.sparkle-3 { animation-delay: 3.2s; }
    @keyframes spellbookSparkle {
      0% {
        opacity: 0;
        transform: scale(0.6) translateY(0);
      }
      25% {
        opacity: 1;
        transform: scale(1) translateY(-4px);
      }
      55% {
        opacity: 0.7;
        transform: scale(1.08) translateY(-10px);
      }
      100% {
        opacity: 0;
        transform: scale(0.5) translateY(-16px);
      }
    }
    .skill-compendium {
      flex: 1 1 240px;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .skill-compendium h3 {
      margin: 0;
      font-size: 1rem;
    }
    .skill-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .skill-empty {
      padding: 0.75rem 0.85rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148,163,184,0.3);
      background: rgba(15,23,42,0.35);
      font-size: 0.85rem;
      color: var(--muted);
      text-align: center;
    }
    .shop-latest {
      margin-top: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .shop-latest h3 {
      margin: 0;
      font-size: 0.95rem;
    }
    .shop-latest-empty {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .battle-sim {
      margin-bottom: 1rem;
      border: 1px solid var(--border);
      border-radius: 1.2rem;
      background:
        radial-gradient(circle at 15% -20%, rgba(59,130,246,0.1), transparent 55%),
        radial-gradient(circle at 85% -10%, rgba(248,113,113,0.1), transparent 55%),
        rgba(15,23,42,0.92);
      box-shadow: 0 22px 60px rgba(8,15,30,0.45);
      padding: 1.1rem 1.25rem 1.35rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      position: relative;
      overflow: hidden;
    }
    .battle-sim.hidden {
      display: none;
    }
    .battle-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }
    .battle-header h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .battle-close {
      background: transparent;
      border: 1px solid rgba(148,163,184,0.35);
      color: var(--muted);
      width: 34px;
      height: 34px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-size: 1rem;
    }
    .battle-close:hover {
      color: var(--text);
      border-color: rgba(245,158,11,0.6);
    }
    .battle-arena {
      --battle-art: none;
      --battle-art-size: cover;
      --battle-art-position: center;
      position: relative;
      height: 220px;
      background-color: transparent;
      background-image: var(--battle-art);
      background-size: var(--battle-art-size);
      background-position: var(--battle-art-position);
      background-repeat: no-repeat;
      filter: saturate(1.25) brightness(1.05);
      border: 1px solid rgba(148,163,184,0.25);
      border-radius: 0.9rem;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      padding: 1.5rem 2rem;
      overflow: hidden;
    }
    .battle-arena::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 30% -10%, rgba(59,130,246,0.018), transparent 65%),
        radial-gradient(circle at 70% -20%, rgba(248,113,113,0.02), transparent 60%);
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .battle-arena[data-battle-theme="forest"] {
      --battle-art: url("assets/battle-bg-forest.svg");
    }
    .battle-arena[data-battle-theme="mountain"] {
      --battle-art: url("assets/battle-bg-mountain.svg");
    }
    .battle-arena[data-battle-theme="celestial"] {
      --battle-art: url("assets/battle-bg-celestial.svg");
      --battle-art-position: center top;
    }
    .battle-arena::after {
      content: "";
      position: absolute;
      inset: auto 0 0;
      height: 80px;
      background: linear-gradient(180deg, rgba(30,41,59,0.12), rgba(15,23,42,0.55));
    }
    @keyframes arenaGlow {
      0%, 100% { transform: translate(-5%, -5%) scale(1); opacity: 0.35; }
      50% { transform: translate(5%, 5%) scale(1.1); opacity: 0.65; }
    }
    .modal-battle-overview {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
    }
    .modal-battle-card {
      flex: 1 1 240px;
      border-radius: 0.85rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: linear-gradient(155deg, rgba(15,23,42,0.92), rgba(8,15,35,0.75));
      padding: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      box-shadow: inset 0 0 18px rgba(2,6,23,0.45);
    }
    .modal-battle-card.hero {
      border-color: rgba(59,130,246,0.35);
    }
    .modal-battle-card.enemy {
      border-color: rgba(248,113,113,0.35);
    }
    .modal-card-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.6rem;
    }
    .modal-card-art {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0.25rem 0 0.5rem;
    }
    .modal-card-art img {
      width: 92px;
      height: auto;
      filter: drop-shadow(0 8px 16px rgba(2,6,23,0.55));
    }
    .modal-card-head h4 {
      margin: 0.15rem 0 0;
      font-size: 1rem;
    }
    .modal-card-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .modal-card-meta {
      margin: 0;
      font-size: 0.75rem;
      color: rgba(226,232,240,0.85);
    }
    .arena-particles {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }
    .arena-particles span {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(248,250,252,0.65);
      opacity: 0.4;
      box-shadow: 0 0 8px rgba(248,250,252,0.8);
      animation: particleDrift 6s linear infinite;
    }
    .arena-particles span:nth-child(2) { animation-duration: 7s; background: rgba(59,130,246,0.8); }
    .arena-particles span:nth-child(3) { animation-duration: 8s; background: rgba(248,113,113,0.8); }
    .arena-particles span:nth-child(4) { animation-duration: 9s; }
    .arena-particles span:nth-child(5) { animation-duration: 10s; background: rgba(251,191,36,0.85); }
    .arena-particles span:nth-child(6) { animation-duration: 11s; }
    .arena-particles span:nth-child(7) { animation-duration: 12s; }
    .arena-particles span:nth-child(8) { animation-duration: 13s; }
    @keyframes particleDrift {
      0% { transform: translateY(20px) scale(0.8); opacity: 0; }
      10% { opacity: 0.5; }
      50% { opacity: 0.8; }
      100% { transform: translateY(-220px) scale(1.2); opacity: 0; }
    }
    .fighter {
      position: relative;
      width: 92px;
      height: 92px;
      border-radius: 0.6rem;
      background: rgba(30,41,59,0.8);
      border: 2px solid rgba(148,163,184,0.45);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 0.4rem;
      overflow: visible;
    }
    .fighter::before {
      content: "";
      position: absolute;
      width: 56px;
      height: 56px;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      image-rendering: pixelated;
    }
    .fighter::after {
      content: "";
      position: absolute;
      width: 32px;
      height: 12px;
      top: 34px;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 4px;
    }
    .fighter.knight::before {
      background: linear-gradient(180deg, #9ca3af 0%, #64748b 65%, #334155 100%);
      border-radius: 6px;
      box-shadow:
        0 -16px 0 0 #cbd5f5 inset,
        0 -30px 0 0 #475569 inset;
    }
    .fighter.knight::after {
      background: linear-gradient(90deg, #0f172a 0 24%, #38bdf8 24% 76%, #0f172a 76% 100%);
      box-shadow: 0 6px 0 0 #1f2937;
    }
    .fighter.enemy::before {
      display: none;
    }
    .fighter.enemy::after {
      background: linear-gradient(90deg, #111827 0 30%, #bef264 30% 70%, #111827 70% 100%);
      border-radius: 3px;
      box-shadow:
        -12px 0 0 -4px rgba(255,255,255,0.08),
        12px 0 0 -4px rgba(255,255,255,0.08);
    }
    .fighter-sprite {
      position: absolute;
      width: 80px;
      max-width: 90%;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
      filter: drop-shadow(0 10px 20px rgba(3,7,18,0.6));
    }
    .fighter-name {
      position: absolute;
      bottom: -1.6rem;
      font-size: 0.78rem;
      letter-spacing: 0.02em;
      color: var(--muted);
    }
    .fighter.attacking-left { animation: attackLeft 0.5s ease-out; }
    .fighter.attacking-right { animation: attackRight 0.5s ease-out; }
    .fighter.hit { animation: hitFlash 0.42s ease-out; }
    .battle-bars {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }
    .hp-row {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.85rem;
    }
    .hp-track {
      flex: 1;
      height: 12px;
      border-radius: 999px;
      background: rgba(15,23,42,0.6);
      border: 1px solid rgba(148,163,184,0.35);
      overflow: hidden;
    }
    .hp-fill {
      height: 100%;
      width: 100%;
      transition: width 0.25s ease;
    }
    .hp-fill.hero {
      background: linear-gradient(90deg, #38bdf8, #0ea5e9);
    }
    .hp-fill.enemy {
      background: linear-gradient(90deg, #f97316, #ef4444);
    }
    .hp-value {
      width: 74px;
      text-align: right;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }
    .battle-foot {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .battle-result {
      margin: 0;
      min-height: 1.4rem;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .battle-skill-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.6rem 0;
      border-top: 1px solid rgba(148,163,184,0.2);
      border-bottom: 1px solid rgba(148,163,184,0.2);
      margin: 0.4rem 0;
    }
    .battle-skill {
      flex: 1 1 180px;
      min-width: 160px;
      padding: 0.45rem 0.6rem;
      border-radius: 0.65rem;
      background: rgba(59,130,246,0.18);
      border: 1px solid rgba(59,130,246,0.45);
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .battle-skill.headline {
      flex: 1 1 100%;
      border: none;
      background: transparent;
      padding: 0;
      min-width: 100%;
    }
    .battle-skill button {
      all: unset;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      cursor: pointer;
      font-weight: 600;
      color: var(--text);
    }
    .battle-skill button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .battle-skill-hotkey {
      background: rgba(148,163,184,0.2);
      color: var(--text);
      border-radius: 0.55rem;
      padding: 0.1rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.03em;
    }
    .battle-skill-desc {
      font-size: 0.78rem;
      color: rgba(226,232,240,0.75);
    }
    .battle-skill.used {
      background: rgba(71,85,105,0.25);
      border-color: rgba(71,85,105,0.55);
    }
    .battle-next {
      align-self: flex-end;
      padding: 0.55rem 1.1rem;
      background: var(--accent);
      color: #1f2937;
      border-radius: 0.75rem;
      border: none;
      font-weight: 600;
      box-shadow: 0 12px 28px rgba(245,158,11,0.28);
    }
    .battle-next.hidden { display: none; }
    .damage-float {
      position: absolute;
      left: 50%;
      top: 45%;
      transform: translate(-50%, -10px);
      font-size: 1.1rem;
      font-weight: 700;
      color: #f87171;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
      animation: damageFloat 1s ease-out forwards;
      pointer-events: none;
      white-space: nowrap;
    }
    .damage-float.hero-hit {
      color: #38bdf8;
    }
    .damage-float.enemy-hit {
      color: #f87171;
    }
    .damage-float.crit {
      color: #fde68a;
      text-shadow: 0 0 12px rgba(250,204,21,0.9);
    }
    .damage-float.heal {
      color: #34d399;
      text-shadow: 0 2px 8px rgba(16,185,129,0.4);
    }
    .status-float {
      position: absolute;
      left: 50%;
      top: 45%;
      transform: translate(-50%, -10px);
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      color: #e2e8f0;
      text-shadow: 0 2px 8px rgba(0,0,0,0.45);
      animation: damageFloat 1s ease-out forwards;
      pointer-events: none;
      white-space: nowrap;
    }
    .status-float.buff {
      color: #4ade80;
    }
    .status-float.debuff {
      color: #fbbf24;
    }
    @keyframes damageFloat {
      0% {
        opacity: 0;
        transform: translate(-50%, -10px) scale(0.85);
      }
      15% {
        opacity: 1;
        transform: translate(-50%, -24px) scale(1.05);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -80px) scale(1.1);
      }
    }
    @keyframes attackLeft {
      0% { transform: translateX(0); }
      40% { transform: translateX(60px); }
      60% { transform: translateX(60px); }
      100% { transform: translateX(0); }
    }
    @keyframes attackRight {
      0% { transform: translateX(0); }
      40% { transform: translateX(-60px); }
      60% { transform: translateX(-60px); }
      100% { transform: translateX(0); }
    }
    @keyframes hitFlash {
      0% { filter: brightness(1); transform: translateY(0); }
      25% { filter: brightness(1.8); transform: translateY(-6px); }
      100% { filter: brightness(1); transform: translateY(0); }
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #coinAnimationLayer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 120;
    }
    .coin-celebration {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      transform: translate(-50%, -50%);
      animation: coinCelebrationRise 2.95s ease-out forwards;
    }
    .coin-main {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,241,179,0.95), rgba(245,158,11,0.95) 55%, rgba(161,98,7,0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 32px rgba(245,158,11,0.8), 0 0 70px rgba(245,158,11,0.4);
      border: 3px solid rgba(255,248,220,0.4);
      animation: coinMainPulse 2.81s ease-out forwards;
      position: relative;
      overflow: hidden;
    }
    .coin-main::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(255,255,255,0.6), rgba(255,255,255,0));
      mix-blend-mode: screen;
      transform: translateX(-120%);
      animation: coinShine 2.81s ease-out forwards;
    }
    .coin-symbol {
      font-size: 48px;
      color: #1f2937;
      text-shadow: 0 4px 12px rgba(0,0,0,0.35);
      animation: coinSymbolPop 2.34s ease-out forwards;
    }
    .coin-amount {
      margin-top: 0.6rem;
      font-size: 1.15rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: #fef3c7;
      text-shadow: 0 0 10px rgba(245,158,11,0.8);
      animation: coinAmountRise 2.73s ease-out forwards;
    }
    .coin-spark {
      --targetX: 0px;
      --targetY: -120px;
      position: absolute;
      width: 34px;
      height: 34px;
      left: 50%;
      top: 45%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fef3c7, #f59e0b);
      border: 2px solid rgba(255,255,255,0.55);
      box-shadow: 0 0 16px rgba(245,158,11,0.6);
      opacity: 0;
      animation: coinSparkFly 2.34s ease-out forwards;
    }
    .coin-spark::after {
      content: "💰";
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #1f2937;
    }
    .coin-badge-boost {
      animation: coinBadgePulse 2.6s ease-out;
    }
    .coin-celebration.loss .coin-main {
      background: radial-gradient(circle at 30% 30%, rgba(254,205,211,0.95), rgba(248,113,113,0.95) 55%, rgba(127,29,29,0.95));
      box-shadow: 0 0 32px rgba(248,113,113,0.8), 0 0 70px rgba(248,113,113,0.35);
      border-color: rgba(254,226,226,0.5);
    }
    .coin-celebration.loss .coin-symbol {
      color: #7f1d1d;
      text-shadow: 0 4px 12px rgba(127,29,29,0.55);
    }
    .coin-celebration.loss .coin-amount {
      color: #fecaca;
      text-shadow: 0 0 12px rgba(248,113,113,0.7);
    }
    .coin-celebration.loss .coin-spark {
      background: radial-gradient(circle at 30% 30%, rgba(254,226,226,1), rgba(248,113,113,0.95));
      border-color: rgba(254,226,226,0.65);
      box-shadow: 0 0 16px rgba(248,113,113,0.6);
    }
    .coin-celebration.loss .coin-spark::after {
      content: "💸";
      color: #7f1d1d;
    }
    .coin-badge-loss {
      animation: coinBadgeLoss 2.6s ease-out;
    }
    @keyframes coinCelebrationRise {
      0% {
        opacity: 0;
        transform: translate(-50%, -20%) scale(0.6);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -60%) scale(1.02);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -120%) scale(0.98);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -160%) scale(0.9);
      }
    }
    @keyframes coinMainPulse {
      0% { transform: scale(0.4) rotate(-12deg); }
      45% { transform: scale(1.1) rotate(6deg); }
      80% { transform: scale(1); }
      100% { transform: scale(0.92); }
    }
    @keyframes coinShine {
      0% { transform: translateX(-120%); }
      50% { transform: translateX(0%); }
      100% { transform: translateX(120%); }
    }
    @keyframes coinSymbolPop {
      0% { opacity: 0; transform: scale(0.4) rotate(-30deg); }
      50% { opacity: 1; transform: scale(1.15) rotate(10deg); }
      100% { opacity: 1; transform: scale(1) rotate(0deg); }
    }
    @keyframes coinAmountRise {
      0% { opacity: 0; transform: translateY(24px); }
      35% { opacity: 1; transform: translateY(-6px); }
      100% { opacity: 0; transform: translateY(-40px); }
    }
    @keyframes coinSparkFly {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
      25% { opacity: 1; }
      100% { opacity: 0; transform: translate(calc(-50% + var(--targetX)), calc(-50% + var(--targetY))) scale(0.15); }
    }
    @keyframes coinBadgePulse {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245,158,11,0.6); }
      35% { transform: scale(1.2); box-shadow: 0 0 32px 10px rgba(245,158,11,0.35); }
      70% { transform: scale(1.05); box-shadow: 0 0 12px 4px rgba(245,158,11,0.2); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245,158,11,0); }
    }
    @keyframes coinBadgeLoss {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(248,113,113,0.55); }
      35% { transform: scale(1.18); box-shadow: 0 0 32px 10px rgba(248,113,113,0.3); }
      70% { transform: scale(0.96); box-shadow: 0 0 12px 4px rgba(248,113,113,0.18); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(248,113,113,0); }
    }
    @media (max-width: 720px) {
      header { flex-direction: column; align-items: flex-start; gap: 0.75rem; }
      .hero-avatar { width: 130px; height: 160px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <span class="title">Shortcut Ritter-Akademie</span>
      <button class="mobile-nav-toggle" id="mobileNavToggle" type="button" aria-expanded="false" aria-controls="topNav">Menü &#8801;</button>
      <div class="top-nav" id="topNav">
        <button class="nav-toggle active" data-view="learn">Training</button>
        <button class="nav-toggle" data-view="inventory">Inventar</button>
        <button class="nav-toggle" data-view="skills">Skills</button>
        <button class="nav-toggle" data-view="shop">Shop</button>
        <button class="nav-toggle" data-view="battle">Battle</button>
      </div>
    </div>
    <div class="header-right">
      <span class="badge" id="coinTop">Coins: 0</span>
    </div>
  </header>
  <div id="coinAnimationLayer"></div>
  <main>
    <section id="learnView" class="view active">
      <div class="card nav-card">
        <div class="nav-row" id="sectionTabs"></div>
        <p class="small">Jede perfekte Lösung bringt 10 Coins pro Aufgabe (3 Aufgaben = 30 Coins). Nach Zuruecksetzen gibt es 5 Coins pro Aufgabe.</p>
      </div>
      <div id="learnSections"></div>
      <div class="card" id="overviewCard">
        <h2>Gesamtuebersicht</h2>
        <p class="small" id="overallSummary">Noch keine Ergebnisse.</p>
      </div>
    </section>
    <section id="inventoryView" class="view">
      <div class="game-grid">
        <div class="card" id="playerCard">
        <div class="statline-row">
          <div class="statline">
            <span class="badge" id="atkDisplay">ATK 1</span>
            <span class="badge" id="defDisplay">DEF 0</span>
            <span class="badge" id="hpDisplay">HP 0</span>
            <span class="badge" id="itemsDisplay">Gear: 0/0</span>
          </div>
          <div class="inventory-actions">
            <button id="testAnimationBtn" class="primary-btn" type="button">Animation testen</button>
          </div>
        </div>
        <div class="hero-wrapper">
          <div class="equipment-layout">
            <div class="slot-row top-row">
              <div class="equipment-slot" data-equip-slot="gloves">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Handschuhe</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="gloves" aria-label="Handschuhe entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="equipment-slot" data-equip-slot="helm">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Helm</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="helm" aria-label="Helm entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="equipment-slot" data-equip-slot="necklace">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Halskette</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="necklace" aria-label="Halskette entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
            </div>
            <div class="slot-row middle-row">
              <div class="equipment-slot tall" data-equip-slot="weapon">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Schwert</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="weapon" aria-label="Schwert entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="hero-center">
                <div class="hero-avatar" id="heroAvatar" data-atk-tier="1" data-def-tier="1">
                  <img
                    id="heroAvatarImage"
                    class="hero-illustration is-blueprint"
                    src="assets/blueprint_clean.svg"
                    alt="Blueprint deines Helden"
                    loading="lazy"
                  />
                </div>
              </div>
              <div class="equipment-slot tall" data-equip-slot="offhand">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Schwert 2 / Schild</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="offhand" aria-label="Schild entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
            </div>
            <div class="slot-row bottom-row">
              <div class="equipment-slot" data-equip-slot="ring_left">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Ring / Amulett 1</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="ring_left" aria-label="Ring links entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="equipment-slot" data-equip-slot="boots">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Stiefel</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="boots" aria-label="Stiefel entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="equipment-slot" data-equip-slot="ring_right">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Ring / Amulett 2</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="ring_right" aria-label="Ring rechts entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="inventory">
            <div class="inventory-filter-bar" aria-label="Inventarfilter">
              <div class="inventory-filter-buttons" role="group" aria-label="Kategorie wählen">
                <button class="inventory-filter-btn active" type="button" data-inventory-filter="weapon" aria-pressed="true">Waffe</button>
                <button class="inventory-filter-btn" type="button" data-inventory-filter="armor" aria-pressed="false">Ausrüstung</button>
                <button class="inventory-filter-btn" type="button" data-inventory-filter="accessory" aria-pressed="false">Accessoire</button>
              </div>
              <button id="autoEquipBtn" class="primary-btn secondary" type="button">Auto anlegen</button>
            </div>
            <div id="inventoryList" class="inventory-list"></div>
            <div id="inventoryFilterEmpty" class="skill-empty" hidden>Keine Items in dieser Kategorie.</div>
            <div id="inventoryEmpty" class="skill-empty">Noch keine Ausrüstung vorhanden. Besuche den Shop, um neue Items zu kaufen.</div>
          </div>
        </div>
      </div>
    </section>
    <section id="skillsView" class="view">
      <div class="game-grid">
        <div class="card" id="skillCard">
          <div class="skill-wrapper">
            <div class="skill-avatar" aria-hidden="true">
          <!--    <svg class="skill-svg" viewBox="0 0 120 150" xmlns="http://www.w3.org/2000/svg" role="img" aria-labelledby="skillSpellbookTitle">
          -->

                <svg viewBox="35 0 140 190" xmlns="http://www.w3.org/2000/svg" role="img" preserveAspectRatio="xMidYMid meet">
  <defs>
    <filter id="emblemGlow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="3" result="blur"/>
      <feMerge>
        <feMergeNode in="blur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
    <!-- Funken-Basis: 60s wie Mond -->
    <circle id="spark" cx="0" cy="0" r="2" fill="#ffe9a9">
      <animate attributeName="fill"
               values="#ffe9a9;#ffe9a9;#9b5cff;#9b5cff;#ffe9a9"
               keyTimes="0;0.4667;0.5;0.9667;1"
               dur="60s"
               repeatCount="indefinite" />
    </circle>
  </defs>

  <g id="book" transform="translate(0,6.6)">
    <!-- Spine -->
    <rect x="43" y="25" width="7" height="140" fill="#5a371e" stroke="#3f2411" stroke-width="2"/>

    <!-- Book cover -->
    <path d="M50 25 H160 a6 6 0 0 1 6 6 V159 a6 6 0 0 1 -6 6 H50 Z"
          fill="#7b4b26" stroke="#3f2411" stroke-width="3" />

    <!-- Pages -->
    <rect x="160" y="31" width="3" height="130" rx="1.5" ry="1.5"
          fill="#f3e7d4" stroke="#c8b49a" stroke-width="1"/>

    <!-- Emblem + Glow -->
    <g filter="url(#emblemGlow)">
      <circle cx="105" cy="85" r="28" fill="#f3e7d4" stroke="#caa052" stroke-width="3">
        <animate attributeName="fill"
                 values="#f3e7d4;#f3e7d4;#2b2b2b;#2b2b2b;#f3e7d4"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 repeatCount="indefinite" />
      </circle>
      <circle cx="105" cy="85" r="30" fill="none" stroke="#ffe9a9" stroke-width="1.5" opacity="0.4">
        <animate attributeName="r" values="28;35;28" dur="3s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0.1;0.5;0.1" dur="3s" repeatCount="indefinite" />
        <animate attributeName="stroke"
                 values="#ffe9a9;#ffe9a9;#9b5cff;#9b5cff;#ffe9a9"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 repeatCount="indefinite" />
      </circle>
    </g>

    <!-- MOND -->
    <g>
      <circle cx="105" cy="85" r="12" fill="#caa052">
        <animate attributeName="r"
                 values="12;13;12"
                 keyTimes="0;0.5;1"
                 dur="20s"
                 repeatCount="indefinite"
                 calcMode="spline"
                 keySplines="0.42 0 0.58 1; 0.42 0 0.58 1" />
        <animate attributeName="fill"
                 values="#caa052;#caa052;#9b5cff;#9b5cff;#caa052"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 repeatCount="indefinite" />
      </circle>
      <!-- Cutout fährt im selben Takt und färbt mit -->
      <circle cx="111" cy="82" r="10" fill="#f3e7d4">
        <animate attributeName="cx"
                 values="111;111;99;99;111"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 calcMode="spline"
                 keySplines="0 0 1 1;
                             0.42 0 0.58 1;
                             0 0 1 1;
                             0.42 0 0.58 1"
                 repeatCount="indefinite" />
        <animate attributeName="fill"
                 values="#f3e7d4;#f3e7d4;#2b2b2b;#2b2b2b;#f3e7d4"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 repeatCount="indefinite" />
      </circle>
    </g>

    <!-- Goldene Ecken -->
    <path d="M52 25 h26 v10 h-16 v14 h-10 z" fill="#caa052" stroke="#8f6f34" stroke-width="1"/>
    <path d="M158 25 h-26 v10 h16 v14 h10 z" fill="#caa052" stroke="#8f6f34" stroke-width="1"/>
    <path d="M52 165 v-24 h10 v14 h16 v10 z" fill="#caa052" stroke="#8f6f34" stroke-width="1"/>
    <path d="M158 165 v-24 h-10 v14 h-16 v10 z" fill="#caa052" stroke="#8f6f34" stroke-width="1"/>

    <!-- Bookmark -->
    <path d="M140 165 L150 165 L150 180 L145 173 L140 180 Z"
          fill="#b83232" stroke="#6d1a1a" stroke-width="1"/>

    <!-- Funken (besser verteilt) -->
    <g>
      <use href="#spark" x="120" y="70">
        <animate attributeName="y" values="70;40" dur="2.5s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="2.5s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="95" y="90">
        <animate attributeName="y" values="90;55" dur="2.8s" begin="0.3s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="2.8s" begin="0.3s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="135" y="110">
        <animate attributeName="y" values="110;70" dur="3s" begin="0.6s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3s" begin="0.6s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="60" y="145">
        <animate attributeName="y" values="145;105" dur="3.2s" begin="0.2s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3.2s" begin="0.2s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="110" y="148">
        <animate attributeName="y" values="148;110" dur="3.1s" begin="1.0s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3.1s" begin="1.0s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="140" y="155">
        <animate attributeName="y" values="155;115" dur="3.4s" begin="0.4s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3.4s" begin="0.4s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="175" y="125">
        <animate attributeName="y" values="125;85" dur="3.4s" begin="0.5s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3.4s" begin="0.5s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="75" y="50">
        <animate attributeName="y" values="50;25" dur="2.6s" begin="0.9s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="2.6s" begin="0.9s" repeatCount="indefinite" />
      </use>
    </g>

    <!-- float -->
    <animateTransform
      attributeName="transform"
      attributeType="XML"
      type="translate"
      dur="4s"
      repeatCount="indefinite"
      values="0,6.6; 0,6.6; 0,0; 0,6.6; 0,6.6"
      keyTimes="0; 0.25; 0.6; 0.95; 1"
      keySplines="0 0 1 1;
                  0.42 0 0.58 1;
                  0.42 0 0.58 1;
                  0 0 1 1"
      calcMode="spline" />
  </g>
</svg>
            </div>
            <div class="skill-compendium">
              <div id="skillList" class="skill-list"></div>
              <div id="skillEmpty" class="skill-empty">Noch keine Skills vorhanden. Wechsle in den Shop, um welche zu kaufen.</div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section id="shopView" class="view">
      <div class="game-grid">
        <div class="card">
          <h2>Shop</h2>
          <p class="small">Wähle deine Belohnungskategorie, jeder Einkauf kostet 20 Coins.</p>
          <div class="gacha-options" role="radiogroup" aria-label="Shop Kategorie">
            <label class="gacha-option active">
              <input type="radio" name="gachaType" value="weapon" checked>
              <span class="gacha-icon" aria-hidden="true">
                <svg viewBox="0 0 32 32" focusable="false">
                  <rect x="14" y="4" width="4" height="15" rx="2" fill="currentColor" opacity="0.85"/>
                  <rect x="10" y="17" width="12" height="3.3" rx="1.6" fill="currentColor" opacity="0.7"/>
                  <rect x="13" y="20" width="6" height="5" rx="1.5" fill="currentColor" opacity="0.85"/>
                  <circle cx="16" cy="26.5" r="2" fill="currentColor"/>
                </svg>
              </span>
              <span class="gacha-label">Waffe</span>
              <span class="gacha-remaining" data-remaining-category="weapon">--</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="armor">
              <span class="gacha-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false">
                  <path fill="currentColor" d="M12 3l7 2.8v5.4c0 4.9-3.3 9.5-7 10.3-3.7-0.8-7-5.4-7-10.3V5.8L12 3z"/>
                </svg>
              </span>
              <span class="gacha-label">Ausrüstung</span>
              <span class="gacha-remaining" data-remaining-category="armor">--</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="accessory">
              <span class="gacha-icon" aria-hidden="true">
                <svg viewBox="0 0 32 32" focusable="false">
                  <circle cx="16" cy="16" r="9" fill="none" stroke="currentColor" stroke-width="1.8"/>
                  <circle cx="16" cy="16" r="6" fill="currentColor" opacity="0.18"/>
                  <path d="M16 8 L18 14 L24 16 L18 18 L16 24 L14 18 L8 16 L14 14 Z" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round"/>
                  <circle cx="16" cy="16" r="2.4" fill="currentColor" opacity="0.85"/>
                  <path d="M13.5 6c1.6-1.4 3.4-1.4 5 0" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
                  <path d="M16 25.5v2.2" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/>
                </svg>
              </span>
              <span class="gacha-label">Accessoire</span>
              <span class="gacha-remaining" data-remaining-category="accessory">--</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="skill">
              <span class="gacha-icon" aria-hidden="true">
                <svg viewBox="35 0 140 190" focusable="false">
                  <rect x="43" y="25" width="7" height="140" fill="currentColor" opacity="0.55" stroke="currentColor" stroke-width="2"/>
                  <path d="M50 25 H160 a6 6 0 0 1 6 6 V159 a6 6 0 0 1 -6 6 H50 Z" fill="none" stroke="currentColor" stroke-width="5"/>
                  <rect x="160" y="31" width="3" height="130" rx="1.5" ry="1.5" fill="currentColor" opacity="0.25" stroke="currentColor" stroke-width="1"/>
                  <circle cx="105" cy="85" r="28" fill="none" stroke="currentColor" stroke-width="4"/>
                  <circle cx="105" cy="85" r="12" fill="currentColor" opacity="0.85"/>
                  <path d="M105 72 L110 87 L125 90 L112 99 L118 115 L105 106 L92 115 L98 99 L85 90 L100 87 Z" fill="none" stroke="currentColor" stroke-width="3" stroke-linejoin="round"/>
                  <path d="M52 25 h26 v10 h-16 v14 h-10 z" fill="currentColor" opacity="0.6" stroke="currentColor" stroke-width="1"/>
                  <path d="M158 25 h-26 v10 h16 v14 h10 z" fill="currentColor" opacity="0.6" stroke="currentColor" stroke-width="1"/>
                  <path d="M52 165 v-24 h10 v14 h16 v10 z" fill="currentColor" opacity="0.6" stroke="currentColor" stroke-width="1"/>
                  <path d="M158 165 v-24 h-10 v14 h-16 v10 z" fill="currentColor" opacity="0.6" stroke="currentColor" stroke-width="1"/>
                  <path d="M140 165 h10 v15 l-5-6-5 6z" fill="currentColor" opacity="0.8" stroke="currentColor" stroke-width="1"/>
                </svg>
              </span>
              <span class="gacha-label">Skill</span>
              <span class="gacha-remaining" data-remaining-category="skill">--</span>
            </label>
          </div>
          <button id="gachaBtn" class="shop-buy-btn">Item kaufen</button>
          <div class="shop-latest" id="shopLatest">
            <h3>Neueste Belohnung</h3>
            <p class="shop-latest-empty" id="shopLatestEmpty">Noch keine Belohnung gezogen.</p>
          </div>
        </div>
      </div>
    </section>
    <section id="battleView" class="view">
      <div class="game-grid">
        <div class="card battle-card">
          <div id="battleSimulation" class="battle-sim hidden" aria-live="polite">
            <div class="battle-header">
              <h3 id="battleTitle">Goblin-Schlacht</h3>
              <button type="button" class="battle-close" id="battleCloseBtn" aria-label="Schliessen">&#x2715;</button>
            </div>
            <div class="battle-arena" id="battleArena">
              <div class="arena-particles" aria-hidden="true">
                <span style="left:10%; animation-delay:0s;"></span>
                <span style="left:25%; animation-delay:0.8s;"></span>
                <span style="left:40%; animation-delay:1.5s;"></span>
                <span style="left:55%; animation-delay:2.3s;"></span>
                <span style="left:70%; animation-delay:3.1s;"></span>
                <span style="left:82%; animation-delay:3.8s;"></span>
                <span style="left:90%; animation-delay:4.6s;"></span>
                <span style="left:5%; animation-delay:5.2s;"></span>
              </div>
              <div class="fighter knight" id="battleKnight">
                <div class="fighter-name">Ritter</div>
              </div>
              <div class="fighter enemy goblin" id="battleEnemy">
                <img id="battleEnemySprite" class="fighter-sprite" src="assets/enemy-kobold.svg" alt="Goblin">
                <div class="fighter-name" id="battleEnemyName">Goblin</div>
              </div>
            </div>
            <div class="modal-battle-overview">
              <div class="modal-battle-card hero" id="modalHeroCard">
                <div class="modal-card-head">
                  <div>
                    <span class="battle-side-label">Held</span>
                    <h4 id="modalHeroName">Shortcut Knight</h4>
                  </div>
                  <div>
                    <span class="battle-side-tier" id="modalHeroTier">Rang 1</span>
                    <span class="battle-trait" id="modalHeroTrait">Ausbalanciert</span>
                  </div>
                </div>
                <div class="modal-card-stats">
                  <span class="battle-stat-badge atk">ATK<strong id="modalHeroAtk">1</strong></span>
                  <span class="battle-stat-badge def">DEF<strong id="modalHeroDef">0</strong></span>
                  <span class="battle-stat-badge">HP<strong id="modalHeroHp">0</strong></span>
                </div>
                <p class="modal-card-meta" id="modalHeroMeta">Bereit fuer den Kampf.</p>
              </div>
              <div class="modal-battle-card enemy" id="modalEnemyCard">
                <div class="modal-card-head">
                  <div>
                    <span class="battle-side-label">Gegner</span>
                    <h4 id="modalEnemyName">Kobold</h4>
                  </div>
                  <div>
                    <span class="battle-side-tier" id="modalEnemyTier">Rang 1</span>
                    <span class="battle-trait" id="modalEnemyTrait">Unbekannt</span>
                  </div>
                </div>
                <div class="modal-card-art">
                  <img id="modalEnemyIcon" src="assets/enemy-kobold.svg" alt="Kobold">
                </div>
                <div class="modal-card-stats">
                  <span class="battle-stat-badge atk">ATK<strong id="modalEnemyAtk">0</strong></span>
                  <span class="battle-stat-badge def">DEF<strong id="modalEnemyDef">0</strong></span>
                  <span class="battle-stat-badge">HP<strong id="modalEnemyHp">0</strong></span>
                </div>
                <p class="modal-card-meta" id="modalEnemyMeta">Details folgen.</p>
              </div>
            </div>
            <div class="battle-skill-bar" id="battleSkillBar"></div>
            <div class="battle-bars">
              <div class="hp-row">
                <span>Ritter</span>
                <div class="hp-track">
                  <div class="hp-fill hero" id="heroHpFill"></div>
                </div>
                <span class="hp-value" id="heroHpValue"></span>
              </div>
              <div class="hp-row">
                <span id="enemyHpLabel">Gegner</span>
                <div class="hp-track">
                  <div class="hp-fill enemy" id="enemyHpFill"></div>
                </div>
                <span class="hp-value" id="enemyHpValue"></span>
              </div>
            </div>
            <div class="battle-foot">
              <p class="battle-result" id="battleResult"></p>
              <button type="button" class="battle-next hidden" id="battleNextBtn">Naechstes Level starten</button>
            </div>
          </div>
          <div class="battle-overview">
            <div class="battle-side hero">
              <div class="battle-side-head">
                <div>
                  <span class="battle-side-label">Held</span>
                  <h3>Shortcut Knight</h3>
                </div>
                <div>
                  <span class="battle-side-tier" id="battleHeroTier">Rang 1</span>
                  <span class="battle-trait" id="battleHeroTrait">Balanced</span>
                </div>
              </div>
              <div class="battle-portrait hero">
                <span class="battle-portrait-icon"><img src="assets/knight_idle_fin.svg" alt="Shortcut Knight"></span>
              </div>
              <div class="battle-statline">
                <span class="battle-stat-badge atk">ATK<strong id="battleHeroAtkStat">1</strong></span>
                <span class="battle-stat-badge def">DEF<strong id="battleHeroDefStat">0</strong></span>
              </div>
              <div class="battle-statline">
                <span class="battle-stat-badge">HP<strong id="battleHeroHpStat">0</strong></span>
              </div>
              <p class="battle-side-meta" id="battleHeroFlavor">Bereit fuer den naechsten Kampf.</p>
              <div class="battle-gear">
                <span class="battle-gear-label">Gear</span>
                <ul class="battle-gear-list" id="battleHeroGearList"></ul>
              </div>
            </div>
            <div class="battle-center">
              <div class="battle-crest">
                <span class="battle-crest-label">VS</span>
                <p>Waehle deinen Kampf und nutze Skills in der Schlacht.</p>
              </div>
              <div class="battle-center-actions">
                <div class="battle-buttons" id="battleButtons"></div>
                <div class="battle-log" id="battleLog"></div>
              </div>
            </div>
            <div class="battle-side enemy">
              <div class="battle-side-head">
                <div>
                  <span class="battle-side-label">Naechster Gegner</span>
                  <h3 id="battleEnemyPreviewName">Goblin</h3>
                </div>
                <div>
                  <span class="battle-side-tier" id="battleEnemyPreviewLevel">Rang 1</span>
                  <span class="battle-trait" id="battleEnemyTrait">Unbekannt</span>
                </div>
              </div>
              <div class="battle-portrait enemy">
                <span class="battle-portrait-icon">
                  <img id="battleEnemyPreviewIcon" src="assets/enemy-kobold.svg" alt="Kobold">
                </span>
              </div>
              <div class="battle-statline">
                <span class="battle-stat-badge atk">ATK<strong id="battleEnemyAtkStat">0</strong></span>
                <span class="battle-stat-badge def">DEF<strong id="battleEnemyDefStat">0</strong></span>
              </div>
              <div class="battle-statline">
                <span class="battle-stat-badge">HP<strong id="battleEnemyHpStat">0</strong></span>
              </div>
              <p class="battle-side-meta" id="battleEnemyFlavor">Unbekannte Taktik.</p>
            </div>
          </div>
        </div>
      </div>
    </section>
  <script src="assets/sections-data.js"></script>
  <script src="assets/skill-hotkeys.js"></script>
  <script>
    const STORAGE_KEY = "shortcutRitter_v1";
    const COINS_PER_ACTION = 10;
    const COINS_PER_ACTION_AFTER_RESET = 5;
    const BASE_ATK = 1;
    const BASE_DEF = 0;
    const BASE_HP = 12;
    const HP_PER_DEF = 6;
    const MAX_ITEM_TIER = 5;
    const MAX_SKILL_TIER = 6;
    const DEFAULT_SKILL_INPUT_MODE = "hotkeys"; // set to "legacy" to fall back to 1-9 keys
    // Vollständiges Standardset zur Offline-Nutzung, falls das Laden aus skill-hotkeys.json fehlschlägt.
    const INLINE_SKILL_HOTKEYS = Array.isArray(window.SKILL_HOTKEY_BLUEPRINTS) ? window.SKILL_HOTKEY_BLUEPRINTS : [];
    const skillHotkeyPool = [];
    const activeSkillKeys = new Set();
    const activeSkillComboLatch = new Set();
    let battleSkillStates = [];
    const VALID_MODIFIER_KEYS = new Map([
      ["control", "CTRL"],
      ["ctrl", "CTRL"],
      ["alt", "ALT"],
      ["altgraph", "ALT"],
      ["shift", "SHIFT"],
      ["meta", "WIN"],
      ["win", "WIN"],
      ["escape", "ESC"],
      ["esc", "ESC"]
    ]);

    function normalizeHotkeyToken(token) {
      if (!token) return null;
      const trimmed = String(token).trim();
      if (!trimmed) return null;
      const lower = trimmed.toLowerCase();
      if (VALID_MODIFIER_KEYS.has(lower)) return VALID_MODIFIER_KEYS.get(lower);
      if (lower.length === 1 && /[a-z0-9]/.test(lower)) {
        return lower.toUpperCase();
      }
      return null;
    }

    function formatHotkeyForDisplay(sequence) {
      return sequence.map(part => {
        switch (part) {
          case "CTRL": return "Ctrl";
          case "ALT": return "Alt";
          case "SHIFT": return "Shift";
          case "WIN": return "Win";
          case "ESC": return "Esc";
          default: return part.toUpperCase();
        }
      }).join(" + ");
    }

    function applySkillHotkeyConfig(entries) {
      skillHotkeyPool.length = 0;
      if (!Array.isArray(entries)) return;
      entries.forEach(entry => {
        if (!entry || !Array.isArray(entry.keys)) return;
        const rawTokens = entry.keys;
        const normalizedTokens = [];
        rawTokens.forEach(token => {
          const normalized = normalizeHotkeyToken(token);
          if (normalized && !normalizedTokens.includes(normalized)) {
            normalizedTokens.push(normalized);
          }
        });
        if (!normalizedTokens.length) return;
        const hasModifier = normalizedTokens.some(token => token.length > 1 || ["CTRL", "ALT", "SHIFT", "WIN", "ESC"].includes(token));
        if (!hasModifier && normalizedTokens.length === 1) return;
        const comboId = [...normalizedTokens].sort().join("+");
        const label = typeof entry.label === "string" && entry.label.trim() ? entry.label.trim() : normalizedTokens.join(" + ");
        skillHotkeyPool.push({
          label,
          sequence: normalizedTokens,
          comboId,
          display: formatHotkeyForDisplay(normalizedTokens),
          comboSet: new Set(normalizedTokens)
        });
      });
    }

    function getRandomSkillCombo(bannedComboIds = null) {
      if (!skillHotkeyPool.length) return null;
      let available = skillHotkeyPool;
      if (bannedComboIds && bannedComboIds.size) {
        available = skillHotkeyPool.filter(combo => !bannedComboIds.has(combo.comboId));
      }
      if (!available.length) available = skillHotkeyPool;
      const index = Math.floor(Math.random() * available.length);
      return available[Math.max(0, Math.min(index, available.length - 1))];
    }

    function assignRandomCombo(entry, usedComboIds = null, previousComboId = null) {
      const banned = new Set();
      if (previousComboId) banned.add(previousComboId);
      if (usedComboIds && usedComboIds.size) {
        usedComboIds.forEach(id => banned.add(id));
      }
      const combo = getRandomSkillCombo(banned);
      if (!combo) {
        entry.mode = "legacy";
        entry.displayLabel = `${entry.skill.name} (Tier ${entry.skill.tier})`;
        entry.hotkeyDisplay = "?";
        entry.comboSet = new Set();
        entry.comboId = null;
        return;
      }
      entry.mode = "combo";
      entry.displayLabel = combo.label;
      entry.hotkeyDisplay = combo.display;
      entry.comboId = combo.comboId;
      entry.comboSet = new Set(combo.comboSet);
      entry.comboSequence = combo.sequence.slice();
    }

    function normalizeEventKey(key) {
      if (!key) return null;
      const lower = key.toLowerCase();
      if (VALID_MODIFIER_KEYS.has(lower)) return VALID_MODIFIER_KEYS.get(lower);
      if (lower.length === 1 && /[a-z0-9]/.test(lower)) {
        return lower.toUpperCase();
      }
      return null;
    }

    function setsEqual(setA, setB) {
      if (setA.size !== setB.size) return false;
      for (const value of setA) {
        if (!setB.has(value)) return false;
      }
      return true;
    }

    function resetSkillKeyTracking() {
      activeSkillKeys.clear();
      activeSkillComboLatch.clear();
    }

    function initSkillHotkeys() {
      applySkillHotkeyConfig(INLINE_SKILL_HOTKEYS);
      if (DEFAULT_SKILL_INPUT_MODE === "hotkeys" && skillHotkeyPool.length && battleSkillStates.length) {
        const used = new Set();
        battleSkillStates.forEach(entry => {
          if (entry && entry.skill) {
            assignRandomCombo(entry, used);
            if (entry.comboId) used.add(entry.comboId);
          }
        });
        resetSkillKeyTracking();
        renderBattleSkillBar();
      }
    }

    initSkillHotkeys();

    const state = {
      coins: 0,
      atk: BASE_ATK,
      def: BASE_DEF,
      hp: 0,
      items: [],
      skills: [],
      equipment: {
        gloves: null,
        helm: null,
        necklace: null,
        boots: null,
        weapon: null,
        offhand: null,
        ring_left: null,
        ring_right: null
      },
      sectionClears: {},
      sectionResets: {},
      gachaPreference: "weapon",
      battleUnlocked: 1,
      battleClears: {},
      lastShopPurchase: null
    };
    function loadState() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const saved = JSON.parse(raw);
        Object.assign(state, saved);
      if (!state.gachaPreference) state.gachaPreference = "weapon";
    } catch (err) {
      console.warn("State konnte nicht geladen werden", err);
    }
    if (!Array.isArray(state.items)) state.items = [];
    if (!Array.isArray(state.skills)) state.skills = [];
    if (typeof state.equipment !== "object" || !state.equipment) state.equipment = {};
    if (typeof state.sectionClears !== "object" || !state.sectionClears) state.sectionClears = {};
      if (typeof state.sectionResets !== "object" || !state.sectionResets) state.sectionResets = {};
      if (typeof state.battleClears !== "object" || !state.battleClears) state.battleClears = {};
      if (typeof state.battleUnlocked !== "number" || !Number.isFinite(state.battleUnlocked)) {
        state.battleUnlocked = 1;
      } else {
        state.battleUnlocked = Math.max(1, Math.floor(state.battleUnlocked));
      }
    if (typeof state.lastShopPurchase !== "object" || !state.lastShopPurchase) {
      state.lastShopPurchase = null;
    }
  }
    loadState();
    function saveState() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }
    const coinTop = document.getElementById("coinTop");
    const atkDisplay = document.getElementById("atkDisplay");
    const defDisplay = document.getElementById("defDisplay");
    const itemsDisplay = document.getElementById("itemsDisplay");
    const shopLatest = document.getElementById("shopLatest");
    const shopLatestEmpty = document.getElementById("shopLatestEmpty");
    const heroAvatar = document.getElementById("heroAvatar");
    const heroAvatarImage = document.getElementById("heroAvatarImage");
    const hpDisplay = document.getElementById("hpDisplay");
    const autoEquipBtn = document.getElementById("autoEquipBtn");
    const equipmentSlots = document.querySelectorAll("[data-equip-slot]");
    const equipmentSlotMap = Object.create(null);
    equipmentSlots.forEach(slot => {
      if (!slot || !slot.dataset) return;
      equipmentSlotMap[slot.dataset.equipSlot] = slot;
    });
    const equipmentLayout = document.querySelector(".equipment-layout");
    const inventoryList = document.getElementById("inventoryList");
    const inventoryFilterEmpty = document.getElementById("inventoryFilterEmpty");
    const inventoryFilterButtons = document.querySelectorAll("[data-inventory-filter]");
    const DEFAULT_INVENTORY_FILTER = "weapon";
    let currentInventoryFilter = DEFAULT_INVENTORY_FILTER;
    let inventoryNeedsResort = true;
    let currentInventoryOrder = [];
    const skillList = document.getElementById("skillList");
    const skillEmpty = document.getElementById("skillEmpty");
    const sectionTabsHost = document.getElementById("sectionTabs");
    const learnSectionsHost = document.getElementById("learnSections");
    const overallSummary = document.getElementById("overallSummary");
    let allCheckables = [];
    const SECTION_BLUEPRINTS = Array.isArray(window.LEARN_SECTION_BLUEPRINTS) ? window.LEARN_SECTION_BLUEPRINTS : [];
    const inputHintRegistry = new Set();

    function resolveSectionId(section, fallbackIndex) {
      if (section && section.id !== undefined && section.id !== null && section.id !== "") {
        return String(section.id);
      }
      return String(fallbackIndex + 1);
    }

    function createSectionTab(section, sectionId, isActive) {
      const tab = document.createElement("button");
      tab.type = "button";
      tab.className = "section-tab";
      if (isActive) tab.classList.add("active");
      tab.dataset.goto = sectionId;
      tab.textContent = section && section.tabLabel ? section.tabLabel : `Abschnitt ${sectionId}`;
      return tab;
    }

    function shuffleArray(source) {
      if (!Array.isArray(source)) return [];
      const array = source.slice();
      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
      }
      return array;
    }

    function reshuffleDndSection(section) {
      if (!section) return;
      const pools = section.querySelectorAll(".dnd-pool");
      pools.forEach(pool => {
        const tokens = Array.from(pool.querySelectorAll(".dnd-token"));
        shuffleArray(tokens).forEach(node => pool.appendChild(node));
      });
      const wraps = section.querySelectorAll(".dnd-targets");
      wraps.forEach(wrapper => {
        const targets = Array.from(wrapper.querySelectorAll(".dnd-target"));
        shuffleArray(targets).forEach(node => wrapper.appendChild(node));
      });
    }

    function buildSelectField(task) {
      const select = document.createElement("select");
      select.dataset.answer = task && task.answer ? task.answer : "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = task && task.placeholderOption ? task.placeholderOption : "-- wählen --";
      select.appendChild(placeholder);
      const options = Array.isArray(task && task.options) ? task.options : [];
      options.forEach(optionValue => {
        if (optionValue === null || optionValue === undefined) return;
        const optionEl = document.createElement("option");
        if (typeof optionValue === "string") {
          optionEl.value = optionValue;
          optionEl.textContent = optionValue;
        } else {
          const value = optionValue.value || optionValue.label || "";
          optionEl.value = value;
          optionEl.textContent = optionValue.label || optionValue.value || "";
        }
        select.appendChild(optionEl);
      });
      return select;
    }

    function buildInputField(task) {
      const wrapper = document.createElement("div");
      wrapper.className = "input-with-hint";
      const input = document.createElement("input");
      input.type = "text";
      input.dataset.answer = task && task.answer ? task.answer : "";
      input.autocomplete = "off";
      if (task && task.hint) {
        input.dataset.hint = task.hint;
      }
      wrapper.appendChild(input);
      if (task && task.hint) {
        const overlay = document.createElement("span");
        overlay.className = "input-hint-overlay";
        overlay.textContent = task.hint;
        const measure = document.createElement("span");
        measure.className = "input-hint-measure";
        wrapper.appendChild(overlay);
        wrapper.appendChild(measure);
      }
      return wrapper;
    }

    function buildTaskField(task) {
      if (!task) return null;
      const label = document.createElement("label");
      label.className = "task-field";
      const question = document.createElement("span");
      question.className = "question-text";
      question.textContent = task.prompt || "";
      label.appendChild(question);
      let control = null;
      if (task.type === "select") {
        control = buildSelectField(task);
      } else if (task.type === "input") {
        control = buildInputField(task);
      }
      if (control) {
        label.appendChild(control);
      }
      return label;
    }

    function appendDndBlock(container, task) {
      const pool = document.createElement("div");
      pool.className = "dnd-pool";
      const tokens = shuffleArray(task && task.tokens);
      tokens.forEach(entry => {
        if (!entry) return;
        const tokenMeta = typeof entry === "string" ? { label: entry, value: entry } : entry;
        const value = tokenMeta.value || tokenMeta.label || "";
        if (!value) return;
        const tokenEl = document.createElement("div");
        tokenEl.className = "dnd-token";
        tokenEl.setAttribute("draggable", "true");
        tokenEl.dataset.value = value;
        tokenEl.textContent = tokenMeta.label || value;
        pool.appendChild(tokenEl);
      });
      container.appendChild(pool);
      const targetsWrap = document.createElement("div");
      targetsWrap.className = "dnd-targets";
      const targets = shuffleArray(task && task.targets);
      targets.forEach(target => {
        if (!target) return;
        const targetEl = document.createElement("div");
        targetEl.className = "dnd-target";
        targetEl.dataset.answer = target.answer || "";
        const label = document.createElement("span");
        label.className = "question-text";
        label.textContent = target.label || target.answer || "";
        const slot = document.createElement("div");
        slot.className = "drop-slot";
        targetEl.appendChild(label);
        targetEl.appendChild(slot);
        targetsWrap.appendChild(targetEl);
      });
      container.appendChild(targetsWrap);
    }

    function updateInputHintOverlay(input) {
      if (!input || !input.dataset) return;
      const hint = input.dataset.hint || "";
      if (!hint) return;
      const wrapper = input.closest(".input-with-hint");
      if (!wrapper) return;
      const overlay = wrapper.querySelector(".input-hint-overlay");
      const measure = wrapper.querySelector(".input-hint-measure");
      if (!overlay || !measure) return;
      const computed = window.getComputedStyle(input);
      const paddingLeft = parseFloat(computed.paddingLeft) || 0;
      const paddingRight = parseFloat(computed.paddingRight) || 0;
      const availableWidth = input.clientWidth - paddingRight - paddingLeft;
      const value = input.value || "";
      if (!value) {
        overlay.textContent = hint;
        measure.textContent = "";
        overlay.style.setProperty("--input-hint-offset", `${paddingLeft}px`);
        overlay.classList.toggle("hidden", false);
        return;
      }
      overlay.textContent = "";
      overlay.classList.add("hidden");
    }

    function initInputHint(input) {
      if (!input || !input.dataset || !input.dataset.hint) return;
      if (inputHintRegistry.has(input)) {
        updateInputHintOverlay(input);
        return;
      }
      inputHintRegistry.add(input);
      const handler = () => updateInputHintOverlay(input);
      input.addEventListener("input", handler);
      input.addEventListener("focus", handler);
      input.addEventListener("blur", handler);
      updateInputHintOverlay(input);
    }

    function refreshAllInputHints() {
      inputHintRegistry.forEach(input => updateInputHintOverlay(input));
    }

    function buildSectionElement(section, sectionId, isActive) {
      const wrapper = document.createElement("div");
      wrapper.className = "section";
      if (isActive) wrapper.classList.add("active");
      wrapper.dataset.section = sectionId;

      const contentCard = document.createElement("div");
      contentCard.className = "card";
      const heading = document.createElement("h2");
      heading.textContent = section && section.title ? section.title : `Abschnitt ${sectionId}`;
      contentCard.appendChild(heading);
      if (section && section.description) {
        const description = document.createElement("p");
        description.className = "small";
        description.textContent = section.description;
        contentCard.appendChild(description);
      }
      const tasks = Array.isArray(section && section.tasks) ? section.tasks : [];
      tasks.forEach(task => {
        if (!task) return;
        if (task.type === "dnd") {
          appendDndBlock(contentCard, task);
        } else {
          const field = buildTaskField(task);
          if (field) contentCard.appendChild(field);
        }
      });
      wrapper.appendChild(contentCard);

      const actionCard = document.createElement("div");
      actionCard.className = "card action-card";
      const checkBtn = document.createElement("button");
      checkBtn.type = "button";
      checkBtn.className = "check-section";
      checkBtn.dataset.checkSection = sectionId;
      checkBtn.textContent = section && section.checkLabel ? section.checkLabel : "Abschnitt prüfen";
      const resetBtn = document.createElement("button");
      resetBtn.type = "button";
      resetBtn.className = "reset-section";
      resetBtn.dataset.resetSection = sectionId;
      resetBtn.textContent = section && section.resetLabel ? section.resetLabel : "Zurücksetzen";
      const result = document.createElement("p");
      result.className = "small result-text";
      result.id = `result-${sectionId}`;
      actionCard.appendChild(checkBtn);
      actionCard.appendChild(resetBtn);
      actionCard.appendChild(result);
      wrapper.appendChild(actionCard);
      return wrapper;
    }

    function renderLearnSections() {
      if (!sectionTabsHost || !learnSectionsHost) return;
      sectionTabsHost.innerHTML = "";
      learnSectionsHost.innerHTML = "";
      if (!SECTION_BLUEPRINTS.length) {
        const fallback = document.createElement("p");
        fallback.className = "small";
        fallback.textContent = "Keine Trainingsabschnitte verfuegbar.";
        learnSectionsHost.appendChild(fallback);
        return;
      }
      SECTION_BLUEPRINTS.forEach((section, index) => {
        const sectionId = resolveSectionId(section, index);
        const tab = createSectionTab(section, sectionId, index === 0);
        const sectionEl = buildSectionElement(section, sectionId, index === 0);
        sectionTabsHost.appendChild(tab);
        learnSectionsHost.appendChild(sectionEl);
      });
    }

    function setupLearnSectionInteractions() {
      const sections = document.querySelectorAll(".section");
      const sectionTabs = document.querySelectorAll(".section-tab");
      const showSection = id => {
        sections.forEach(sec => {
          sec.classList.toggle("active", sec.dataset.section === String(id));
        });
        sectionTabs.forEach(tab => {
          tab.classList.toggle("active", tab.dataset.goto === String(id));
        });
      };
      sectionTabs.forEach(tab => {
        tab.addEventListener("click", () => {
          showSection(tab.dataset.goto);
        });
      });
      if (sectionTabs.length) {
        const defaultId = sectionTabs[0].dataset.goto || (sections[0] ? sections[0].dataset.section : "1");
        showSection(defaultId);
      }
      allCheckables = Array.from(document.querySelectorAll("[data-answer], .dnd-target"));
      document.querySelectorAll("input[data-hint]").forEach(input => initInputHint(input));
      let draggedValue = "";
      document.querySelectorAll(".dnd-token").forEach(token => {
        token.addEventListener("dragstart", event => {
          draggedValue = token.dataset.value;
          if (event.dataTransfer) {
            event.dataTransfer.setData("text/plain", draggedValue);
          }
        });
      });
      document.querySelectorAll(".dnd-target").forEach(target => {
        const slot = target.querySelector(".drop-slot");
        if (!slot) return;
        slot.addEventListener("dragover", event => {
          event.preventDefault();
          target.classList.add("over");
        });
        slot.addEventListener("dragleave", () => {
          target.classList.remove("over");
        });
        slot.addEventListener("drop", event => {
          event.preventDefault();
          target.classList.remove("over");
          const value = (event.dataTransfer && event.dataTransfer.getData("text/plain")) || draggedValue;
          if (!value) return;
          slot.textContent = value;
          slot.dataset.value = value;
          slot.classList.remove("correct", "incorrect");
          target.classList.remove("correct", "incorrect");
          const wrap = target.closest(".task-field");
          if (wrap) wrap.classList.remove("correct", "incorrect");
          updateOverallSummary();
        });
      });
      allCheckables.forEach(el => {
        const wrap = el.closest(".task-field");
        const clear = () => {
          el.classList.remove("correct", "incorrect");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        if (el.classList.contains("dnd-target")) {
          const slot = el.querySelector(".drop-slot");
          if (slot) slot.classList.remove("correct", "incorrect");
        }
        updateOverallSummary();
      };
        if (el.tagName === "SELECT") {
          el.addEventListener("change", clear);
        } else if (el.tagName === "INPUT") {
          el.addEventListener("input", clear);
        }
      });
    }

    function bindSectionActionButtons() {
      document.querySelectorAll(".check-section").forEach(btn => {
        btn.addEventListener("click", () => {
          gradeSection(btn.dataset.checkSection, btn);
        });
      });
      document.querySelectorAll(".reset-section").forEach(btn => {
        btn.addEventListener("click", () => {
          resetSection(btn.dataset.resetSection);
        });
      });
    }

    function initLearnSections() {
      renderLearnSections();
      setupLearnSectionInteractions();
      bindSectionActionButtons();
      refreshAllInputHints();
    }

    initLearnSections();
    window.addEventListener("resize", () => {
      refreshAllInputHints();
    });
    const coinAnimationLayer = document.getElementById("coinAnimationLayer");
    const gachaBtn = document.getElementById("gachaBtn");
    const baseGachaLabel = gachaBtn ? (gachaBtn.getAttribute("aria-label") || gachaBtn.textContent.trim() || "Item kaufen") : "";
    const setGachaStatus = message => {
      if (!gachaBtn) return;
      const status = message ? String(message) : "";
      if (baseGachaLabel) {
        gachaBtn.setAttribute("aria-label", status ? `${baseGachaLabel} (${status})` : baseGachaLabel);
      } else if (status) {
        gachaBtn.setAttribute("aria-label", status);
      } else {
        gachaBtn.removeAttribute("aria-label");
      }
      gachaBtn.title = status;
    };
    const gachaTypeInputs = document.querySelectorAll("input[name='gachaType']");
    const gachaRemainingLabels = document.querySelectorAll("[data-remaining-category]");
    const battleLog = document.getElementById("battleLog");
    const battleSimulation = document.getElementById("battleSimulation");
    const battleTitle = document.getElementById("battleTitle");
    const battleCloseBtn = document.getElementById("battleCloseBtn");
    const battleArena = document.getElementById("battleArena");
    const battleSkillBar = document.getElementById("battleSkillBar");
    const battleKnight = document.getElementById("battleKnight");
    const battleEnemy = document.getElementById("battleEnemy");
    const battleEnemySprite = document.getElementById("battleEnemySprite");
    const battleEnemyName = document.getElementById("battleEnemyName");
    const battleHeroAtkStat = document.getElementById("battleHeroAtkStat");
    const battleHeroDefStat = document.getElementById("battleHeroDefStat");
    const battleHeroHpStat = document.getElementById("battleHeroHpStat");
    const battleHeroTierLabel = document.getElementById("battleHeroTier");
    const battleHeroTrait = document.getElementById("battleHeroTrait");
    const battleHeroFlavor = document.getElementById("battleHeroFlavor");
    const battleEnemyPreviewIcon = document.getElementById("battleEnemyPreviewIcon");
    const battleEnemyPreviewName = document.getElementById("battleEnemyPreviewName");
    const battleEnemyPreviewLevel = document.getElementById("battleEnemyPreviewLevel");
    const battleEnemyAtkStat = document.getElementById("battleEnemyAtkStat");
    const battleEnemyDefStat = document.getElementById("battleEnemyDefStat");
    const battleEnemyHpStat = document.getElementById("battleEnemyHpStat");
    const battleEnemyFlavor = document.getElementById("battleEnemyFlavor");
    const battleEnemyTrait = document.getElementById("battleEnemyTrait");
    const battleHeroGearList = document.getElementById("battleHeroGearList");
    const modalHeroCard = document.getElementById("modalHeroCard");
    const modalEnemyCard = document.getElementById("modalEnemyCard");
    const modalHeroName = document.getElementById("modalHeroName");
    const modalHeroTier = document.getElementById("modalHeroTier");
    const modalHeroTrait = document.getElementById("modalHeroTrait");
    const modalHeroAtk = document.getElementById("modalHeroAtk");
    const modalHeroDef = document.getElementById("modalHeroDef");
    const modalHeroHp = document.getElementById("modalHeroHp");
    const modalHeroMeta = document.getElementById("modalHeroMeta");
    const modalEnemyName = document.getElementById("modalEnemyName");
    const modalEnemyTier = document.getElementById("modalEnemyTier");
    const modalEnemyTrait = document.getElementById("modalEnemyTrait");
    const modalEnemyAtk = document.getElementById("modalEnemyAtk");
    const modalEnemyDef = document.getElementById("modalEnemyDef");
    const modalEnemyHp = document.getElementById("modalEnemyHp");
    const modalEnemyMeta = document.getElementById("modalEnemyMeta");
    const modalEnemyIcon = document.getElementById("modalEnemyIcon");
    const heroCardElements = Array.from(document.querySelectorAll(".battle-side.hero, .modal-battle-card.hero"));
    const enemyCardElements = Array.from(document.querySelectorAll(".battle-side.enemy, .modal-battle-card.enemy"));
    const enemyHpLabel = document.getElementById("enemyHpLabel");
    const heroHpFill = document.getElementById("heroHpFill");
    const enemyHpFill = document.getElementById("enemyHpFill");
    const heroHpValue = document.getElementById("heroHpValue");
    const enemyHpValue = document.getElementById("enemyHpValue");
    const battleResult = document.getElementById("battleResult");
    const battleNextBtn = document.getElementById("battleNextBtn");
    const testAnimationBtn = document.getElementById("testAnimationBtn");
    const battleButtonContainer = document.getElementById("battleButtons");
    let battleButtons = [];
    let currentBattleContext = null;
    let canRenderBattlePreview = false;
    function handleUpgradeClick(container, upgradeFn) {
      if (!container) return;
      container.addEventListener("click", event => {
        const btn = event.target.closest(".item-upgrade");
        if (!btn || btn.disabled || btn.dataset.skillBonus === "true") return;
        const key = btn.dataset.itemKey || btn.dataset.skillKey;
        if (!key) return;
        upgradeFn(key);
      });
    }
    handleUpgradeClick(inventoryList, triggerItemUpgrade);
    handleUpgradeClick(skillList, triggerSkillUpgrade);
    const handleSkillBonusActivation = target => {
      if (!target) return;
      if (target.dataset.skillBonusReady !== "true") return;
      const key = target.dataset.skillBonusKey;
      if (!key) return;
      triggerSkillBonusUpgrade(key);
    };
    const handleSkillUpgradeActivation = target => {
      if (!target) return;
      if (target.dataset.skillUpgradeReady !== "true") return;
      const key = target.dataset.skillUpgradeKey;
      if (!key) return;
      triggerSkillUpgrade(key);
    };
    if (skillList) {
      skillList.addEventListener("click", event => {
        const indicator = event.target.closest("[data-skill-bonus-key],[data-skill-upgrade-key]");
        if (!indicator) return;
        if (indicator.dataset.skillBonusKey) {
          handleSkillBonusActivation(indicator);
        } else if (indicator.dataset.skillUpgradeKey) {
          handleSkillUpgradeActivation(indicator);
        }
      });
      skillList.addEventListener("keydown", event => {
        if (event.key !== "Enter" && event.key !== " ") return;
        const indicator = event.target.closest("[data-skill-bonus-key],[data-skill-upgrade-key]");
        if (!indicator) return;
        event.preventDefault();
        if (indicator.dataset.skillBonusKey) {
          handleSkillBonusActivation(indicator);
        } else if (indicator.dataset.skillUpgradeKey) {
          handleSkillUpgradeActivation(indicator);
        }
      });
    }
    if (inventoryFilterButtons.length) {
      inventoryFilterButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const rawValue = btn.dataset.inventoryFilter || DEFAULT_INVENTORY_FILTER;
          const normalizedValue = rawValue === "all" ? "all" : normalizeItemCategory(rawValue);
          if (normalizedValue === currentInventoryFilter) return;
          currentInventoryFilter = normalizedValue;
          inventoryNeedsResort = true;
          inventoryFilterButtons.forEach(ctrl => {
            const isActive = ctrl === btn;
            ctrl.classList.toggle("active", isActive);
            ctrl.setAttribute("aria-pressed", String(isActive));
          });
          renderInventory();
        });
      });
    }

    if (inventoryList) {
      inventoryList.addEventListener("click", event => {
        const equipBtn = event.target.closest(".item-equip");
        if (!equipBtn) return;
        const itemKey = equipBtn.dataset.itemKey;
        const slotKey = equipBtn.dataset.slotKey;
        if (!itemKey || !slotKey) return;
        const normalizedSlot = normalizeItemSlot(slotKey);
        const equippedKey = normalizedSlot && state.equipment ? state.equipment[normalizedSlot] : null;
        if (equippedKey && equippedKey === itemKey) {
          unequipSlot(normalizedSlot);
        } else {
          equipItem(slotKey, itemKey);
        }
      });
    }
    if (equipmentLayout) {
      equipmentLayout.addEventListener("click", event => {
        const clearBtn = event.target.closest(".slot-unequip");
        if (!clearBtn || clearBtn.hidden) return;
        const slotKey = clearBtn.dataset.slot;
        unequipSlot(slotKey);
      });
    }
    if (autoEquipBtn) {
      autoEquipBtn.addEventListener("click", autoEquipBest);
    }

    const learnView = document.getElementById("learnView");
    const inventoryView = document.getElementById("inventoryView");
    const skillsView = document.getElementById("skillsView");
    const shopView = document.getElementById("shopView");
    const battleView = document.getElementById("battleView");
    const viewRegistry = {
      learn: learnView,
      inventory: inventoryView,
      skills: skillsView,
      shop: shopView,
      battle: battleView
    };
    const navToggles = document.querySelectorAll(".nav-toggle");
    const topNav = document.querySelector(".top-nav");
    const mobileNavToggle = document.getElementById("mobileNavToggle");

    function closeMobileNav() {
      if (!mobileNavToggle || !topNav) return;
      topNav.classList.remove("open");
      mobileNavToggle.setAttribute("aria-expanded", "false");
    }

    if (mobileNavToggle && topNav) {
      mobileNavToggle.addEventListener("click", () => {
        const expanded = mobileNavToggle.getAttribute("aria-expanded") === "true";
        const next = !expanded;
        mobileNavToggle.setAttribute("aria-expanded", String(next));
        topNav.classList.toggle("open", next);
      });
      window.addEventListener("resize", () => {
        if (window.innerWidth > 720) {
          closeMobileNav();
        }
      });
    }

    function setActiveView(viewKey) {
      Object.values(viewRegistry).forEach(section => {
        if (section) section.classList.remove("active");
      });
      const targetSection = viewRegistry[viewKey] || learnView;
      if (targetSection) targetSection.classList.add("active");
    }
    function setActiveNav(viewKey) {
      navToggles.forEach(btn => {
        const matches = btn.dataset.view === viewKey;
        btn.classList.toggle("active", matches);
      });
    }
    function activateView(viewKey) {
      setActiveNav(viewKey);
      setActiveView(viewKey);
    }
    navToggles.forEach(btn => {
      btn.addEventListener("click", () => {
        const view = btn.dataset.view;
        activateView(view);
        if (typeof window !== "undefined" && window.innerWidth <= 720) {
          closeMobileNav();
        }
      });
    });
    const defaultNav = Array.from(navToggles).find(btn => btn.classList.contains("active"));
    if (defaultNav) {
      setActiveView(defaultNav.dataset.view);
    } else {
      activateView("learn");
    }

    if (gachaTypeInputs && gachaTypeInputs.length) {
      gachaTypeInputs.forEach(input => {
        input.addEventListener("change", () => {
          if (!input.checked) return;
          state.gachaPreference = input.value;
          updateGachaOptionStyles();
          saveState();
        });
      });
    }

    applyGachaPreference(state.gachaPreference);

    const KNIGHT_POOL = [
      { key: "bronze_sword", name: "Bronzeklinge", atk: 2, def: 0, icon: "sword_bronze", slot: "weapon", description: "", theme: "knight", category: "weapon" },

      { key: "feuer_klinge", name: "Feuerklinge", atk: 4, def: 0, icon: "sword_fire", slot: "weapon", description: "", theme: "knight", category: "weapon" },

      { key: "stahl_sword", name: "Stahlklinge", atk: 3, def: 0, icon: "sword_steel", slot: "weapon", description: "", theme: "knight", category: "weapon" },
      { key: "schatten_klinge", name: "Schattenklinge", atk: 2, def: 1, icon: "sword_ghost", slot: "weapon", description: "", theme: "knight", category: "weapon" },
      { key: "eichen_schild", name: "Eichenschild", atk: 0, def: 2, icon: "shield", slot: "offhand", description: "", theme: "knight", category: "armor" },
      { key: "turm_schild", name: "Turmschild", atk: 0, def: 3, icon: "shield", slot: "offhand", description: "", theme: "knight", category: "armor" },
      { key: "taktik_helm", name: "Taktikhelm", atk: 1, def: 1, icon: "helm", slot: "helm", description: "", theme: "knight", category: "armor" },
      { key: "falken_cape", name: "Falkencape", atk: 1, def: 0, icon: "gloves", slot: "gloves", description: "", theme: "knight", category: "accessory" },
      { key: "runen_amulet", name: "Runen-Amulett", atk: 0, def: 1, icon: "talisman", slot: "necklace", description: "", theme: "knight", category: "accessory" },
      { key: "stahl_stiefel", name: "Stahl-Stiefel", atk: 0, def: 2, icon: "boots", slot: "boots", description: "", theme: "knight", category: "armor" },
      { key: "wind_stiefel", name: "Windlaeufer-Stiefel", atk: 1, def: 1, icon: "boots", slot: "boots", description: "", theme: "knight", category: "armor" }
    ];
    const KNIGHT_BY_KEY = Object.create(null);
    const KNIGHT_BY_NAME = Object.create(null);
    KNIGHT_POOL.forEach(entry => {
      KNIGHT_BY_KEY[entry.key] = entry;
      KNIGHT_BY_NAME[entry.name] = entry;
    });
    const SKILL_POOL = [
      { key: "sturm_hieb", name: "Sturm-Hieb", icon: "skill_power", description: "Fuegt sofort zusaetzlichen Schaden zu.", effect: "damage", basePower: 6, powerPerTier: 4 },
      { key: "schutzwall", name: "Schutzwall", icon: "skill_guard", description: "Stellt Lebenspunkte wieder her.", effect: "heal", basePower: 10, powerPerTier: 6 },
      { key: "kampfrausch", name: "Kampfrausch", icon: "skill_focus", description: "Erhoeht dauerhaft deine ATK im Kampf.", effect: "buff_atk", basePower: 2, powerPerTier: 2 },
      { key: "schattenschritt", name: "Schattenschritt", icon: "skill_shadow", description: "Schwaecht die ATK des Gegners.", effect: "debuff_enemy", basePower: 2, powerPerTier: 2 }
    ];
    const SKILL_BY_KEY = Object.create(null);
    SKILL_POOL.forEach(entry => {
      SKILL_BY_KEY[entry.key] = entry;
    });
    const GACHA_CATEGORY_LABELS = {
      weapon: "Waffe",
      armor: "Ausrüstung",
      accessory: "Accessoire",
      any: "Zufall",
      skill: "Skill"
    };
    const INVENTORY_CATEGORY_ORDER = {
      weapon: 0,
      armor: 1,
      accessory: 2
    };
    const EQUIPMENT_SLOT_DEFS = {
      gloves: {
        label: "Handschuhe",
        hint: "Bereit fuer Handschuhe oder leichte Ruestung.",
        empty: "Noch keine Handschuhe.",
        accepts: ["gloves", "hands", "cape", "accessory"]
      },
      helm: {
        label: "Helm",
        hint: "Nur Helme passen hier.",
        empty: "Kein Helm aktiv.",
        accepts: ["helm", "helmet"]
      },
      necklace: {
        label: "Halskette",
        hint: "Runen, Amulette oder Halsketten.",
        empty: "Keine Halskette aktiv.",
        accepts: ["necklace", "amulet", "talisman", "trinket", "accessory"]
      },
      boots: {
        label: "Stiefel",
        hint: "Stiefel, Beinschienen oder leichte Panzerung.",
        empty: "Keine Stiefel aktiv.",
        accepts: ["boots", "boot", "stiefel", "greaves", "legs", "armor"]
      },
      weapon: {
        label: "Schwert",
        hint: "Lege Schwerter ueber das Inventar an.",
        empty: "Kein Schwert ausgeruestet.",
        accepts: ["weapon", "sword", "blade"]
      },
      offhand: {
        label: "Schwert 2 / Schild",
        hint: "Nur Schilde und Nebenhand-Gear.",
        empty: "Kein Schild oder Zweitwaffe aktiv.",
        accepts: ["offhand", "shield", "weapon", "sword", "blade"]
      },
      ring_left: {
        label: "Ring / Amulett 1",
        hint: "Erster Ring- oder Amulett-Slot.",
        empty: "Kein Schmuck ausgeruestet.",
        accepts: ["ring_left", "ring", "band", "amulet", "talisman", "trinket", "accessory"]
      },
      ring_right: {
        label: "Ring / Amulett 2",
        hint: "Zweiter Ring- oder Amulett-Slot.",
        empty: "Kein Schmuck ausgeruestet.",
        accepts: ["ring_right", "ring", "band", "amulet", "talisman", "trinket", "accessory"]
      }
    };
    const EQUIPMENT_SLOT_KEYS = Object.keys(EQUIPMENT_SLOT_DEFS);
    const AUTO_EQUIP_SLOT_ORDER = ["weapon", "offhand", "helm", "gloves", "necklace", "boots", "ring_left", "ring_right"];
    const ITEM_ART = {
      sword: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g transform="translate(0 3)"><rect x="14" y="4" width="4" height="18" rx="2" fill="#e2e8f0" stroke="#94a3b8" stroke-width="1.5"></rect><rect x="10" y="16" width="12" height="3" rx="1.5" fill="#fcd34d"></rect><rect x="11.5" y="19" width="9" height="4" rx="2" fill="#b45309"></rect><circle cx="16" cy="21" r="1.4" fill="#1f2937"></circle></g></svg>',
      shield: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M16 3 L26 7 v10 c0 9-10 13-10 13S6 26 6 17V7z" fill="rgba(14,165,233,0.25)" stroke="#38bdf8" stroke-width="1.8"></path><path d="M16 6 L23 9 v8 c0 6-7 9-7 9s-7-3-7-9V9z" fill="rgba(14,116,144,0.45)"></path></svg>',
      helm: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g transform="translate(0 2)"><path d="M8 22v-6c0-6.6 3.6-12 8-12s8 5.4 8 12v6z" fill="#94a3b8" stroke="#1e293b" stroke-width="1.6" stroke-linejoin="round"></path><rect x="11" y="16" width="10" height="4" rx="1.5" fill="#0f172a"></rect><path d="M16 11v7" stroke="#e2e8f0" stroke-width="2" stroke-linecap="round"></path></g></svg>',
      gloves: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g stroke="#1e293b" stroke-width="1.4" fill="rgba(248,250,252,0.85)"><path d="M9 7 q0-3 2.5-3t2.5 3v12q0 2-2.5 2T9 19z"></path><path d="M17 7 q0-3 2.5-3t2.5 3v12q0 2-2.5 2T17 19z"></path><path d="M7 13h18v6q0 5-6 7H13 q-6-2-6-7z" fill="rgba(148,163,184,0.4)"></path></g></svg>',
      boots: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M8 7 h8 v12 l6 3 v5H8z" fill="rgba(148,163,184,0.5)" stroke="#475569" stroke-width="1.3" stroke-linejoin="round"></path><path d="M18 7 h6 v10 l-2 8h-4z" fill="rgba(59,130,246,0.35)" stroke="#1d4ed8" stroke-width="1.2" stroke-linejoin="round"></path><path d="M8 24h10M19 26h6" stroke="#0f172a" stroke-width="1.4" stroke-linecap="round"></path></svg>',
      cape: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M10 4 q6 4 12 0 l2 20 q-8 4-16 0z" fill="rgba(59,130,246,0.45)" stroke="#2563eb" stroke-width="1.4"></path><circle cx="16" cy="6" r="2.4" fill="#1d4ed8"></circle></svg>',
      talisman: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="9" fill="rgba(254,243,199,0.9)" stroke="#fbbf24" stroke-width="1.6"></circle><path d="M16 8 L18 14 L24 16 L18 18 L16 24 L14 18 L8 16 L14 14 Z" fill="rgba(250,204,21,0.8)" stroke="#92400e" stroke-width="0.8" stroke-linejoin="round"></path><circle cx="16" cy="16" r="2.4" fill="#f97316"></circle></svg>',
      skill_power: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="13" fill="rgba(239,68,68,0.18)" stroke="#f87171" stroke-width="1.8"></circle><path d="M16 6 L10 18 h6 l-2 8 8-12h-6z" fill="#facc15" stroke="#f59e0b" stroke-width="1.5" stroke-linejoin="round"></path></svg>',
      skill_guard: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M16 4 L26 9 v11 c0 9-10 13-10 13S6 29 6 20V9z" fill="rgba(59,130,246,0.18)" stroke="#60a5fa" stroke-width="1.8"></path><path d="M16 8 L23 11 v8 c0 6-7 9-7 9s-7-3-7-9v-8z" fill="rgba(96,165,250,0.28)"></path><path d="M16 12 v10" stroke="#e2e8f0" stroke-width="1.6"></path></svg>',
      skill_focus: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="11" fill="rgba(56,189,248,0.18)" stroke="#38bdf8" stroke-width="1.6"></circle><circle cx="16" cy="16" r="6.5" fill="rgba(14,165,233,0.25)" stroke="#0ea5e9" stroke-width="1.4"></circle><circle cx="16" cy="16" r="2.4" fill="#e0f2fe"></circle><path d="M16 4v4M16 24v4M4 16h4M24 16h4" stroke="#bae6fd" stroke-width="1.4" stroke-linecap="round"></path></svg>',
      skill_shadow: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="12" fill="rgba(79,70,229,0.2)" stroke="#6366f1" stroke-width="1.6"></circle><path d="M12 20 q4 4 8 0 q-2 -3 -1 -6 q1 -3 5 -5 q-4 -3 -8 0 q-4 -3 -8 0 q4 2 5 5 q1 3 -1 6z" fill="rgba(129,140,248,0.35)" stroke="#c4b5fd" stroke-width="1.2"></path></svg>',
      default: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="6" width="14" height="18" rx="3" fill="#475569" stroke="#94a3b8" stroke-width="1.4"></rect><circle cx="16" cy="12" r="3" fill="#e2e8f0"></circle><path d="M12 22 h8" stroke="#e2e8f0" stroke-width="2" stroke-linecap="round"></path></svg>'
    };
    function normalizeItemSlot(slot) {
      if (!slot) return null;
      const key = String(slot).toLowerCase();
      if (key === "trinket") return "necklace";
      if (key === "ring") return "ring_left";
      if (key === "stiefel" || key === "boots" || key === "boot" || key === "greaves" || key === "legs") return "boots";
      return EQUIPMENT_SLOT_DEFS[key] ? key : null;
    }
    function inferItemSlot(item) {
      if (!item) return null;
      const icon = String(item.icon || "").toLowerCase();
      if (icon === "sword") return "weapon";
      if (icon === "shield") return "offhand";
      if (icon === "helm") return "helm";
      if (icon === "gloves" || icon === "cape") return "gloves";
      if (icon === "boots" || icon === "greaves") return "boots";
      if (icon === "talisman") return "necklace";
      if (icon === "ring") return "ring_left";
      const category = String(item.category || "").toLowerCase();
      if (category === "weapon") return "weapon";
      if (category === "boots" || category === "legs") return "boots";
      if (category === "armor") return "offhand";
      if (category === "accessory") return "necklace";
      return null;
    }
    function normalizeItemCategory(category) {
      if (!category) return "misc";
      const normalized = String(category).trim().toLowerCase();
      return normalized || "misc";
    }
    function getItemSlot(item) {
      if (!item) return null;
      return normalizeItemSlot(item.slot) || inferItemSlot(item);
    }
    function getSlotButtonLabel(slotKey) {
      if (!slotKey) return "";
      if (slotKey === "weapon") return "Waffenslot1";
      if (slotKey === "offhand") return "Waffenslot2";
      const meta = EQUIPMENT_SLOT_DEFS[slotKey];
      return meta ? meta.label : slotKey;
    }
    function getEquipSlotsForItem(item) {
      if (!item) return [];
      const slots = [];
      const seen = new Set();
      const pushSlot = slot => {
        if (!slot || seen.has(slot) || !EQUIPMENT_SLOT_DEFS[slot]) return;
        slots.push(slot);
        seen.add(slot);
      };
      const primarySlot = getItemSlot(item);
      const isWeapon = primarySlot === "weapon" || normalizeItemCategory(item.category) === "weapon";
      if (isWeapon) {
        if (itemMatchesSlot(item, "weapon")) pushSlot("weapon");
        if (itemMatchesSlot(item, "offhand")) pushSlot("offhand");
      } else {
        pushSlot(primarySlot);
      }
      return slots;
    }
    ensureEquipmentState();
    function cloneItem(template) {
      const now = Date.now();
      return {
        id: `${template.key}-${now}-${Math.random().toString(16).slice(2, 6)}`,
        key: template.key,
        name: template.name,
        baseAtk: template.atk,
        baseDef: template.def,
        atk: template.atk,
        def: template.def,
        icon: template.icon,
        slot: getItemSlot(template),
        description: template.description,
        theme: template.theme || "knight",
        category: template.category || "accessory",
        tier: 1,
        totalCopies: 1,
        createdAt: now,
        lastObtainedAt: now
      };
    }
    function copiesRequiredForTier(tier) {
      if (tier <= 1) return 1;
      return Math.pow(2, tier - 1);
    }
    function getMaxCopiesForItem(template) {
      const targetTier = Math.max(1, Math.min(MAX_ITEM_TIER, Math.floor(template && template.maxTier ? template.maxTier : MAX_ITEM_TIER)));
      return copiesRequiredForTier(targetTier);
    }
    function getOwnedItemCopies(itemKey) {
      if (!itemKey || !Array.isArray(state.items)) return 0;
      const entry = state.items.find(candidate => candidate.key === itemKey);
      if (!entry) return 0;
      return Math.max(1, Math.floor(entry.totalCopies || 1));
    }
    function getRemainingShopCopies(template) {
      if (!template || !template.key) return 0;
      const maxCopies = getMaxCopiesForItem(template);
      const ownedCopies = getOwnedItemCopies(template.key);
      return Math.max(0, maxCopies - ownedCopies);
    }
    function isItemEligibleForShop(template) {
      return getRemainingShopCopies(template) > 0;
    }
    function getMaxCopiesForSkill(template) {
      if (template && Number.isFinite(template.maxTier)) {
        const targetTier = Math.max(1, Math.min(MAX_SKILL_TIER, Math.floor(template.maxTier)));
        return copiesRequiredForTier(targetTier);
      }
      return Infinity;
    }
    function maxTierFromCopies(copies, tierCap = MAX_ITEM_TIER) {
      const safeCopies = Math.max(1, Math.floor(copies || 1));
      const cap = Math.max(1, Math.floor(tierCap || MAX_ITEM_TIER));
      return Math.min(cap, Math.floor(Math.log2(safeCopies)) + 1);
    }
    function getSkillOvercapInfo(skill) {
      const totalCopies = Math.max(0, Math.floor(skill && skill.totalCopies ? skill.totalCopies : 0));
      const capCopies = copiesRequiredForTier(MAX_SKILL_TIER);
      const overcapCopies = Math.max(0, totalCopies - capCopies);
      const copiesPerPercent = 10;
      const naturalMaxPercent = Math.floor(overcapCopies / copiesPerPercent);
      const storedBonus = Math.max(0, Math.floor(skill && skill.overcapBonusPercent ? skill.overcapBonusPercent : 0));
      const bonusPercent = Math.min(storedBonus, naturalMaxPercent);
      const spentCopies = bonusPercent * copiesPerPercent;
      const availableCopies = Math.max(0, overcapCopies - spentCopies);
      const availablePercent = Math.floor(availableCopies / copiesPerPercent);
      const progressTowardNextPercent = availableCopies % copiesPerPercent;
      const remainingToNextPercent = availablePercent > 0
        ? 0
        : (progressTowardNextPercent === 0 ? copiesPerPercent : copiesPerPercent - progressTowardNextPercent);
      return {
        totalCopies,
        capCopies,
        overcapCopies,
        bonusPercent,
        copiesPerPercent,
        availablePercent,
        availableCopies,
        progressTowardNextPercent,
        remainingToNextPercent
      };
    }
    function getSkillBaseEffect(skill) {
      if (!skill) return 0;
      const tier = Math.max(1, Math.floor(skill.tier || 1));
      const basePower = Number(skill.basePower || 0);
      const perTier = Number(skill.powerPerTier || 0);
      return basePower + perTier * (tier - 1);
    }
    function getSkillEffectivePower(skill) {
      const base = getSkillBaseEffect(skill);
      const bonusPercent = Number(skill && skill.overcapBonusPercent ? skill.overcapBonusPercent : 0);
      if (!bonusPercent) return base;
      return Math.max(1, Math.round(base * (1 + bonusPercent / 100)));
    }
    function updateItemDerivedStats(item) {
      if (!item) return item;
      const safeTier = Math.max(1, Math.min(MAX_ITEM_TIER, Math.floor(item.tier || 1)));
      const safeCopies = Math.max(1, Math.floor(item.totalCopies || 1));
      const baseAtk = Number(item.baseAtk ?? item.atk ?? 0);
      const baseDef = Number(item.baseDef ?? item.def ?? 0);
      const maxTier = maxTierFromCopies(safeCopies, MAX_ITEM_TIER);
      const tier = Math.min(safeTier, maxTier);
      item.tier = tier;
      item.totalCopies = safeCopies;
      item.baseAtk = baseAtk;
      item.baseDef = baseDef;
      item.atk = baseAtk * tier;
      item.def = baseDef * tier;
      item.slot = getItemSlot(item);
      if (!item.createdAt) item.createdAt = Date.now();
      if (!item.lastObtainedAt) item.lastObtainedAt = item.createdAt;
      return item;
    }
    function getNextTierRequirement(item, tierCap = MAX_ITEM_TIER) {
      if (!item) return Infinity;
      const cap = Math.max(1, Math.floor(tierCap || MAX_ITEM_TIER));
      const currentTier = Math.max(1, Math.floor(item.tier || 1));
      if (currentTier >= cap) return Infinity;
      const nextTier = Math.min(cap, currentTier + 1);
      return copiesRequiredForTier(nextTier);
    }
    function canUpgradeItem(item, tierCap = MAX_ITEM_TIER) {
      if (!item) return false;
      const cap = Math.max(1, Math.floor(tierCap || MAX_ITEM_TIER));
      if (item.tier >= cap) return false;
      const requirement = getNextTierRequirement(item, cap);
      return item.totalCopies >= requirement;
    }
    function upgradeLegacyItem(item, index) {
      const now = Date.now();
      if (!item || typeof item !== "object") {
        return cloneItem(KNIGHT_POOL[index % KNIGHT_POOL.length]);
      }
      const template = item.key ? KNIGHT_BY_KEY[item.key] : (KNIGHT_BY_NAME[item.name] || null);
      const key = (template && template.key) || item.key || `legacy-${index}`;
      const baseAtk = Number(item.baseAtk ?? item.atk ?? (template ? template.atk : 0) ?? 0);
      const baseDef = Number(item.baseDef ?? item.def ?? (template ? template.def : 0) ?? 0);
      const tier = Math.max(1, Math.min(MAX_ITEM_TIER, Number(item.tier || 1)));
      const copiesSource = Number(item.totalCopies || item.copies || 0);
      const totalCopies = copiesSource > 0 ? copiesSource : 1;
      const createdAt = Number(item.createdAt || item.obtainedAt || now);
      const lastObtainedAt = Number(item.lastObtainedAt || item.updatedAt || createdAt);
      const name = item.name || (template ? template.name : `Relikt ${index + 1}`);
      const description = item.description || (template ? template.description : "Umgeschmiedet aus frueheren Belohnungen.");
      const category = item.category || (template ? template.category : "weapon");
      const icon = item.icon || (template ? template.icon : (category === "armor" ? "shield" : category === "accessory" ? "talisman" : "sword"));
      const slot = normalizeItemSlot(item.slot) || (template ? normalizeItemSlot(template.slot) : null) || inferItemSlot({ icon, category });
      const theme = item.theme || (template ? template.theme : "knight");
      const normalized = {
        id: item.id || `${key}-${createdAt}-${Math.random().toString(16).slice(2, 6)}`,
        key,
        name,
        baseAtk,
        baseDef,
        atk: baseAtk * tier,
        def: baseDef * tier,
        icon,
        slot,
        description,
        theme,
        category,
        tier,
        totalCopies,
        createdAt,
        lastObtainedAt
      };
      return normalized;
    }
    function cloneSkill(template) {
      const now = Date.now();
      return {
        id: `${template.key}-${now}-${Math.random().toString(16).slice(2, 6)}`,
        key: template.key,
        name: template.name,
        icon: template.icon || "skill_power",
        description: template.description || "Aktivierbarer Kampf-Skill.",
        effect: template.effect || "damage",
        basePower: Number(template.basePower || 4),
        powerPerTier: Number(template.powerPerTier || 2),
        tier: 1,
        totalCopies: 1,
        createdAt: now,
        lastObtainedAt: now
      };
    }
    function updateSkillDerivedStats(skill) {
      if (!skill) return skill;
      const safeTier = Math.max(1, Math.min(MAX_SKILL_TIER, Math.floor(skill.tier || 1)));
      const safeCopies = Math.max(1, Math.floor(skill.totalCopies || 1));
      const maxTier = maxTierFromCopies(safeCopies, MAX_SKILL_TIER);
      const tier = Math.min(safeTier, maxTier);
      skill.tier = tier;
      skill.totalCopies = safeCopies;
      skill.basePower = Number(skill.basePower || 0);
      skill.powerPerTier = Number(skill.powerPerTier || 0);
      const capCopies = copiesRequiredForTier(MAX_SKILL_TIER);
      const overcapCopies = Math.max(0, safeCopies - capCopies);
      const copiesPerPercent = 10;
      const naturalMaxPercent = Math.floor(overcapCopies / copiesPerPercent);
      if (!Number.isFinite(skill.overcapBonusPercent)) {
        skill.overcapBonusPercent = naturalMaxPercent;
      }
      skill.overcapBonusPercent = Math.max(0, Math.min(naturalMaxPercent, Math.floor(skill.overcapBonusPercent)));
      const magicInfo = getSkillOvercapInfo(skill);
      skill.overcapCopies = magicInfo.overcapCopies;
      skill.overcapBonusPercent = magicInfo.bonusPercent;
      skill.overcapProgress = magicInfo.progressTowardNextPercent;
      skill.copiesPerOvercapPercent = magicInfo.copiesPerPercent;
      skill.overcapAvailablePercent = magicInfo.availablePercent;
      if (!skill.createdAt) skill.createdAt = Date.now();
      if (!skill.lastObtainedAt) skill.lastObtainedAt = skill.createdAt;
      return skill;
    }
    function upgradeLegacySkill(skill, index) {
      const now = Date.now();
      if (!skill || typeof skill !== "object") {
        return cloneSkill(SKILL_POOL[index % SKILL_POOL.length]);
      }
      const template = skill.key ? SKILL_BY_KEY[skill.key] : null;
      const key = (template && template.key) || skill.key || `legacy-skill-${index}`;
      const basePower = Number(skill.basePower ?? (template ? template.basePower : 4) ?? 4);
      const powerPerTier = Number(skill.powerPerTier ?? (template ? template.powerPerTier : 2) ?? 2);
      const effect = skill.effect || (template ? template.effect : "damage");
      const tier = Math.max(1, Math.min(MAX_SKILL_TIER, Number(skill.tier || 1)));
      const copiesSource = Number(skill.totalCopies || skill.copies || 0);
      const totalCopies = copiesSource > 0 ? copiesSource : 1;
      const createdAt = Number(skill.createdAt || skill.obtainedAt || now);
      const lastObtainedAt = Number(skill.lastObtainedAt || skill.updatedAt || createdAt);
      const name = skill.name || (template ? template.name : `Skill ${index + 1}`);
      const description = skill.description || (template ? template.description : "Aktivierter Kampfspruch.");
      const icon = skill.icon || (template ? template.icon : "skill_power");
      const normalized = {
        id: skill.id || `${key}-${createdAt}-${Math.random().toString(16).slice(2, 6)}`,
        key,
        name,
        icon,
        description,
        effect,
        basePower,
        powerPerTier,
        tier,
        totalCopies,
        createdAt,
        lastObtainedAt
      };
      return updateSkillDerivedStats(normalized);
    }
    function ensureSkillInventory() {
      if (!Array.isArray(state.skills)) {
        state.skills = [];
        return;
      }
      const upgraded = state.skills.map((skill, index) => upgradeLegacySkill(skill, index));
      const merged = new Map();
      upgraded.forEach(skill => {
        if (!skill) return;
        const key = skill.key || skill.name || skill.id;
        if (!merged.has(key)) {
          merged.set(key, { ...skill });
        } else {
          const existing = merged.get(key);
          const existingCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
          const incomingCopies = Math.max(1, Math.floor(skill.totalCopies || 1));
          existing.totalCopies = existingCopies + incomingCopies;
          existing.lastObtainedAt = Math.max(
            Number(existing.lastObtainedAt || existing.createdAt || 0),
            Number(skill.lastObtainedAt || skill.createdAt || Date.now())
          );
          existing.createdAt = Math.min(
            Number(existing.createdAt || existing.lastObtainedAt || Date.now()),
            Number(skill.createdAt || skill.lastObtainedAt || Date.now())
          );
          existing.tier = Math.max(Number(existing.tier || 1), Number(skill.tier || 1));
        }
      });
      state.skills = Array.from(merged.values()).map(updateSkillDerivedStats);
      sortSkillsByNewest();
    }
    function ensureKnightInventory() {
      if (!Array.isArray(state.items)) {
        state.items = [];
        return;
      }
      const upgraded = state.items.map((item, index) => upgradeLegacyItem(item, index));
      const merged = new Map();
      upgraded.forEach(item => {
        if (!item) return;
        const key = item.key || item.name || item.id;
        if (!merged.has(key)) {
          merged.set(key, { ...item });
        } else {
          const existing = merged.get(key);
          const existingCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
          const incomingCopies = Math.max(1, Math.floor(item.totalCopies || 1));
          existing.totalCopies = existingCopies + incomingCopies;
          existing.lastObtainedAt = Math.max(
            Number(existing.lastObtainedAt || existing.createdAt || 0),
            Number(item.lastObtainedAt || item.createdAt || Date.now())
          );
          existing.createdAt = Math.min(
            Number(existing.createdAt || existing.lastObtainedAt || Date.now()),
            Number(item.createdAt || item.lastObtainedAt || Date.now())
          );
          existing.tier = Math.max(Number(existing.tier || 1), Number(item.tier || 1));
        }
      });
      state.items = Array.from(merged.values()).map(updateItemDerivedStats);
      sortInventoryByNewest();
      ensureEquipmentState();
    }
    function ensureEquipmentState() {
      if (typeof state.equipment !== "object" || !state.equipment) {
        state.equipment = {};
      }
      if ("trinket" in state.equipment) {
        const legacy = state.equipment.trinket;
        if (legacy && !state.equipment.necklace) {
          state.equipment.necklace = legacy;
        }
        delete state.equipment.trinket;
      }
      EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
        if (!Object.prototype.hasOwnProperty.call(state.equipment, slotKey)) {
          state.equipment[slotKey] = null;
        }
        const equippedKey = state.equipment[slotKey];
        if (!equippedKey) {
          state.equipment[slotKey] = null;
          return;
        }
        const itemExists = state.items.some(entry => entry && (entry.key || entry.name) === equippedKey);
        if (!itemExists) {
          state.equipment[slotKey] = null;
        }
      });
      Object.keys(state.equipment).forEach(slotKey => {
        if (!EQUIPMENT_SLOT_DEFS[slotKey]) {
          delete state.equipment[slotKey];
        }
      });
    }
    function clearItemFromOtherSlots(itemKey, keepSlot = null) {
      if (!itemKey) return;
      ensureEquipmentState();
      EQUIPMENT_SLOT_KEYS.forEach(slot => {
        if (slot === keepSlot) return;
        if (state.equipment[slot] === itemKey) {
          state.equipment[slot] = null;
        }
      });
    }
    function evaluateItemPower(item) {
      if (!item) return -Infinity;
      updateItemDerivedStats(item);
      const atk = Number(item.atk) || 0;
      const def = Number(item.def) || 0;
      const hp = Number(item.hp || item.maxHp || 0);
      return atk * 10000 + def * 100 + hp;
    }
    function autoEquipBest() {
      if (!state.items.length) {
    updateUI();
        return;
      }
      ensureEquipmentState();
      const pool = state.items
        .map(item => ({ item, power: evaluateItemPower(item) }))
        .sort((a, b) => b.power - a.power);
      const used = new Set();
      const updatedEquipment = {};
      EQUIPMENT_SLOT_KEYS.forEach(slot => {
        updatedEquipment[slot] = null;
      });
      const slotOrder = [];
      AUTO_EQUIP_SLOT_ORDER.forEach(slot => {
        if (EQUIPMENT_SLOT_DEFS[slot]) slotOrder.push(slot);
      });
      EQUIPMENT_SLOT_KEYS.forEach(slot => {
        if (!slotOrder.includes(slot)) slotOrder.push(slot);
      });
      slotOrder.forEach(slotKey => {
        const bestEntry = pool.find(entry => {
          const key = entry.item.key || entry.item.name;
          if (used.has(key)) return false;
          return itemMatchesSlot(entry.item, slotKey);
        });
        if (bestEntry) {
          const key = bestEntry.item.key || bestEntry.item.name;
          updatedEquipment[slotKey] = key;
          used.add(key);
        }
      });
      state.equipment = updatedEquipment;
      recalcStats();
      saveState();
    updateUI();
    }
    function getItemByKey(key) {
      if (!key) return null;
      return state.items.find(entry => entry && (entry.key || entry.name) === key) || null;
    }
    function itemMatchesSlot(item, slotKey) {
      if (!item || !slotKey) return false;
      const normalizedSlot = normalizeItemSlot(slotKey);
      if (!normalizedSlot) return false;
      const meta = EQUIPMENT_SLOT_DEFS[normalizedSlot];
      const tokenPool = [
        normalizeItemSlot(item.slot),
        (item.category || "").toLowerCase(),
        (item.icon || "").toLowerCase()
      ].filter(Boolean);
      if (tokenPool.includes(normalizedSlot)) return true;
      if (!meta || !meta.accepts) return false;
      return tokenPool.some(token => meta.accepts.includes(token));
    }
    function getEquippedItems() {
      ensureEquipmentState();
      const items = [];
      EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
        const eqKey = state.equipment[slotKey];
        if (!eqKey) return;
        const item = getItemByKey(eqKey);
        if (item) items.push(item);
      });
      return items;
    }
    function recalcStats() {
      let atk = BASE_ATK;
      let def = BASE_DEF;
      let hp = 0;
      getEquippedItems().forEach(item => {
        updateItemDerivedStats(item);
        atk += Number(item.atk || 0);
        def += Number(item.def || 0);
        hp += Number(item.hp || item.maxHp || 0);
      });
      state.atk = atk;
      state.def = def;
      state.hp = hp;
    }
    function getHeroMaxHp() {
      const gearHp = Math.max(0, Math.round(state.hp || 0));
      const defenseBonus = Math.max(0, state.def) * HP_PER_DEF;
      return Math.max(1, BASE_HP + gearHp + defenseBonus);
    }
    function getItemIcon(iconKey, itemKey) {
      // Prefer explicit iconKey. If missing or legacy 'sword', try resolving via the item key / template.
      let ik = iconKey;
      if ((!ik || String(ik).toLowerCase() === "sword") && itemKey && typeof KNIGHT_BY_KEY === 'object') {
        const byKey = KNIGHT_BY_KEY[itemKey];
        if (byKey && byKey.icon) ik = byKey.icon;
      }
      if (!ik) return ITEM_ART.default;
      const key = String(ik);
      // If icon references an external sword asset like "sword_fire", use the file in assets/
      if (key.startsWith("sword_")) {
        // sanitize to avoid unexpected chars
        const safe = key.replace(/[^a-z0-9_\-]/gi, "");
        return `<img src="assets/${safe}.svg" alt="${safe}" loading="lazy">`;
      }
      return ITEM_ART[ik] || ITEM_ART.default;
    }
    function createInventoryRow(item, options = {}) {
      const { showUpgrade = true, showProgressIndicator = false, progressIndicatorOverrides = null } = options;
      if (!item) return null;
      updateItemDerivedStats(item);
      const normalizedKey = item.key || item.name;
      const normalizedCategory = normalizeItemCategory(item.category);
      const row = document.createElement("div");
      row.className = `inventory-item tier-${item.tier}`;
      row.dataset.itemKey = normalizedKey;
      row.dataset.category = normalizedCategory;
        const equipSlots = getEquipSlotsForItem(item);

      const left = document.createElement("div");
      left.className = "item-left";
      const icon = document.createElement("div");
      icon.className = "item-icon";
  icon.innerHTML = getItemIcon(item.icon, item.key);
      const text = document.createElement("div");
      text.className = "item-text";
      const nameEl = document.createElement("strong");
      nameEl.textContent = item.name;
      text.appendChild(nameEl);
      const categoryLabel = GACHA_CATEGORY_LABELS[item.category] || item.category || "";
      const descText = item.description ? item.description : (categoryLabel ? `Kategorie: ${categoryLabel}` : "");
      if (descText) {
        const desc = document.createElement("span");
        desc.textContent = descText;
        text.appendChild(desc);
      }
      const requirement = getNextTierRequirement(item);
      const meta = document.createElement("span");
      meta.className = "item-meta";
      if (item.tier >= MAX_ITEM_TIER) {
        meta.textContent = `Tier ${item.tier} | x${item.totalCopies} | Maximum erreicht`;
      } else {
        const progress = Math.min(item.totalCopies, requirement);
        meta.textContent = `Tier ${item.tier} | x${item.totalCopies} | Fortschritt: ${progress}/${requirement}`;
      }
      text.appendChild(meta);
      left.appendChild(icon);
      left.appendChild(text);
      row.appendChild(left);

      const controls = document.createElement("div");
      controls.className = "item-controls";
      const stats = document.createElement("div");
      stats.className = "item-stats";
      if (Number(item.atk) > 0) {
        const atkBadge = document.createElement("span");
        atkBadge.className = "badge atk";
        atkBadge.textContent = `ATK +${item.atk}`;
        stats.appendChild(atkBadge);
      }
      if (Number(item.def) > 0) {
        const defBadge = document.createElement("span");
        defBadge.className = "badge def";
        defBadge.textContent = `DEF +${item.def}`;
        stats.appendChild(defBadge);
      }
      controls.appendChild(stats);
        if (equipSlots && equipSlots.length) {
          const equippedSlots = equipSlots.filter(slot => state.equipment && state.equipment[slot] === normalizedKey);
          const buttonSlots = equippedSlots.length ? equippedSlots : equipSlots;
          buttonSlots.forEach(targetSlot => {
            const equipBtn = document.createElement("button");
            equipBtn.className = "item-equip";
            const isEquippedInSlot = state.equipment && state.equipment[targetSlot] === normalizedKey;
            if (isEquippedInSlot) equipBtn.classList.add("equipped");
            equipBtn.dataset.itemKey = normalizedKey;
            equipBtn.dataset.slotKey = targetSlot;
            const slotLabel = getSlotButtonLabel(targetSlot);
            const normalizedCategory = normalizeItemCategory(item.category);
            const isAccessory = normalizedCategory === "accessory";
            const label = isAccessory ? "Anziehen" : `Anziehen (${slotLabel})`;
            equipBtn.textContent = label;
            equipBtn.disabled = false;
            controls.appendChild(equipBtn);
          });
        }
      if (showUpgrade && item.tier < MAX_ITEM_TIER) {
        const upgradeBtn = document.createElement("button");
        const requirementText = requirement === Infinity ? "-" : requirement;
        upgradeBtn.className = "item-upgrade";
        upgradeBtn.dataset.itemKey = item.key || item.name;
        const nextTier = Math.min(item.tier + 1, MAX_ITEM_TIER);
        if (canUpgradeItem(item)) {
          upgradeBtn.classList.add(`tier-${nextTier}`);
        }
        upgradeBtn.textContent = `Upgrade Tier ${item.tier + 1} (${item.totalCopies}/${requirementText})`;
        upgradeBtn.disabled = !canUpgradeItem(item);
        controls.appendChild(upgradeBtn);
      }
      if (showProgressIndicator) {
        const overrides = progressIndicatorOverrides || {};
        const tierClassValue = overrides.tierClass ?? item.tier;
        const indicatorTier = Math.max(1, Math.min(MAX_ITEM_TIER, Math.floor(tierClassValue)));
        const displayTier = overrides.displayTier ?? item.tier;
        const nextTierDisplay = overrides.nextTier ?? (
          displayTier >= MAX_ITEM_TIER ? displayTier : Math.min(displayTier + 1, MAX_ITEM_TIER)
        );
        const indicator = document.createElement("div");
        indicator.className = "skill-bonus-indicator";
        indicator.classList.add(`tier-${indicatorTier}`);
        indicator.dataset.skillBonusReady = "false";
        indicator.setAttribute("aria-hidden", overrides.readOnly ? "true" : "false");
        const headerRow = document.createElement("div");
        headerRow.className = "skill-bonus-header";
        const title = document.createElement("div");
        title.className = "skill-bonus-title";
        title.textContent = displayTier >= MAX_ITEM_TIER
          ? `Tier ${displayTier} (MAX)`
          : `Tier ${displayTier} ➜ Tier ${nextTierDisplay}`;
        const progressLabel = document.createElement("span");
        progressLabel.className = "skill-bonus-progress-label";
        const bar = document.createElement("div");
        bar.className = "skill-bonus-progress";
        const fill = document.createElement("div");
        fill.className = "skill-bonus-progress-fill";
        let progressCap = overrides.progressMax;
        let infiniteCap = false;
        if (progressCap === Infinity) {
          infiniteCap = true;
        } else if (!Number.isFinite(progressCap) || progressCap <= 0) {
          const baseRequirement = requirement === Infinity ? item.totalCopies || 1 : requirement;
          if (baseRequirement === Infinity) {
            infiniteCap = true;
          } else {
            progressCap = Math.max(1, baseRequirement);
          }
        }
        let progressValue;
        if (Number.isFinite(overrides.progressValue)) {
          progressValue = Math.max(0, overrides.progressValue);
        } else if (infiniteCap) {
          progressValue = item.totalCopies || 0;
        } else {
          progressValue = Math.min(item.totalCopies, progressCap || 1);
        }
        const progressRatio = infiniteCap
          ? 1
          : (progressCap ? Math.min(1, Math.max(0, progressValue / progressCap)) : 0);
        fill.style.width = `${progressRatio * 100}%`;
        const progressLabelText = overrides.progressLabel
          ? overrides.progressLabel
          : (infiniteCap ? `${progressValue}/∞` : `${progressValue}/${progressCap}`);
        progressLabel.textContent = progressLabelText;
        bar.appendChild(fill);
        headerRow.appendChild(title);
        headerRow.appendChild(progressLabel);
        const statusRow = document.createElement("div");
        statusRow.className = "skill-bonus-meta";
        const status = document.createElement("span");
        if (overrides.statusText !== undefined) {
          status.textContent = overrides.statusText;
          if (overrides.statusClass) status.className = overrides.statusClass;
        } else if (canUpgradeItem(item) && item.tier < MAX_ITEM_TIER) {
          status.className = "skill-bonus-ready";
          status.textContent = "Upgrade bereit";
        } else if (item.tier >= MAX_ITEM_TIER) {
          status.textContent = "Maximum erreicht";
        } else {
          status.textContent = "";
        }
        statusRow.appendChild(status);
        indicator.appendChild(headerRow);
        indicator.appendChild(bar);
        indicator.appendChild(statusRow);
        controls.appendChild(indicator);
      }
      row.appendChild(controls);
      return row;
    }
    function createSkillRow(skill, options = {}) {
      const {
        showUpgrade = true,
        allowBonusActivation = true,
        progressIndicatorOverrides = null
      } = options;
      if (!skill) return null;
      updateSkillDerivedStats(skill);
      const row = document.createElement("div");
      row.className = `inventory-item tier-${skill.tier}`;
      row.dataset.skillKey = skill.key || skill.name;
      const left = document.createElement("div");
      left.className = "item-left";
      const icon = document.createElement("div");
      icon.className = "item-icon";
  icon.innerHTML = getItemIcon(skill.icon, skill.key);
      const text = document.createElement("div");
      text.className = "item-text";
      const nameEl = document.createElement("strong");
      nameEl.textContent = skill.name;
      text.appendChild(nameEl);
      if (skill.description) {
        const desc = document.createElement("span");
        desc.textContent = skill.description;
        text.appendChild(desc);
      }
      const requirement = getNextTierRequirement(skill, MAX_SKILL_TIER);
      const isMagicRed = (progressIndicatorOverrides && progressIndicatorOverrides.forceMagicRed) || skill.tier >= MAX_SKILL_TIER;
      const bonusPercent = Number(skill.overcapBonusPercent || 0);
      const bonusLabel = bonusPercent > 0 ? ` +${bonusPercent}%` : "";
      const magicInfo = getSkillOvercapInfo(skill);
      const readyCount = Math.max(0, magicInfo.availablePercent);
      const isReady = readyCount > 0;
      const progressDisplayValue = isReady && magicInfo.progressTowardNextPercent === 0
        ? magicInfo.copiesPerPercent
        : magicInfo.progressTowardNextPercent;
      left.appendChild(icon);
      left.appendChild(text);
      row.appendChild(left);
      const controls = document.createElement("div");
      controls.className = "item-controls";
      const stats = document.createElement("div");
      stats.className = "item-stats";
      const badge = document.createElement("span");
      badge.className = "badge atk";
      const effectValue = getSkillEffectivePower(skill);
      const bonusText = bonusPercent ? ` (+${bonusPercent}%)` : "";
      switch (skill.effect) {
        case "damage":
          badge.textContent = `Schaden +${effectValue}${bonusText}`;
          break;
        case "heal":
          badge.className = "badge def";
          badge.textContent = `Heilung +${effectValue}${bonusText}`;
          break;
        case "buff_atk":
          badge.textContent = `ATK Buff +${effectValue}${bonusText}`;
          break;
        case "debuff_enemy":
          badge.className = "badge def";
          badge.textContent = `Enemy ATK -${effectValue}${bonusText}`;
          break;
        default:
          badge.textContent = `Tier ${skill.tier}`;
      }
      stats.appendChild(badge);
      controls.appendChild(stats);
      const canUpgradeSkill = canUpgradeItem(skill, MAX_SKILL_TIER);
      const bonusIndicator = document.createElement("div");
      bonusIndicator.className = "skill-bonus-indicator";
      const indicatorOverrides = progressIndicatorOverrides || {};
      const indicatorTierClass = Math.max(1, Math.min(MAX_SKILL_TIER, Math.floor(indicatorOverrides.tierClass ?? Math.min(skill.tier, MAX_SKILL_TIER))));
      bonusIndicator.classList.add(`tier-${indicatorTierClass}`);
      bonusIndicator.setAttribute("aria-hidden", indicatorOverrides.readOnly ? "true" : "false");
      const title = document.createElement("div");
      title.className = "skill-bonus-title";
      const headerRow = document.createElement("div");
      headerRow.className = "skill-bonus-header";
      const progressLabel = document.createElement("span");
      progressLabel.className = "skill-bonus-progress-label";
      headerRow.appendChild(title);
      headerRow.appendChild(progressLabel);
      const bar = document.createElement("div");
      bar.className = "skill-bonus-progress";
      const fill = document.createElement("div");
      fill.className = "skill-bonus-progress-fill";
      bar.appendChild(fill);
      const metaRow = document.createElement("div");
      metaRow.className = "skill-bonus-meta";
      const status = document.createElement("span");
      if (isMagicRed) {
        if (allowBonusActivation) {
          bonusIndicator.dataset.skillBonus = "true";
          bonusIndicator.dataset.skillBonusKey = skill.key || skill.name;
          bonusIndicator.dataset.skillBonusReady = String(isReady);
          bonusIndicator.setAttribute("role", "button");
          bonusIndicator.setAttribute("aria-disabled", String(!isReady));
          bonusIndicator.tabIndex = isReady ? 0 : -1;
        } else {
          bonusIndicator.dataset.skillBonusReady = "false";
          bonusIndicator.setAttribute("aria-hidden", "true");
        }
        const bonusStageValue = Math.max(0, Number(indicatorOverrides.bonusStage ?? bonusPercent) || 0);
        title.textContent = indicatorOverrides.titleText || `Tier-6 (Bonusstufe ${bonusStageValue})`;
        const progressCap = indicatorOverrides.progressMax ?? magicInfo.copiesPerPercent;
        const progressValueCustom = indicatorOverrides.progressValue ?? progressDisplayValue;
        const forceFull = indicatorOverrides.forceFullProgress ?? true;
        const showFullProgress = forceFull && readyCount > 0 && Number.isFinite(progressCap) && progressCap > 0;
        const effectiveValue = showFullProgress ? progressCap : progressValueCustom;
        const ratio = progressCap === Infinity
          ? 1
          : (progressCap ? Math.min(1, Math.max(0, effectiveValue / progressCap)) : 0);
        fill.style.width = `${ratio * 100}%`;
        const progressLabelText = indicatorOverrides.progressLabel
          ? indicatorOverrides.progressLabel
          : (progressCap === Infinity ? `${effectiveValue}/∞` : `${effectiveValue}/${progressCap}`);
        progressLabel.textContent = progressLabelText;
        if (indicatorOverrides.statusText !== undefined) {
          status.textContent = indicatorOverrides.statusText;
          if (indicatorOverrides.statusClass) status.className = indicatorOverrides.statusClass;
        } else if (isReady) {
          status.className = "skill-bonus-ready";
          status.textContent = readyCount > 1 ? `${readyCount}x Upgrade bereit` : "Upgrade bereit";
        } else {
          status.textContent = "";
        }
        if (indicatorOverrides.ariaLabel) {
          bonusIndicator.setAttribute("aria-label", indicatorOverrides.ariaLabel);
        } else {
          const ariaBits = [`Tier-6 Bonus Fortschritt ${progressLabelText}`];
          ariaBits.push(isReady ? "Upgrade bereit." : "Noch nicht bereit.");
          bonusIndicator.setAttribute("aria-label", ariaBits.join(" "));
        }
      } else {
        const displayTierOverride = indicatorOverrides.displayTier ?? skill.tier;
        const nextTierOverride = indicatorOverrides.nextTier ?? Math.min(MAX_SKILL_TIER, skill.tier + 1);
        if (indicatorOverrides.titleText) {
          title.textContent = indicatorOverrides.titleText;
        } else {
          title.textContent = displayTierOverride >= MAX_SKILL_TIER
            ? `Tier ${displayTierOverride} (MAX)`
            : `Tier ${displayTierOverride} ➜ Tier ${nextTierOverride}`;
        }
        let progressCap = indicatorOverrides.progressMax;
        let infiniteCap = false;
        if (progressCap === Infinity) {
          infiniteCap = true;
        } else if (!Number.isFinite(progressCap) || progressCap <= 0) {
          if (requirement === Infinity) {
            infiniteCap = true;
          } else {
            progressCap = Math.max(1, requirement);
          }
        }
        let progressValue;
        if (Number.isFinite(indicatorOverrides.progressValue)) {
          progressValue = Math.max(0, indicatorOverrides.progressValue);
        } else if (infiniteCap) {
          progressValue = Math.min(skill.totalCopies, requirement === Infinity ? skill.totalCopies : Number.MAX_SAFE_INTEGER);
        } else {
          progressValue = Math.min(skill.totalCopies, progressCap || 1);
        }
        const progressRatio = infiniteCap
          ? 1
          : (progressCap ? Math.min(1, Math.max(0, progressValue / progressCap)) : 0);
        fill.style.width = `${progressRatio * 100}%`;
        const progressLabelText = indicatorOverrides.progressLabel
          ? indicatorOverrides.progressLabel
          : (infiniteCap ? `${progressValue}/∞` : `${progressValue}/${progressCap}`);
        progressLabel.textContent = progressLabelText;
        if (indicatorOverrides.statusText !== undefined) {
          status.textContent = indicatorOverrides.statusText;
          if (indicatorOverrides.statusClass) status.className = indicatorOverrides.statusClass;
        } else if (canUpgradeSkill) {
          status.className = "skill-bonus-ready";
          status.textContent = "Upgrade bereit";
        } else if (Number.isFinite(requirement)) {
          status.textContent = "";
        } else {
          status.textContent = "Maximum erreicht";
        }
        if (allowBonusActivation) {
          bonusIndicator.dataset.skillUpgrade = "true";
          bonusIndicator.dataset.skillUpgradeKey = skill.key || skill.name;
          const upgradeReady = canUpgradeSkill && skill.tier < MAX_SKILL_TIER;
          bonusIndicator.dataset.skillUpgradeReady = String(upgradeReady);
          bonusIndicator.setAttribute("role", "button");
          bonusIndicator.setAttribute("aria-disabled", String(!upgradeReady));
          bonusIndicator.tabIndex = upgradeReady ? 0 : -1;
        } else {
          bonusIndicator.dataset.skillUpgradeReady = "false";
          bonusIndicator.setAttribute("aria-hidden", "true");
        }
        const ariaLabel = indicatorOverrides.ariaLabel
          ? indicatorOverrides.ariaLabel
          : `Tier ${displayTierOverride} Fortschritt ${progressLabelText}`;
        bonusIndicator.setAttribute("aria-label", ariaLabel);
      }
      metaRow.appendChild(status);
      bonusIndicator.appendChild(headerRow);
      bonusIndicator.appendChild(bar);
      bonusIndicator.appendChild(metaRow);
      controls.appendChild(bonusIndicator);
      row.appendChild(controls);
      return row;
    }
    function renderInventory() {
      if (!inventoryList) return;
      ensureEquipmentState();
      inventoryList.innerHTML = "";
      const hasItems = Boolean(state.items.length);
      const emptyNotice = document.getElementById("inventoryEmpty");
      if (emptyNotice) emptyNotice.style.display = hasItems ? "none" : "block";
      if (inventoryFilterEmpty) {
        inventoryFilterEmpty.hidden = true;
        inventoryFilterEmpty.style.display = "none";
      }
      if (!hasItems) return;
      const filterValue = currentInventoryFilter || DEFAULT_INVENTORY_FILTER;
      const itemTimestamp = entry => Number(entry.lastObtainedAt || entry.createdAt || 0);
      const equippedKeys = new Set(
        Object.values(state.equipment || {}).filter(Boolean)
      );
      const getCategoryRank = item => {
        const normalizedCategory = normalizeItemCategory(item.category);
        return Object.prototype.hasOwnProperty.call(INVENTORY_CATEGORY_ORDER, normalizedCategory)
          ? INVENTORY_CATEGORY_ORDER[normalizedCategory]
          : 999;
      };
      const matchesFilter = item => {
        const category = normalizeItemCategory(item.category);
        return filterValue === "all" || category === filterValue;
      };
      const getItemKeyValue = item => (item && (item.key || item.name)) || null;
      const sortCurrentFilter = () => {
        const sorted = state.items
          .filter(matchesFilter)
          .sort((a, b) => {
            if (filterValue === "all") {
              const categoryDiff = getCategoryRank(a) - getCategoryRank(b);
              if (categoryDiff !== 0) return categoryDiff;
            }
            const equipRank = (equippedKeys.has(getItemKeyValue(a)) ? 0 : 1) - (equippedKeys.has(getItemKeyValue(b)) ? 0 : 1);
            if (equipRank !== 0) return equipRank;
            return itemTimestamp(b) - itemTimestamp(a);
          });
        currentInventoryOrder = sorted.map(getItemKeyValue).filter(Boolean);
        inventoryNeedsResort = false;
        return sorted;
      };
      const itemMap = new Map();
      state.items.forEach(item => {
        const key = getItemKeyValue(item);
        if (!key) return;
        itemMap.set(key, item);
      });
      const ensureOrderValidity = () => {
        const availableKeys = new Set(itemMap.keys());
        currentInventoryOrder = currentInventoryOrder.filter(key => availableKeys.has(key));
      };
      let orderedItems = [];
      if (inventoryNeedsResort) {
        orderedItems = sortCurrentFilter();
      } else {
        ensureOrderValidity();
        const orderSet = new Set(currentInventoryOrder);
        currentInventoryOrder.forEach(key => {
          const item = itemMap.get(key);
          if (!item || !matchesFilter(item)) return;
          orderedItems.push(item);
        });
        itemMap.forEach((item, key) => {
          if (orderSet.has(key)) return;
          currentInventoryOrder.push(key);
          orderSet.add(key);
          if (matchesFilter(item)) orderedItems.push(item);
        });
      }
      let visibleCount = 0;
      orderedItems.forEach(item => {
        const category = normalizeItemCategory(item.category);
        const row = createInventoryRow(item, { showUpgrade: true });
        if (row) {
          row.dataset.category = category;
          row.dataset.equipped = String(equippedKeys.has(getItemKeyValue(item)));
          inventoryList.appendChild(row);
          visibleCount += 1;
        }
      });
      if (inventoryFilterEmpty) {
        if (visibleCount === 0) {
          inventoryFilterEmpty.hidden = false;
          inventoryFilterEmpty.style.display = "block";
        } else {
          inventoryFilterEmpty.hidden = true;
          inventoryFilterEmpty.style.display = "none";
        }
      }
    }
    function equipItem(preferredSlot, itemKey) {
      ensureEquipmentState();
      const item = getItemByKey(itemKey);
      if (!item) return;
      const resolvedSlot = normalizeItemSlot(preferredSlot) || getItemSlot(item);
      if (!resolvedSlot || !EQUIPMENT_SLOT_DEFS[resolvedSlot]) return;
      if (!itemMatchesSlot(item, resolvedSlot)) return;
      const targetKey = item.key || item.name;
      clearItemFromOtherSlots(targetKey, resolvedSlot);
      if (state.equipment[resolvedSlot] === targetKey) return;
      state.equipment[resolvedSlot] = targetKey;
      recalcStats();
      saveState();
      updateUI();
    }
    function unequipSlot(slotKey) {
      const normalized = normalizeItemSlot(slotKey);
      if (!normalized) return;
      ensureEquipmentState();
      if (!state.equipment[normalized]) return;
      state.equipment[normalized] = null;
      recalcStats();
      saveState();
      updateUI();
    }
    function collectItemStats(item) {
      if (!item) return [];
      const stats = [];
      const push = (label, value, className) => {
        const numeric = Number(value) || 0;
        if (numeric > 0) {
          stats.push({ label, value: numeric, className });
        }
      };
      push("ATK", item.atk, "atk");
      push("DEF", item.def, "def");
      return stats;
    }
    function renderEquipmentSlots() {
      ensureEquipmentState();
      EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
        const slotEl = equipmentSlotMap[slotKey];
        if (!slotEl) return;
        const meta = EQUIPMENT_SLOT_DEFS[slotKey] || {};
        const iconEl = slotEl.querySelector(".slot-icon");
        const nameEl = slotEl.querySelector(".slot-name");
        const metaEl = slotEl.querySelector(".slot-meta");
        const statsEl = slotEl.querySelector(".slot-stats");
        const clearBtn = slotEl.querySelector(".slot-unequip");
        const headerLabel = slotEl.querySelector(".slot-header span");
        const equippedKey = state.equipment[slotKey];
        const item = getItemByKey(equippedKey);
        for (let tier = 1; tier <= MAX_ITEM_TIER; tier += 1) {
          slotEl.classList.remove(`tier-${tier}`);
        }
        if (!item) {
          slotEl.classList.remove("equipped");
          if (headerLabel) headerLabel.textContent = meta.label || slotKey.toUpperCase();
          if (nameEl) nameEl.textContent = "Leer";
          if (metaEl) metaEl.textContent = meta.empty || "Slot frei";
          if (statsEl) statsEl.innerHTML = "";
          if (iconEl) iconEl.innerHTML = '<span class="slot-placeholder">?</span>';
          if (clearBtn) clearBtn.hidden = true;
          return;
        }
        slotEl.classList.add("equipped");
        const tierClass = `tier-${Math.min(MAX_ITEM_TIER, Math.max(1, Number(item.tier) || 1))}`;
        slotEl.classList.add(tierClass);
        if (headerLabel) headerLabel.textContent = item.name || meta.label || slotKey;
        if (nameEl) nameEl.textContent = item.name;
        if (metaEl) {
          const tierValue = item.tier || 1;
          const copyValue = item.totalCopies || 1;
          metaEl.textContent = "Tier " + tierValue + " / Kopien " + copyValue;
        }
        const statBadges = collectItemStats(item);
        if (statsEl) {
          statsEl.innerHTML = "";
          statBadges.forEach(({ label, value, className }) => {
            const chip = document.createElement("span");
            chip.className = `badge ${className} inventory-stat-badge`;
            chip.textContent = `${label} +${value}`;
            statsEl.appendChild(chip);
          });
        }
        if (iconEl) {
          iconEl.innerHTML = getItemIcon(item.icon, item.key);
        }
        if (clearBtn) {
          clearBtn.hidden = false;
          clearBtn.dataset.slot = slotKey;
        }
      });
    }
    function renderSkills() {
      if (!skillList) return;
      skillList.innerHTML = "";
      const uniqueSkills = state.skills.length;
      const totalCopies = state.skills.reduce((sum, skill) => {
        return sum + Math.max(1, Math.floor(skill.totalCopies || 1));
      }, 0);
      if (!uniqueSkills) {
        if (skillEmpty) skillEmpty.style.display = "block";
        return;
      }
      if (skillEmpty) skillEmpty.style.display = "none";
      const sorted = [...state.skills].sort((a, b) => {
        const left = b.lastObtainedAt || b.createdAt || 0;
        const right = a.lastObtainedAt || a.createdAt || 0;
        return left - right;
      });
      sorted.forEach(skill => {
        const row = createSkillRow(skill, { showUpgrade: true });
        if (row) skillList.appendChild(row);
      });
    }
    function renderShopLatest() {
      if (!shopLatest) return;
      shopLatest.querySelectorAll(".inventory-item").forEach(el => el.remove());
      let record = state.lastShopPurchase;
      if (!record) {
        let latestItem = null;
        if (state.items.length) {
          latestItem = [...state.items].sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0))[0];
        }
        let latestSkill = null;
        if (state.skills.length) {
          latestSkill = [...state.skills].sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0))[0];
        }
        if (latestItem || latestSkill) {
          if (latestItem && latestSkill) {
            const itemTime = latestItem.lastObtainedAt || latestItem.createdAt || 0;
            const skillTime = latestSkill.lastObtainedAt || latestSkill.createdAt || 0;
            record = itemTime >= skillTime ? { type: "item", key: latestItem.key } : { type: "skill", key: latestSkill.key };
          } else if (latestItem) {
            record = { type: "item", key: latestItem.key };
          } else if (latestSkill) {
            record = { type: "skill", key: latestSkill.key };
          }
        }
      }
      if (!record) {
        if (shopLatestEmpty) shopLatestEmpty.style.display = "block";
        return;
      }
      let row = null;
      if (record.type === "item") {
        const item = state.items.find(entry => entry.key === record.key);
        if (item) {
          row = createInventoryRow(item, {
            showUpgrade: false,
            showProgressIndicator: true,
            progressIndicatorOverrides: {
              tierClass: 1,
              readOnly: true
            }
          });
        }
      } else if (record.type === "skill") {
        const skill = state.skills.find(entry => entry.key === record.key);
        if (skill) {
          row = createSkillRow(skill, {
            showUpgrade: false,
            allowBonusActivation: false,
            progressIndicatorOverrides: {
              tierClass: 1,
              readOnly: true
            }
          });
        }
      }
      if (!row) {
        if (shopLatestEmpty) shopLatestEmpty.style.display = "block";
        return;
      }
      if (shopLatestEmpty) shopLatestEmpty.style.display = "none";
      shopLatest.appendChild(row);
    }
    function sortInventoryByNewest() {
      state.items.sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0));
    }
    function sortSkillsByNewest() {
      state.skills.sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0));
    }
    function triggerItemUpgrade(key) {
      const item = state.items.find(entry => (entry.key || entry.name) === key);
      if (!item || !canUpgradeItem(item)) return;
      item.tier = Math.min(MAX_ITEM_TIER, item.tier + 1);
      item.lastUpgradeAt = Date.now();
      updateItemDerivedStats(item);
      recalcStats();
      saveState();
      sortInventoryByNewest();
      updateUI();
    }
    function triggerSkillUpgrade(key) {
      const skill = state.skills.find(entry => (entry.key || entry.name) === key);
      if (!skill || !canUpgradeItem(skill, MAX_SKILL_TIER)) return;
      skill.tier = Math.min(MAX_SKILL_TIER, skill.tier + 1);
      skill.lastUpgradeAt = Date.now();
      updateSkillDerivedStats(skill);
      saveState();
      sortSkillsByNewest();
      updateUI();
    }
    function triggerSkillBonusUpgrade(key) {
      const skill = state.skills.find(entry => (entry.key || entry.name) === key);
      if (!skill) return;
      updateSkillDerivedStats(skill);
      const magicInfo = getSkillOvercapInfo(skill);
      if (!magicInfo.availablePercent) return;
      const maxBonus = Math.floor(magicInfo.overcapCopies / magicInfo.copiesPerPercent);
      const currentBonus = Math.max(0, Math.floor(skill.overcapBonusPercent || 0));
      if (currentBonus >= maxBonus) return;
      skill.overcapBonusPercent = Math.min(maxBonus, currentBonus + 1);
      skill.lastUpgradeAt = Date.now();
      updateSkillDerivedStats(skill);
      saveState();
      sortSkillsByNewest();
      updateUI();
    }
    function addItemToInventory(template) {
      const now = Date.now();
      const key = template.key;
      const existing = state.items.find(entry => entry.key === key);
      const maxCopies = getMaxCopiesForItem(existing || template || {});
      if (existing) {
        const currentCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
        if (currentCopies >= maxCopies) {
          updateItemDerivedStats(existing);
          sortInventoryByNewest();
          return { item: existing, isNew: false };
        }
        existing.totalCopies = currentCopies + 1;
        existing.lastObtainedAt = now;
        updateItemDerivedStats(existing);
        sortInventoryByNewest();
        return { item: existing, isNew: false };
      }
      const fresh = cloneItem(template);
      fresh.createdAt = now;
      fresh.lastObtainedAt = now;
      state.items.push(fresh);
      sortInventoryByNewest();
      return { item: fresh, isNew: true };
    }
    function addSkillToCollection(template) {
      const now = Date.now();
      const key = template.key;
      const existing = state.skills.find(entry => entry.key === key);
      const maxCopies = getMaxCopiesForSkill(existing || template || {});
      if (existing) {
        const currentCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
        if (Number.isFinite(maxCopies) && currentCopies >= maxCopies) {
          updateSkillDerivedStats(existing);
          sortSkillsByNewest();
          return { skill: existing, isNew: false };
        }
        existing.totalCopies = currentCopies + 1;
        existing.lastObtainedAt = now;
        updateSkillDerivedStats(existing);
        sortSkillsByNewest();
        return { skill: existing, isNew: false };
      }
      const fresh = cloneSkill(template);
      fresh.createdAt = now;
      fresh.lastObtainedAt = now;
      state.skills.push(fresh);
      sortSkillsByNewest();
      return { skill: fresh, isNew: true };
    }
    function updateGachaOptionStyles() {
      if (!gachaTypeInputs) return;
      gachaTypeInputs.forEach(input => {
        const wrapper = input.closest(".gacha-option");
        if (wrapper) wrapper.classList.toggle("active", input.checked);
      });
    }
    function applyGachaPreference(pref) {
      if (!gachaTypeInputs || !gachaTypeInputs.length) return;
      const target = pref || state.gachaPreference || "weapon";
      let found = false;
      gachaTypeInputs.forEach((input, idx) => {
        const match = input.value === target;
        input.checked = match;
        if (match) found = true;
        if (!found && idx === gachaTypeInputs.length - 1 && !match) {
          input.checked = false;
        }
      });
      if (!found) {
        gachaTypeInputs[0].checked = true;
        state.gachaPreference = gachaTypeInputs[0].value;
      } else {
        state.gachaPreference = target;
      }
      updateGachaOptionStyles();
    }
    function getSelectedGachaType() {
      if (!gachaTypeInputs || !gachaTypeInputs.length) {
        return state.gachaPreference || "weapon";
      }
      const selected = Array.from(gachaTypeInputs).find(input => input.checked);
      return selected ? selected.value : state.gachaPreference || "weapon";
    }
    function getShopPoolForCategory(category) {
      let pool = KNIGHT_POOL;
      if (category && category !== "any" && category !== "skill") {
        const filtered = KNIGHT_POOL.filter(item => item.category === category);
        if (filtered.length) pool = filtered;
      }
      return pool.filter(isItemEligibleForShop);
    }
    function pickBlueprintFromPool(pool, remainingFn = getRemainingShopCopies) {
      if (!pool || !pool.length) return null;
      const weighted = [];
      pool.forEach(item => {
        const remaining = Math.max(0, (remainingFn ? remainingFn(item) : getRemainingShopCopies(item)));
        for (let i = 0; i < remaining; i += 1) {
          weighted.push(item);
        }
      });
      if (!weighted.length) return null;
      const index = Math.floor(Math.random() * weighted.length);
      return weighted[index];
    }
    function describeGachaCategory(category) {
      if (category && GACHA_CATEGORY_LABELS[category]) return GACHA_CATEGORY_LABELS[category];
      if (!category || category === "any") return GACHA_CATEGORY_LABELS.any || "Items";
      return category.charAt(0).toUpperCase() + category.slice(1);
    }
    function getRemainingCopiesForCategory(category) {
      if (category === "skill") {
        return Infinity;
      }
      const pool = (!category || category === "any")
        ? KNIGHT_POOL
        : KNIGHT_POOL.filter(item => item.category === category);
      if (!pool.length) return 0;
      return pool.reduce((sum, template) => {
        return sum + Math.max(0, getRemainingShopCopies(template));
      }, 0);
    }
    function formatRemainingCopyText(category, amount) {
      if (!isFinite(amount)) return "∞ übrig";
      if (amount <= 0) return "Ausverkauft";
      return amount + "x übrig";
    }
    function updateGachaRemainingDisplays() {
      if (!gachaRemainingLabels || !gachaRemainingLabels.length) return;
      gachaRemainingLabels.forEach(label => {
        const category = label.getAttribute("data-remaining-category");
        const remaining = getRemainingCopiesForCategory(category);
        label.textContent = formatRemainingCopyText(category, remaining);
      });
    }
    let displayedCoins = state.coins;
    let pendingCoinAnimation = null;

    function spawnCoinAnimation(amount, anchor, variant = "gain") {
      const anchorEl = anchor || coinTop;
      if (!coinAnimationLayer || !anchorEl) return;
      const isLoss = variant === "loss" || amount < 0;
      const displayAmount = Math.abs(Math.round(amount));
      const rect = anchorEl.getBoundingClientRect();
      const celebration = document.createElement("div");
      celebration.className = `coin-celebration ${isLoss ? "loss" : "gain"}`;
      celebration.style.left = `${rect.left + rect.width / 2}px`;
      celebration.style.top = `${rect.top + rect.height / 2}px`;
      celebration.innerHTML = `
        <div class="coin-main">
          <div class="coin-symbol">${isLoss ? "💸" : "💰"}</div>
        </div>
        <div class="coin-amount">${isLoss ? "-" : "+"}${displayAmount} Coins</div>
      `;
      const sparkCount = isLoss ? 8 : 12;
      for (let i = 0; i < sparkCount; i++) {
        const spark = document.createElement("span");
        spark.className = "coin-spark";
        const angle = (Math.PI * 2 * (i / sparkCount)) + (Math.random() * 0.6 - 0.3);
        const radius = 140 + Math.random() * 45;
        const targetX = Math.cos(angle) * radius;
        const targetY = Math.sin(angle) * radius - 40;
        spark.style.setProperty("--targetX", `${targetX}px`);
        spark.style.setProperty("--targetY", `${targetY}px`);
        spark.style.animationDelay = `${0.12 * i}s`;
        celebration.appendChild(spark);
      }
      coinAnimationLayer.appendChild(celebration);
      setTimeout(() => celebration.remove(), 4000);
      const badgeClass = isLoss ? "coin-badge-loss" : "coin-badge-boost";
      coinTop.classList.add(badgeClass);
      coinTop.addEventListener("animationend", () => {
        coinTop.classList.remove(badgeClass);
      }, { once: true });
    }
    function updateHeroAvatar() {
      if (!heroAvatar) return;
      const atkBonus = Math.max(0, state.atk - BASE_ATK);
      const defBonus = Math.max(0, state.def - BASE_DEF);
      const atkTier = atkBonus >= 5 ? 3 : atkBonus >= 2 ? 2 : 1;
      const defTier = defBonus >= 5 ? 3 : defBonus >= 2 ? 2 : 1;
      const hasInventory = Array.isArray(state.items) && state.items.length > 0;
      heroAvatar.setAttribute("data-atk-tier", String(atkTier));
      heroAvatar.setAttribute("data-def-tier", String(defTier));
      heroAvatar.classList.toggle("no-gear", !hasInventory);
      heroAvatar.classList.toggle("has-gear", hasInventory);
      if (heroAvatarImage) {
        const blueprintSrc = "assets/blueprint_clean.svg";
        const knightSrc = "assets/knight_idle_fin.svg";
        heroAvatarImage.src = hasInventory ? knightSrc : blueprintSrc;
        heroAvatarImage.alt = hasInventory ? "Ritter bereit fuer den Kampf" : "Blueprint deines Helden";
        heroAvatarImage.classList.toggle("is-blueprint", !hasInventory);
        heroAvatarImage.classList.toggle("is-knight", hasInventory);
      }
    }
    function describeHeroTrait(atk, def) {
      if (atk - def >= 2) return "Aggressiv";
      if (def - atk >= 2) return "Defensiv";
      return "Ausbalanciert";
    }
    function describeEnemyTrait(enemy) {
      if (!enemy) return "Unbekannt";
      const label = ENEMY_VARIANT_LABELS[enemy.variant];
      if (label) return label;
      if (enemy.atk >= enemy.def + 2) return "Berserker";
      if (enemy.def >= enemy.atk + 2) return "Tank";
      return "Unberechenbar";
    }
    function getBattleTheme(level) {
      if (level >= 9) return "celestial";
      if (level >= 5) return "mountain";
      return "forest";
    }
    function setActiveBattleSide(isHeroActive) {
      heroCardElements.forEach(el => el.classList.toggle("attacking", Boolean(isHeroActive)));
      enemyCardElements.forEach(el => el.classList.toggle("attacking", !isHeroActive));
    }
    function pulseBattleSide(isHero) {
      const targets = isHero ? heroCardElements : enemyCardElements;
      targets.forEach(sideEl => {
        sideEl.classList.remove("hit");
        void sideEl.offsetWidth;
        sideEl.classList.add("hit");
        setTimeout(() => sideEl.classList.remove("hit"), 360);
      });
    }
    function clearBattleSideState() {
      heroCardElements.forEach(el => el.classList.remove("attacking", "hit"));
      enemyCardElements.forEach(el => el.classList.remove("attacking", "hit"));
    }
    function getEnemyIconKey(enemy) {
      if (enemy && enemy.icon && ENEMY_ICON_PATHS[enemy.icon]) return enemy.icon;
      if (enemy && enemy.variant && ENEMY_ICON_PATHS[enemy.variant]) return enemy.variant;
      return DEFAULT_ENEMY_ICON_KEY;
    }
    function getEnemyIconPath(enemy) {
      const key = getEnemyIconKey(enemy);
      return { key, path: ENEMY_ICON_PATHS[key] };
    }
    function updateEnemyPreviewArt(enemy) {
      if (!battleEnemyPreviewIcon) return;
      const { path } = getEnemyIconPath(enemy);
      battleEnemyPreviewIcon.src = path;
      battleEnemyPreviewIcon.alt = enemy && enemy.name ? enemy.name : "Gegner";
    }
    function updateActiveEnemyArt(enemy) {
      const { path } = getEnemyIconPath(enemy);
      const altText = enemy && enemy.name ? enemy.name : "Gegner";
      if (modalEnemyIcon) {
        modalEnemyIcon.src = path;
        modalEnemyIcon.alt = altText;
      }
      if (battleEnemySprite) {
        battleEnemySprite.src = path;
        battleEnemySprite.alt = altText;
      }
    }
    function updateBattlePreview() {
      if (!canRenderBattlePreview) return;
      const heroAtk = Math.max(0, state.atk || 0);
      const heroDef = Math.max(0, state.def || 0);
      const heroHpMax = getHeroMaxHp();
      if (battleHeroAtkStat) battleHeroAtkStat.textContent = String(heroAtk);
      if (battleHeroDefStat) battleHeroDefStat.textContent = String(heroDef);
      if (battleHeroHpStat) battleHeroHpStat.textContent = String(heroHpMax);
      if (battleHeroTierLabel) battleHeroTierLabel.textContent = "Rang " + Math.max(1, state.battleUnlocked || 1);
      if (battleHeroFlavor) {
        const equippedCount = getEquippedItems().length;
        battleHeroFlavor.textContent = `${equippedCount}/${EQUIPMENT_SLOT_KEYS.length} Slots belegt`;
      }
      if (battleHeroTrait) battleHeroTrait.textContent = describeHeroTrait(heroAtk, heroDef);
      if (battleHeroGearList) {
        battleHeroGearList.innerHTML = "";
        const gearEntries = [];
        EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
          const eqKey = state.equipment && state.equipment[slotKey];
          if (!eqKey) return;
          const item = getItemByKey(eqKey);
          if (!item) return;
          const meta = EQUIPMENT_SLOT_DEFS[slotKey] || {};
          gearEntries.push({
            slot: meta.label || slotKey,
            name: item.name || eqKey,
            icon: getItemIcon(item.icon, item.key),
            stats: collectItemStats(item)
          });
        });
        if (!gearEntries.length) {
          const empty = document.createElement("li");
          empty.className = "battle-gear-empty";
          empty.textContent = "Keine Ausrüstung";
          battleHeroGearList.appendChild(empty);
        } else {
          gearEntries.forEach(entry => {
            const li = document.createElement("li");
            li.className = "battle-gear-card";
            const iconWrap = document.createElement("div");
            iconWrap.className = "gear-icon";
            iconWrap.innerHTML = entry.icon;
            const textWrap = document.createElement("div");
            textWrap.className = "gear-text";
            const slotLabel = document.createElement("strong");
            slotLabel.textContent = entry.slot;
            const nameLabel = document.createElement("span");
            nameLabel.textContent = entry.name;
            textWrap.appendChild(slotLabel);
            textWrap.appendChild(nameLabel);
            const statsRow = document.createElement("div");
            statsRow.className = "gear-stats";
            entry.stats.forEach(stat => {
              const badge = document.createElement("span");
              badge.className = `badge ${stat.className}`;
              badge.textContent = `${stat.label} +${stat.value}`;
              statsRow.appendChild(badge);
            });
            if (entry.stats.length) {
              textWrap.appendChild(statsRow);
            }
            li.appendChild(iconWrap);
            li.appendChild(textWrap);
            battleHeroGearList.appendChild(li);
          });
        }
      }
      const previewLevel = Math.min(Math.max(1, state.battleUnlocked || 1), ENEMY_DATA.length);
      const enemy = ENEMIES[previewLevel] || ENEMY_DATA[0];
      if (battleEnemyPreviewName) battleEnemyPreviewName.textContent = enemy ? enemy.name : "Unbekannt";
      if (battleEnemyPreviewLevel) battleEnemyPreviewLevel.textContent = enemy ? `Rang ${enemy.level || previewLevel}` : "Rang ?";
      if (battleEnemyAtkStat) battleEnemyAtkStat.textContent = enemy ? String(enemy.atk) : "-";
      if (battleEnemyDefStat) battleEnemyDefStat.textContent = enemy ? String(enemy.def) : "-";
      if (battleEnemyHpStat) battleEnemyHpStat.textContent = enemy ? String(enemy.hp) : "-";
      if (battleEnemyTrait) battleEnemyTrait.textContent = describeEnemyTrait(enemy);
      updateEnemyPreviewArt(enemy);
      if (battleEnemyFlavor) {
        battleEnemyFlavor.textContent = enemy
          ? `ATK ${enemy.atk} • DEF ${enemy.def} • HP ${enemy.hp}`
          : "Gegner unbekannt";
      }
    }
    function pushBattleLog(message, variant = "system") {
      if (!battleLog) return;
      const entry = document.createElement("div");
      entry.className = `battle-entry battle-entry-${variant}`;
      entry.textContent = message;
      battleLog.appendChild(entry);
      battleLog.scrollTop = battleLog.scrollHeight;
    }
    function resetBattleLog(message) {
      if (!battleLog) return;
      battleLog.innerHTML = "";
      if (message) pushBattleLog(message, "system");
    }
    function updateUI() {
      const diff = state.coins - displayedCoins;
      if (pendingCoinAnimation) {
        const info = pendingCoinAnimation;
        spawnCoinAnimation(info.amount, info.anchor, info.variant || (info.amount < 0 ? "loss" : "gain"));
        pendingCoinAnimation = null;
      } else if (diff !== 0) {
        spawnCoinAnimation(diff, null, diff < 0 ? "loss" : "gain");
      }
      displayedCoins = state.coins;
      if (coinTop) coinTop.textContent = "Coins: " + state.coins;
      if (atkDisplay) atkDisplay.textContent = "ATK " + state.atk;
      if (defDisplay) defDisplay.textContent = "DEF " + state.def;
      const equippedCount = getEquippedItems().length;
      if (hpDisplay) hpDisplay.textContent = "HP " + getHeroMaxHp();
      if (itemsDisplay) itemsDisplay.textContent = "Gear: " + equippedCount + "/" + EQUIPMENT_SLOT_KEYS.length;
      updateHeroAvatar();
      renderEquipmentSlots();
      renderInventory();
      renderSkills();
      renderShopLatest();
      updateGachaRemainingDisplays();
      renderBattleSkillBar();
      if (canRenderBattlePreview) updateBattlePreview();
    }
    function updateOverallSummary() {
      if (!overallSummary) return;
      const total = allCheckables.length;
      let correctCount = 0;
      allCheckables.forEach(el => {
        if (el.classList.contains("correct")) {
          correctCount += 1;
        }
      });
      const percent = total === 0 ? 0 : Math.round((correctCount / total) * 100);
      overallSummary.textContent = `${correctCount}/${total} Aufgaben aktuell richtig (${percent}%)`;
    }
    function gradeSection(sectionId, triggerBtn) {
      const section = document.querySelector(`.section[data-section="${sectionId}"]`);
      if (!section) return;
      const fields = section.querySelectorAll("[data-answer], .dnd-target");
      let correctCount = 0;
      const total = fields.length;
      fields.forEach(field => {
        const wrap = field.closest(".task-field");
        field.classList.remove("correct", "incorrect");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        let slotRef = null;
        const solution = (field.getAttribute("data-answer") || "").trim();
        let userValue = "";
        if (field.classList.contains("dnd-target")) {
          slotRef = field.querySelector(".drop-slot");
          if (slotRef) slotRef.classList.remove("correct", "incorrect");
          userValue = slotRef ? (slotRef.dataset.value || slotRef.textContent || "").trim() : "";
        } else if (field.tagName === "SELECT") {
          userValue = field.value.trim();
        } else if (field.tagName === "INPUT") {
          userValue = field.value.trim();
        }
        let isCorrect = false;
        if (field.tagName === "INPUT") {
          isCorrect = userValue.toUpperCase() === solution.toUpperCase();
        } else {
          isCorrect = userValue === solution;
        }
        if (isCorrect) {
          correctCount += 1;
          field.classList.add("correct");
          if (wrap) wrap.classList.add("correct");
          if (slotRef) slotRef.classList.add("correct");
        } else {
          field.classList.add("incorrect");
          if (wrap) wrap.classList.add("incorrect");
          if (slotRef) slotRef.classList.add("incorrect");
        }
      });
      const percent = total === 0 ? 0 : Math.round((correctCount / total) * 100);
      let resultMsg = `${correctCount}/${total} richtig (${percent}%)`;
      if (correctCount === total) {
        const clears = state.sectionClears[sectionId] || 0;
        const resets = state.sectionResets[sectionId] || 0;
        const actions = total;
        let reward = 0;
        if (clears === 0) {
          reward = actions * COINS_PER_ACTION;
        } else if (resets > 0) {
          reward = actions * COINS_PER_ACTION_AFTER_RESET;
          const remainingResets = Math.max(0, resets - 1);
          state.sectionResets[sectionId] = remainingResets;
        }
        state.sectionClears[sectionId] = clears + 1;
        if (reward > 0) {
          state.coins += reward;
          pendingCoinAnimation = { amount: reward, anchor: triggerBtn || null, variant: "gain" };
          resultMsg += ` | +${reward} Coins`;
        } else if (clears > 0) {
          resultMsg += " | fuer mehr Coins erst zuruecksetzen.";
        }
      } else {
        resultMsg += " | versuche es erneut.";
      }
      const resultEl = document.getElementById(`result-${sectionId}`);
      if (resultEl) resultEl.textContent = resultMsg;
      updateUI();
      updateOverallSummary();
      recalcStats();
      saveState();
    }
    function resetSection(sectionId) {
      const section = document.querySelector(`.section[data-section="${sectionId}"]`);
      if (!section) return;
      const fields = section.querySelectorAll("[data-answer], .dnd-target");
      fields.forEach(field => {
        const wrap = field.closest(".task-field");
        field.classList.remove("correct", "incorrect");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        if (field.tagName === "SELECT") {
          field.value = "";
        } else if (field.tagName === "INPUT") {
          field.value = "";
          if (field.dataset && field.dataset.hint) {
            updateInputHintOverlay(field);
          }
        } else if (field.classList.contains("dnd-target")) {
          const slot = field.querySelector(".drop-slot");
          if (slot) {
            slot.textContent = "";
            delete slot.dataset.value;
            slot.classList.remove("correct", "incorrect");
          }
        }
      });
      reshuffleDndSection(section);
      const resultEl = document.getElementById(`result-${sectionId}`);
      if (resultEl) resultEl.textContent = "Abschnitt wurde zurueckgesetzt.";
      state.sectionResets[sectionId] = (state.sectionResets[sectionId] || 0) + 1;
      updateUI();
      updateOverallSummary();
      saveState();
    }
    if (testAnimationBtn) {
      testAnimationBtn.addEventListener("click", () => {
        state.coins += 200;
        pendingCoinAnimation = { amount: 200, anchor: testAnimationBtn, variant: "gain" };
        updateUI();
        saveState();
      });
    }

    function clearLocalProgress() {
      const message = "Lokale Fortschrittsdaten wirklich loeschen? (Taste: Ctrl + Delete)";
      if (confirm(message)) {
        localStorage.removeItem(STORAGE_KEY);
        location.reload();
      }
    }

    document.addEventListener("keydown", (event) => {
      if (event.ctrlKey && (event.key === "Delete" || event.key === "Del")) {
        event.preventDefault();
        clearLocalProgress();
      }
    });

    gachaBtn.addEventListener("click", () => {
      const cost = 20;
      if (state.coins < cost) {
        setGachaStatus("Nicht genug Coins (20 noetig).");
        return;
      }
      const type = getSelectedGachaType();
      state.gachaPreference = type;
      if (type === "skill") {
        state.coins -= cost;
        pendingCoinAnimation = { amount: -cost, anchor: gachaBtn, variant: "loss" };
        const { skill } = addSkillToCollection(SKILL_POOL[Math.floor(Math.random() * SKILL_POOL.length)]);
        state.lastShopPurchase = { type: "skill", key: skill.key, timestamp: Date.now() };
        updateUI();
      } else {
        const availablePool = getShopPoolForCategory(type);
        if (!availablePool.length) {
          const label = describeGachaCategory(type);
          setGachaStatus(label + "-Kategorie ausverkauft: Alle Items bereits Tier " + MAX_ITEM_TIER + ".");
          return;
        }
        const blueprint = pickBlueprintFromPool(availablePool);
        if (!blueprint) {
          const label = describeGachaCategory(type);
          setGachaStatus(label + "-Kategorie ausverkauft: Alle Items bereits Tier " + MAX_ITEM_TIER + ".");
          return;
        }
        state.coins -= cost;
        pendingCoinAnimation = { amount: -cost, anchor: gachaBtn, variant: "loss" };
        const { item } = addItemToInventory(blueprint);
        state.lastShopPurchase = { type: "item", key: item.key, timestamp: Date.now() };
        recalcStats();
        updateUI();
      }
      setGachaStatus("");
      saveState();
      updateGachaOptionStyles();
    });

    const ENEMY_VARIANTS = ["goblin", "goblin-army", "goblin-king"];
    const ENEMY_VARIANT_LABELS = {
      goblin: "Schneller Nahkaempfer",
      "goblin-army": "Verstaerkungen im Ruecken",
      "goblin-king": "Koenigliche Elite"
    };
    const DEFAULT_ENEMY_ICON_KEY = "kobold";
    const ENEMY_ICON_PATHS = {
      kobold: "assets/enemy-kobold.svg",
      "gruener-goblin": "assets/enemy-gruener-goblin.svg",
      hobgoblin: "assets/enemy-hobgoblin.svg",
      waldgoblin: "assets/enemy-waldgoblin.svg",
      hoehlengoblin: "assets/enemy-hoehlengoblin.svg",
      bergtroll: "assets/enemy-bergtroll.svg",
      dunkelgoblin: "assets/enemy-dunkelgoblin.svg",
      kriegsgoblin: "assets/enemy-kriegsgoblin.svg",
      schattengoblin: "assets/enemy-schattengoblin.svg",
      daemonengoblin: "assets/enemy-daemonengoblin.svg",
      goblinkoenig: "assets/enemy-goblinkoenig.svg",
      goblin: "assets/enemy-kobold.svg",
      "goblin-army": "assets/enemy-kriegsgoblin.svg",
      "goblin-king": "assets/enemy-goblinkoenig.svg"
    };
    const ENEMY_DATA = [
      { name: "Kobold", icon: "kobold", hp: 16, atk: 2, def: 0, variance: 1, crit: 0.06, variant: "goblin" },
      { name: "Gruener Goblin", icon: "gruener-goblin", hp: 20, atk: 3, def: 0, variance: 1, crit: 0.07, variant: "goblin" },
      { name: "Hobgoblin", icon: "hobgoblin", hp: 24, atk: 4, def: 1, variance: 1, crit: 0.08, variant: "goblin" },
      { name: "Waldgoblin", icon: "waldgoblin", hp: 26, atk: 4, def: 2, variance: 2, crit: 0.09, variant: "goblin" },
      { name: "Hoehlengoblin", icon: "hoehlengoblin", hp: 30, atk: 5, def: 2, variance: 2, crit: 0.1, variant: "goblin" },
      { name: "Bergtroll", icon: "bergtroll", hp: 34, atk: 6, def: 2, variance: 2, crit: 0.11, variant: "goblin-army" },
      { name: "Dunkelgoblin", icon: "dunkelgoblin", hp: 38, atk: 6, def: 3, variance: 2, crit: 0.12, variant: "goblin-army" },
      { name: "Kriegsgoblin", icon: "kriegsgoblin", hp: 42, atk: 7, def: 3, variance: 3, crit: 0.13, variant: "goblin-army" },
      { name: "Schattengoblin", icon: "schattengoblin", hp: 46, atk: 7, def: 4, variance: 3, crit: 0.14, variant: "goblin-army" },
      { name: "Daemonengoblin", icon: "daemonengoblin", hp: 52, atk: 8, def: 4, variance: 3, crit: 0.15, variant: "goblin-army" },
      { name: "Goblinkoenig", icon: "goblinkoenig", hp: 60, atk: 9, def: 5, variance: 3, crit: 0.18, variant: "goblin-king" }
    ];
    const ENEMIES = {};
    ENEMY_DATA.forEach((enemy, index) => {
      const level = index + 1;
      ENEMIES[level] = { ...enemy, level };
    });
    canRenderBattlePreview = true;
    updateBattlePreview();
    state.battleUnlocked = Math.min(ENEMY_DATA.length, Math.max(1, Math.floor(state.battleUnlocked || 1)));
    Object.keys(state.battleClears || {}).forEach(key => {
      const level = Number(key);
      if (!level || level > ENEMY_DATA.length) {
        delete state.battleClears[key];
      }
    });
    let battleInProgress = false;
    let battleSimHideTimer = null;
    function renderBattleButtons() {
      if (!battleButtonContainer) return;
      battleButtonContainer.innerHTML = "";
      battleButtons = [];
      ENEMY_DATA.forEach((enemy, index) => {
        const level = index + 1;
        const btn = document.createElement("button");
        btn.className = "battle-btn";
        btn.dataset.enemy = String(level);
        const label = `Rang ${level} ${enemy.name}`;
        btn.dataset.label = label;
        btn.textContent = label;
        btn.addEventListener("click", () => {
          startBattle(level);
        });
        battleButtonContainer.appendChild(btn);
        battleButtons.push(btn);
      });
      updateBattleButtons();
    }

    function getOwnedBattleSkills() {
      return state.skills
        .map(skill => updateSkillDerivedStats({ ...skill }))
        .filter(skill => skill && skill.tier > 0)
        .sort((a, b) => {
          if (b.tier !== a.tier) return b.tier - a.tier;
          const timeDiff = (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0);
          if (timeDiff !== 0) return timeDiff;
          return a.name.localeCompare(b.name);
        });
    }

    function setupBattleSkills(hero, enemy) {
      const owned = getOwnedBattleSkills().slice(0, 9);
      const combosActive = DEFAULT_SKILL_INPUT_MODE === "hotkeys" && skillHotkeyPool.length;
      const usedCombos = new Set();
      battleSkillStates = owned.map((skill, index) => {
        const entry = {
          key: skill.key,
          skill,
          used: false
        };
        const bonusPercent = Number(skill.overcapBonusPercent || 0);
        const tierLabel = bonusPercent > 0 ? `Tier ${skill.tier} +${bonusPercent}%` : `Tier ${skill.tier}`;
        entry.displayLabel = `${skill.name} (${tierLabel})`;
        if (combosActive) {
          assignRandomCombo(entry, usedCombos);
          if (entry.comboId) usedCombos.add(entry.comboId);
        } else {
          entry.mode = "legacy";
          entry.hotkeyDisplay = String(index + 1);
          entry.legacyKey = index + 1;
        }
        return entry;
      });
      resetSkillKeyTracking();
      currentBattleContext = { hero, enemy };
      renderBattleSkillBar();
    }

    function renderBattleSkillBar() {
      if (!battleSkillBar) return;
      battleSkillBar.innerHTML = "";
      if (!battleSkillStates.length) {
        const info = document.createElement("span");
        info.className = "battle-skill-desc";
        const combosActive = DEFAULT_SKILL_INPUT_MODE === "hotkeys" && skillHotkeyPool.length > 0;
        const message = state.skills.length
          ? (combosActive ? "Skills bereit - nutze die angezeigten Hotkeys." : "Skills bereit - starte einen Kampf und nutze 1-9.")
          : "Noch keine Skills freigeschaltet.";
        info.textContent = message;
        battleSkillBar.appendChild(info);
        return;
      }
      battleSkillStates.forEach(entry => {
        const card = document.createElement("div");
        card.className = "battle-skill";
        if (entry.used) card.classList.add("used");
        const button = document.createElement("button");
        button.disabled = entry.used || !battleInProgress || !currentBattleContext;
        const hotkeyBadge = document.createElement("span");
        hotkeyBadge.className = "battle-skill-hotkey";
        hotkeyBadge.textContent = entry.hotkeyDisplay;
        const label = document.createElement("span");
        label.textContent = entry.displayLabel;
        button.appendChild(hotkeyBadge);
        button.appendChild(label);
        button.addEventListener("click", () => {
          activateBattleSkill(entry);
        });
        card.appendChild(button);
        const effectValue = getSkillEffectivePower(entry.skill);
        const bonusPercent = Number(entry.skill.overcapBonusPercent || 0);
        const desc = document.createElement("span");
        desc.className = "battle-skill-desc";
        let effectText = "";
        const bonusDescriptor = bonusPercent > 0 ? ` (+${bonusPercent}%)` : "";
        switch (entry.skill.effect) {
          case "damage":
            effectText = `Fügt sofort ${effectValue} Schaden zu${bonusDescriptor}.`;
            break;
          case "heal":
            effectText = `Heilt ${effectValue} HP${bonusDescriptor}.`;
            break;
          case "buff_atk":
            effectText = `Erhöht ATK um ${effectValue} für den Kampf${bonusDescriptor}.`;
            break;
          case "debuff_enemy":
            effectText = `Senkt Gegner-ATK um ${effectValue}${bonusDescriptor}.`;
            break;
          default:
            effectText = entry.skill.description || "Aktivierter Skill.";
        }
        const tierDetail = bonusPercent > 0 ? `Tier ${entry.skill.tier} +${bonusPercent}%` : `Tier ${entry.skill.tier}`;
        const detailLabel = `${entry.skill.name} (${tierDetail})`;
        desc.textContent = effectText ? `${detailLabel} - ${effectText}` : detailLabel;
        card.appendChild(desc);
        battleSkillBar.appendChild(card);
      });
    }

    function clearBattleSkills() {
      battleSkillStates = [];
      currentBattleContext = null;
      resetSkillKeyTracking();
      renderBattleSkillBar();
    }

    function activateBattleSkill(entry) {
      if (!battleInProgress || !currentBattleContext) return;
      if (!entry || entry.used) return;
      const { hero, enemy } = currentBattleContext;
      const power = getSkillEffectivePower(entry.skill);
      let resultText = entry.skill.name + " aktiviert.";
      switch (entry.skill.effect) {
        case "damage": {
          applyDamage(enemy, power);
          spawnDamageNumber(battleEnemy, power, "enemy", false);
          updateHpUi(hero, enemy);
          resultText = entry.skill.name + " verursacht " + power + " zusaetzlichen Schaden.";
          break;
        }
        case "heal": {
          const missing = Math.max(0, hero.maxHp - hero.hp);
          const healAmount = Math.min(power, missing);
          hero.hp = Math.min(hero.maxHp, hero.hp + power);
          updateHpUi(hero, enemy);
          if (healAmount > 0) {
            spawnDamageNumber(battleKnight, healAmount, "hero", false, "heal");
          } else {
            spawnStatusText(battleKnight, "HP voll", "buff");
          }
          resultText = entry.skill.name + " heilt " + healAmount + " HP.";
          break;
        }
        case "buff_atk": {
          hero.atk = Math.max(1, hero.atk + power);
          hero.variance = Math.max(1, hero.variance || 1);
          spawnStatusText(battleKnight, "+ATK " + power, "buff");
          resultText = entry.skill.name + " erhoeht deine ATK um " + power + " fuer diesen Kampf.";
          break;
        }
        case "debuff_enemy": {
          const before = enemy.atk;
          enemy.atk = Math.max(1, enemy.atk - power);
          const reduced = before - enemy.atk;
          spawnStatusText(battleEnemy, "-ATK " + reduced, "debuff");
          resultText = entry.skill.name + " senkt die ATK des Gegners um " + reduced + ".";
          break;
        }
        default: {
          spawnStatusText(battleKnight, entry.skill.name, "buff");
          break;
        }
      }
      if (entry.mode === "combo") {
        const usedByOthers = new Set();
        battleSkillStates.forEach(other => {
          if (other !== entry && other.mode === "combo" && other.comboId) {
            usedByOthers.add(other.comboId);
          }
        });
        assignRandomCombo(entry, usedByOthers, entry.comboId);
        entry.used = false;
        resetSkillKeyTracking();
      } else {
        entry.used = true;
      }
      renderBattleSkillBar();
      if (battleResult) battleResult.textContent = resultText;
    }

    function useBattleSkillByLegacyKey(key) {
      const entry = battleSkillStates.find(state => state.mode === "legacy" && state.legacyKey === key && !state.used);
      if (entry) {
        activateBattleSkill(entry);
        return true;
      }
      return false;
    }

    function tryActivateSkillCombos(event) {
      if (!battleSkillStates.length) return false;
      let triggered = false;
      battleSkillStates.forEach(entry => {
        if (entry.mode !== "combo" || entry.used) return;
        if (activeSkillComboLatch.has(entry.comboId)) return;
        if (!setsEqual(activeSkillKeys, entry.comboSet)) return;
        event.preventDefault();
        if (typeof event.stopPropagation === "function") event.stopPropagation();
        if (typeof event.stopImmediatePropagation === "function") event.stopImmediatePropagation();
        activeSkillComboLatch.add(entry.comboId);
        activateBattleSkill(entry);
        triggered = true;
      });
      return triggered;
    }

    function handleBattleKeyDown(event) {
      if (!battleSimulation || battleSimulation.classList.contains("hidden")) return;
      if (!currentBattleContext) return;
      const normalized = normalizeEventKey(event.key);
      if (!normalized) return;
      if (normalized === "ALT") {
        event.preventDefault();
      }
      activeSkillKeys.add(normalized);
      if (event.repeat) return;
      if (normalized.length === 1 && /[0-9]/.test(normalized)) {
        const keyNum = Number(normalized);
        if (keyNum >= 1 && keyNum <= 9 && useBattleSkillByLegacyKey(keyNum)) {
          event.preventDefault();
          return;
        }
      }
      tryActivateSkillCombos(event);
    }

    function handleBattleKeyUp(event) {
      const normalized = normalizeEventKey(event.key);
      if (!normalized) return;
      activeSkillKeys.delete(normalized);
      if (!activeSkillComboLatch.size) return;
      const release = [];
      activeSkillComboLatch.forEach(comboId => {
        const entry = battleSkillStates.find(state => state.mode === "combo" && state.comboId === comboId);
        if (!entry) {
          release.push(comboId);
          return;
        }
        const stillPressed = Array.from(entry.comboSet).every(token => activeSkillKeys.has(token));
        if (!stillPressed) release.push(comboId);
      });
      release.forEach(id => activeSkillComboLatch.delete(id));
    }

    document.addEventListener("keydown", handleBattleKeyDown);
    document.addEventListener("keyup", handleBattleKeyUp);
    window.addEventListener("blur", resetSkillKeyTracking);

    if (battleCloseBtn) {
      battleCloseBtn.addEventListener("click", () => {
        hideBattleSimulation(true);
      });
    }
    if (battleNextBtn) {
      battleNextBtn.addEventListener("click", () => {
        if (battleInProgress) return;
        const targetLevel = Number(battleNextBtn.dataset.targetLevel || "0");
        if (!targetLevel) return;
        startBattle(targetLevel);
      });
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && battleSimulation && !battleSimulation.classList.contains("hidden")) {
        hideBattleSimulation(true);
      }
    });
    async function startBattle(level) {
      if (battleInProgress) return;
      if (level > state.battleUnlocked) return;
      const enemyBlueprint = ENEMIES[level];
      if (!enemyBlueprint) return;
      if (typeof window !== "undefined" && window.scrollTo) {
        window.scrollTo({ top: 0, behavior: "smooth" });
      }
      const hero = createHeroState();
      const enemy = createEnemyState(enemyBlueprint);
      battleInProgress = true;
      prepareBattleSimulation(hero, enemy, level);
      setupBattleSkills(hero, enemy);
      updateHpUi(hero, enemy);
      resetBattleLog("Kampf gegen " + enemy.name + " (Rang " + level + ") gestartet.");
      let heroWon = false;
      try {
        heroWon = await runBattleLoop(hero, enemy);
      } finally {
        battleInProgress = false;
        if (battleCloseBtn) battleCloseBtn.disabled = false;
      }
      finishBattle(hero, enemy, level, heroWon);
    }

    function prepareBattleSimulation(heroState, enemyState, level) {
      if (!battleSimulation) return;
      showBattleSimulation();
      if (battleCloseBtn) battleCloseBtn.disabled = true;
      clearBattleSideState();
      if (battleResult) battleResult.textContent = "Der Kampf beginnt!";
      if (battleNextBtn) {
        battleNextBtn.classList.add("hidden");
        battleNextBtn.removeAttribute("data-target-level");
      }
      const theme = getBattleTheme(Math.max(1, level || enemyState?.level || 1));
      if (battleArena) battleArena.setAttribute("data-battle-theme", theme);
      const enemyName = enemyState && enemyState.name ? enemyState.name : "Gegner";
      if (battleTitle) battleTitle.textContent = "Kampf gegen " + enemyName + " (Rang " + level + ")";
      if (battleEnemyName) battleEnemyName.textContent = enemyName;
      if (enemyHpLabel) enemyHpLabel.textContent = enemyName;
      if (battleKnight) battleKnight.classList.remove("attacking-left", "attacking-right", "hit");
      if (battleEnemy) {
        battleEnemy.classList.remove("attacking-left", "attacking-right", "hit");
        ENEMY_VARIANTS.forEach(variant => battleEnemy.classList.remove(variant));
        if (enemyState && enemyState.variant) battleEnemy.classList.add(enemyState.variant);
      }
      updateBattleSimulationCards(heroState, enemyState, level);
      resetBattleArena();
    }
    function updateBattleSimulationCards(heroState, enemyState, level) {
      if (heroState) {
        if (modalHeroName) modalHeroName.textContent = heroState.name || "Shortcut Knight";
        const heroTier = Math.max(1, state.battleUnlocked || 1);
        if (modalHeroTier) modalHeroTier.textContent = "Rang " + heroTier;
        if (modalHeroTrait) {
          modalHeroTrait.textContent = describeHeroTrait(
            Math.max(0, heroState.atk || 0),
            Math.max(0, heroState.def || 0)
          );
        }
        if (modalHeroAtk) modalHeroAtk.textContent = String(Math.max(0, heroState.atk || 0));
        if (modalHeroDef) modalHeroDef.textContent = String(Math.max(0, heroState.def || 0));
        if (modalHeroHp) modalHeroHp.textContent = String(Math.max(0, heroState.maxHp || heroState.hp || 0));
        if (modalHeroMeta) {
          const gearCount = getEquippedItems().length;
          const critPercent = Math.round(Math.max(0, heroState.crit || 0) * 100);
          const variance = Math.max(0, heroState.variance || 0);
          modalHeroMeta.textContent = `${gearCount}/${EQUIPMENT_SLOT_KEYS.length} Slots • Var ±${variance} • Krit ${critPercent}%`;
        }
      }
      if (enemyState) {
        updateActiveEnemyArt(enemyState);
        if (modalEnemyName) modalEnemyName.textContent = enemyState.name || "Gegner";
        const enemyLevel = Math.max(1, level || enemyState.level || 1);
        if (modalEnemyTier) modalEnemyTier.textContent = "Rang " + enemyLevel;
        if (modalEnemyTrait) modalEnemyTrait.textContent = describeEnemyTrait(enemyState);
        if (modalEnemyAtk) modalEnemyAtk.textContent = String(Math.max(0, enemyState.atk || 0));
        if (modalEnemyDef) modalEnemyDef.textContent = String(Math.max(0, enemyState.def || 0));
        if (modalEnemyHp) modalEnemyHp.textContent = String(Math.max(0, enemyState.maxHp || enemyState.hp || 0));
        if (modalEnemyMeta) {
          const critPercent = Math.round(Math.max(0, enemyState.crit || 0) * 100);
          const variance = Math.max(0, enemyState.variance || 0);
          modalEnemyMeta.textContent = `Var ±${variance} • Krit ${critPercent}%`;
        }
      }
    }

    function showBattleSimulation() {
      if (!battleSimulation) return;
      cancelBattleSimHide();
      battleSimulation.classList.remove("hidden");
    }

    function hideBattleSimulation(force = false) {
      if (!battleSimulation) return;
      if (battleInProgress && !force) return;
      cancelBattleSimHide();
      battleSimulation.classList.add("hidden");
      clearBattleSkills();
    }

    function cancelBattleSimHide() {
      if (!battleSimHideTimer) return;
      clearTimeout(battleSimHideTimer);
      battleSimHideTimer = null;
    }

    function scheduleBattleSimHide() {
      cancelBattleSimHide();
      battleSimHideTimer = setTimeout(() => {
        hideBattleSimulation(true);
      }, 1000);
    }

    function resetBattleArena() {
      if (!battleArena) return;
      battleArena.querySelectorAll(".damage-float").forEach(el => el.remove());
    }

    function createHeroState() {
      const baseHp = getHeroMaxHp();
      return {
        name: "Ritter",
        maxHp: baseHp,
        hp: baseHp,
        atk: Math.max(1, state.atk),
        def: Math.max(0, state.def),
        variance: Math.max(1, Math.floor(Math.max(1, state.atk) / 4)),
        crit: 0.18
      };
    }

    function createEnemyState(blueprint) {
      return {
        name: blueprint.name,
        maxHp: blueprint.hp,
        hp: blueprint.hp,
        atk: blueprint.atk,
        def: blueprint.def,
        variance: blueprint.variance || 1,
        crit: blueprint.crit || 0.1,
        variant: blueprint.variant || "goblin",
        icon: blueprint.icon || getEnemyIconKey(blueprint)
      };
    }

    async function runBattleLoop(hero, enemy) {
      let attacker = hero;
      let defender = enemy;
      let attackerEl = battleKnight;
      let defenderEl = battleEnemy;
      while (hero.hp > 0 && enemy.hp > 0) {
        setActiveBattleSide(attacker === hero);
        const { amount, crit } = calculateDamage(attacker, defender);
        playAttack(attackerEl, defenderEl);
        applyDamage(defender, amount);
        pulseBattleSide(defender === hero);
        spawnDamageNumber(defenderEl, amount, defender === hero ? "hero" : "enemy", crit);
        const attackerName = attacker === hero ? "Ritter" : enemy.name;
        const defenderName = defender === hero ? "Ritter" : enemy.name;
        const critNote = crit ? " (Kritisch!)" : "";
        pushBattleLog(`${attackerName} trifft ${defenderName} für ${amount} Schaden${critNote}.`, attacker === hero ? "hero" : "enemy");
        updateHpUi(hero, enemy);
        await delay(680);
        if (defender.hp <= 0) break;
        [attacker, defender] = attacker === hero ? [enemy, hero] : [hero, enemy];
        [attackerEl, defenderEl] = attackerEl === battleKnight ? [battleEnemy, battleKnight] : [battleKnight, battleEnemy];
        await delay(220);
      }
      clearBattleSideState();
      return enemy.hp <= 0;
    }

    function finishBattle(hero, enemy, level, heroWon) {
      const remainingHeroHp = Math.max(0, Math.round(hero.hp));
      if (heroWon) {
        state.battleClears[level] = true;
        const nextLevel = level + 1;
        let unlockText = "";
        if (ENEMIES[nextLevel]) {
          if (state.battleUnlocked < nextLevel) {
            state.battleUnlocked = nextLevel;
            unlockText = " Naechstes Level freigeschaltet.";
          }
          if (battleNextBtn) {
            battleNextBtn.dataset.targetLevel = String(nextLevel);
            battleNextBtn.textContent = "Rang " + nextLevel + " " + ENEMIES[nextLevel].name + " starten";
            battleNextBtn.classList.remove("hidden");
          }
        } else if (battleNextBtn) {
          battleNextBtn.classList.add("hidden");
          battleNextBtn.removeAttribute("data-target-level");
        }
        if (battleResult) battleResult.textContent = "Sieg! Der Ritter besiegt " + enemy.name + "." + unlockText;
        pushBattleLog("Ritter besiegt " + enemy.name + ". Verbleibende HP: " + remainingHeroHp + ".", "hero");
        if (unlockText) {
          pushBattleLog("Rang " + nextLevel + " freigeschaltet.", "system");
        }
      } else {
        if (battleResult) battleResult.textContent = "Niederlage gegen " + enemy.name + ". Versuche es erneut.";
        pushBattleLog(enemy.name + " besiegt den Ritter. Versuche es erneut.", "enemy");
        if (battleNextBtn) {
          battleNextBtn.classList.add("hidden");
          battleNextBtn.removeAttribute("data-target-level");
        }
      }
      updateBattleButtons();
      currentBattleContext = null;
      renderBattleSkillBar();
      saveState();
      updateBattlePreview();
      scheduleBattleSimHide();
    }

    function updateBattleButtons() {
      if (!battleButtons || !battleButtons.length) return;
      battleButtons.forEach(btn => {
        const base = btn.dataset.label || btn.textContent;
        const level = Number(btn.dataset.enemy || "0");
        if (!level) return;
        const locked = level > state.battleUnlocked;
        const cleared = Boolean(state.battleClears && state.battleClears[level]);
        let label = base;
        if (locked) {
          label += " (gesperrt)";
        } else if (cleared) {
          label += " (gewonnen)";
        }
        btn.textContent = label;
        btn.disabled = locked;
      });
    }

    function updateHpUi(hero, enemy) {
      updateBar(heroHpFill, heroHpValue, hero.hp, hero.maxHp);
      updateBar(enemyHpFill, enemyHpValue, enemy.hp, enemy.maxHp);
    }

    function updateBar(fillEl, valueEl, hp, max) {
      if (!fillEl || !valueEl || !max) return;
      const clampedHp = Math.max(0, Math.round(hp));
      const clampedMax = Math.max(1, Math.round(max));
      const pct = Math.max(0, Math.min(1, clampedHp / clampedMax));
      fillEl.style.width = (pct * 100).toFixed(0) + "%";
      valueEl.textContent = clampedHp + " / " + clampedMax;
    }

    function calculateDamage(attacker, defender) {
      const variance = attacker.variance || 0;
      const spread = variance ? (Math.floor(Math.random() * (variance * 2 + 1)) - variance) : 0;
      let amount = attacker.atk + spread - defender.def;
      let crit = false;
      if (attacker.crit && Math.random() < attacker.crit) {
        crit = true;
        amount = Math.round(amount * 1.5) + 1;
      }
      amount = Math.max(1, amount);
      return { amount, crit };
    }

    function applyDamage(target, amount) {
      target.hp = Math.max(0, target.hp - amount);
    }

    function playAttack(attackerEl, defenderEl) {
      if (!attackerEl || !defenderEl) return;
      const attackClass = attackerEl === battleKnight ? "attacking-left" : "attacking-right";
      attackerEl.classList.remove("attacking-left", "attacking-right");
      defenderEl.classList.remove("hit");
      void attackerEl.offsetWidth;
      void defenderEl.offsetWidth;
      attackerEl.classList.add(attackClass);
      defenderEl.classList.add("hit");
      setTimeout(() => attackerEl.classList.remove("attacking-left", "attacking-right"), 520);
      setTimeout(() => defenderEl.classList.remove("hit"), 420);
    }

    function spawnDamageNumber(targetEl, amount, targetType, crit, effect = "damage") {
      if (!battleArena || !targetEl) return;
      const float = document.createElement("div");
      float.className = "damage-float";
      float.classList.add(targetType === "hero" ? "hero-hit" : "enemy-hit");
      if (effect === "heal") {
        float.classList.add("heal");
        float.textContent = "+" + amount;
      } else if (crit) {
        float.classList.add("crit");
        float.textContent = "-" + amount + "!";
      } else {
        float.textContent = "-" + amount;
      }
      const arenaRect = battleArena.getBoundingClientRect();
      const targetRect = targetEl.getBoundingClientRect();
      const offsetX = (targetRect.left + targetRect.width / 2) - arenaRect.left + (Math.random() * 30 - 15);
      const offsetY = (targetRect.top + targetRect.height / 2) - arenaRect.top - 10 + (Math.random() * 12 - 6);
      float.style.left = `${offsetX}px`;
      float.style.top = `${offsetY}px`;
      battleArena.appendChild(float);
      setTimeout(() => float.remove(), 950);
    }

    function spawnStatusText(targetEl, text, variant = "buff") {
      if (!battleArena || !targetEl) return;
      const float = document.createElement("div");
      float.className = "status-float";
      float.classList.add(variant);
      float.textContent = text;
      const arenaRect = battleArena.getBoundingClientRect();
      const targetRect = targetEl.getBoundingClientRect();
      const offsetX = (targetRect.left + targetRect.width / 2) - arenaRect.left + (Math.random() * 24 - 12);
      const offsetY = (targetRect.top + targetRect.height / 2) - arenaRect.top - 16 + (Math.random() * 10 - 5);
      float.style.left = `${offsetX}px`;
      float.style.top = `${offsetY}px`;
      battleArena.appendChild(float);
      setTimeout(() => float.remove(), 950);
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    ensureSkillInventory();
    ensureKnightInventory();
    renderBattleButtons();
    clearBattleSkills();
    updateBattleButtons();
    recalcStats();
    updateUI();
    updateOverallSummary();
    resetBattleLog("Waehle einen Kampf um die Simulation zu starten.");
  </script>
</body>
</html>

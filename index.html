<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Shortcut Ritter-Akademie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f172a;
      --card: #1d273b;
      --border: rgba(148,163,184,0.25);
      --accent: #f59e0b;
      --accent-soft: rgba(245,158,11,0.18);
      --good: #22c55e;
      --good-soft: rgba(34,197,94,0.15);
      --bad: #f87171;
      --bad-soft: rgba(248,113,113,0.18);
      --text: #e2e8f0;
      --muted: #94a3b8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: rgba(13,22,41,0.85);
      backdrop-filter: blur(8px);
      position: sticky;
      top: 0;
      z-index: 20;
    }
    .title {
      font-weight: 600;
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }
    .header-left { display: flex; align-items: center; gap: 1rem; }
    .top-nav { display: flex; gap: 0.5rem; }
    .nav-toggle {
      padding: 0.35rem 0.9rem;
      border-radius: 0.75rem;
      border: 1px solid transparent;
      background: rgba(148,163,184,0.12);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
    }
    .nav-toggle.active {
      border-color: rgba(245,158,11,0.5);
      background: var(--accent-soft);
    }
    .badge {
      border-radius: 999px;
      padding: 0.3rem 0.8rem;
      border: 1px solid var(--border);
      font-size: 0.78rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: rgba(15,23,42,0.4);
    }
    main {
      flex: 1;
      width: min(1100px, 95%);
      margin: 0.8rem auto 2.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .view { display: none; flex-direction: column; gap: 1rem; }
    .view.active { display: flex; }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.2rem 1.4rem;
      box-shadow: 0 18px 36px rgba(8,15,30,0.35);
    }
    .nav-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .section-tab {
      padding: 0.4rem 0.85rem;
      border-radius: 0.75rem;
      border: 1px solid transparent;
      background: rgba(148,163,184,0.12);
      color: var(--text);
      font-size: 0.82rem;
      cursor: pointer;
    }
    .section-tab.active {
      border-color: rgba(245,158,11,0.45);
      background: var(--accent-soft);
    }
    .section {
      display: none;
      flex-direction: column;
      gap: 1rem;
    }
    .section.active { display: flex; }
    h2 { margin: 0; font-size: 1.2rem; }
    .small { font-size: 0.85rem; color: var(--muted); }
    .task-field {
      display: block;
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 0.75rem;
      padding: 0.65rem 0.75rem;
      margin-top: 0.75rem;
      position: relative;
      background: rgba(15,23,42,0.3);
    }
    .task-field.correct {
      border-color: var(--good);
      background: var(--good-soft);
    }
    .task-field.incorrect {
      border-color: var(--bad);
      background: var(--bad-soft);
    }
    .task-field span.question-text {
      display: block;
      font-weight: 500;
      margin-bottom: 0.4rem;
    }
    select, input[type="text"] {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.45);
      color: var(--text);
      font-size: 0.92rem;
    }
    select:focus, input[type="text"]:focus {
      outline: 2px solid rgba(245,158,11,0.45);
      outline-offset: 2px;
    }
    button {
      font-family: inherit;
      cursor: pointer;
      border-radius: 0.75rem;
      border: none;
      font-weight: 600;
    }
    .action-card {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .action-card button {
      padding: 0.55rem 1.1rem;
      background: var(--accent);
      color: #1f2937;
    }
    .reset-section {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
    }
    .result-text { flex: 1 1 100%; margin: 0; }
    .dnd-pool, .dnd-targets {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-top: 0.9rem;
    }
    .dnd-token {
      padding: 0.3rem 0.7rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(148,163,184,0.15);
      cursor: grab;
      user-select: none;
    }
    .dnd-target {
      padding: 0.6rem;
      border-radius: 0.75rem;
      border: 1px dashed rgba(148,163,184,0.4);
      min-width: 170px;
      background: rgba(15,23,42,0.3);
      position: relative;
    }
    .dnd-target.over {
      border-color: var(--accent);
    }
    .drop-slot {
      margin-top: 0.45rem;
      min-height: 34px;
      border-radius: 0.45rem;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(10,20,40,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
    }
    #overviewCard { margin-top: 0.5rem; }
    .hero-wrapper { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 1rem; }
    .hero-avatar {
      --atk-low: #5b6ff5;
      --atk-mid: #f59e0b;
      --atk-high: #facc15;
      --def-low: #38bdf8;
      --def-mid: #0ea5e9;
      --def-high: #22c55e;
      width: 150px;
      height: 180px;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: linear-gradient(155deg, rgba(26,35,58,0.95), rgba(12,19,34,0.8));
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 0 16px rgba(8,15,30,0.7);
    }
    .hero-svg { width: 120px; height: 160px; }
    .hero-avatar[data-atk-tier="1"] .sword-blade { stroke: var(--atk-low); }
    .hero-avatar[data-atk-tier="2"] .sword-blade { stroke: var(--atk-mid); }
    .hero-avatar[data-atk-tier="3"] .sword-blade { stroke: var(--atk-high); }
    .hero-avatar[data-def-tier="1"] .shield-outline { stroke: var(--def-low); }
    .hero-avatar[data-def-tier="2"] .shield-outline { stroke: var(--def-mid); }
    .hero-avatar[data-def-tier="3"] .shield-outline { stroke: var(--def-high); }
    .hero-avatar.no-gear .sword-group,
    .hero-avatar.no-gear .shield-group,
    .hero-avatar.no-gear .cape-shape {
      opacity: 0;
    }
    .hero-avatar.no-gear .armor-core,
    .hero-avatar.no-gear .leg-piece {
      opacity: 0.35;
      filter: grayscale(0.6);
    }
    .inventory {
      flex: 1 1 240px;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .inventory h3 { margin: 0; font-size: 1rem; }
    .inventory-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .inventory-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.8rem;
      padding: 0.6rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.45);
      transition: border 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }
    .inventory-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(15,23,42,0.4);
    }
    .item-left {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex: 1;
    }
    .item-icon {
      width: 36px;
      height: 36px;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(148,163,184,0.12);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .item-text { display: flex; flex-direction: column; gap: 0.2rem; }
    .item-text strong { font-size: 0.85rem; }
    .item-text span { font-size: 0.75rem; color: var(--muted); }
    .item-meta { font-size: 0.75rem; color: rgba(226,232,240,0.85); }
    .item-stats { display: flex; gap: 0.4rem; }
    .item-controls {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }
    .item-upgrade {
      padding: 0.4rem 0.8rem;
      border-radius: 0.65rem;
      border: 1px solid rgba(248,250,252,0.18);
      background: rgba(248,250,252,0.08);
      color: var(--text);
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
    }
    .item-upgrade:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 26px rgba(59,130,246,0.25);
      border-color: rgba(59,130,246,0.55);
    }
    .item-upgrade:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      border-color: rgba(148,163,184,0.25);
    }
    .inventory-item.tier-1 {
      border-color: rgba(148,163,184,0.35);
      background: linear-gradient(135deg, rgba(148,163,184,0.18), rgba(15,23,42,0.55));
    }
    .inventory-item.tier-2 {
      border-color: rgba(74,222,128,0.55);
      background: linear-gradient(135deg, rgba(34,197,94,0.28), rgba(15,23,42,0.55));
    }
    .inventory-item.tier-3 {
      border-color: rgba(37,99,235,0.66);
      background: linear-gradient(135deg, rgba(37,99,235,0.28), rgba(15,23,42,0.58));
    }
    .inventory-item.tier-4 {
      border-color: rgba(192,132,252,0.65);
      background: linear-gradient(135deg, rgba(168,85,247,0.3), rgba(15,23,42,0.6));
    }
    .inventory-item.tier-5 {
      border-color: rgba(251,191,36,0.75);
      background: linear-gradient(135deg, rgba(251,191,36,0.32), rgba(15,23,42,0.62));
      box-shadow: 0 14px 38px rgba(251,191,36,0.28);
    }
    .inventory-item.tier-5 .item-upgrade {
      display: none;
    }
    .inventory-item.tier-1 .item-icon { border-color: rgba(148,163,184,0.55); background: rgba(148,163,184,0.18); }
    .inventory-item.tier-2 .item-icon { border-color: rgba(34,197,94,0.65); background: rgba(34,197,94,0.22); }
    .inventory-item.tier-3 .item-icon { border-color: rgba(37,99,235,0.7); background: rgba(37,99,235,0.24); }
    .inventory-item.tier-4 .item-icon { border-color: rgba(192,132,252,0.75); background: rgba(192,132,252,0.25); }
    .inventory-item.tier-5 .item-icon { border-color: rgba(251,191,36,0.8); background: rgba(251,191,36,0.3); }
    .badge.atk { background: rgba(248,113,113,0.2); border: 1px solid rgba(248,113,113,0.45); color: #fecaca; }
    .badge.def { background: rgba(96,165,250,0.2); border: 1px solid rgba(96,165,250,0.45); color: #bfdbfe; }
    .inventory-empty { font-size: 0.8rem; color: var(--muted); }
    .game-grid { display: flex; flex-wrap: wrap; gap: 1rem; }
    .game-grid .card { flex: 1 1 280px; }
    .statline { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    #gachaBtn {
      padding: 0.6rem 1.2rem;
      background: var(--accent);
      color: #1f2937;
    }
    .battle-card { position: relative; }
    .battle-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-top: 0.85rem;
    }
    .battle-btn {
      flex: 1 1 150px;
      padding: 0.6rem 1rem;
      background: rgba(245,158,11,0.18);
      border: 1px solid rgba(245,158,11,0.45);
      color: var(--text);
      transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
    }
    .battle-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 22px rgba(245,158,11,0.22);
      border-color: rgba(245,158,11,0.7);
    }
    .battle-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
      border-color: rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.35);
    }
    .gacha-msg { min-height: 1.2rem; font-size: 0.85rem; color: var(--muted); margin-top: 0.5rem; }
    .gacha-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .gacha-option {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.5rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.35);
      cursor: pointer;
      font-size: 0.85rem;
      color: var(--text);
      transition: border 0.2s ease, background 0.2s ease, transform 0.2s ease;
    }
    .gacha-option input { display: none; }
    .gacha-option.active {
      border-color: rgba(245,158,11,0.6);
      background: rgba(245,158,11,0.18);
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(245,158,11,0.15);
    }
    .battle-log {
      margin-top: 0.75rem;
      background: rgba(15,23,42,0.4);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 0.75rem;
      font-size: 0.85rem;
      color: var(--muted);
      min-height: 4.5rem;
      white-space: pre-wrap;
    }
    .shop-latest {
      margin-top: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .shop-latest h3 {
      margin: 0;
      font-size: 0.95rem;
    }
    .shop-latest-empty {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .battle-modal {
      position: fixed;
      inset: 0;
      background: rgba(5,10,22,0.78);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 90;
    }
    .battle-modal.active { display: flex; }
    .battle-window {
      width: min(520px, 95%);
      background: rgba(15,23,42,0.96);
      border: 1px solid var(--border);
      border-radius: 1rem;
      box-shadow: 0 22px 60px rgba(8,15,30,0.65);
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .battle-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }
    .battle-header h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .battle-close {
      background: transparent;
      border: 1px solid rgba(148,163,184,0.35);
      color: var(--muted);
      width: 34px;
      height: 34px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-size: 1rem;
    }
    .battle-close:hover {
      color: var(--text);
      border-color: rgba(245,158,11,0.6);
    }
    .battle-arena {
      position: relative;
      height: 220px;
      background: radial-gradient(circle at 50% 20%, rgba(248,250,252,0.09), transparent 65%);
      border: 1px solid rgba(148,163,184,0.25);
      border-radius: 0.9rem;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      padding: 1.5rem 2rem;
      overflow: hidden;
    }
    .battle-arena::after {
      content: "";
      position: absolute;
      inset: auto 0 0;
      height: 80px;
      background: linear-gradient(180deg, rgba(30,41,59,0.2), rgba(15,23,42,0.85));
    }
    .fighter {
      position: relative;
      width: 92px;
      height: 92px;
      border-radius: 0.6rem;
      background: rgba(30,41,59,0.8);
      border: 2px solid rgba(148,163,184,0.45);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 0.4rem;
      overflow: visible;
    }
    .fighter::before {
      content: "";
      position: absolute;
      width: 56px;
      height: 56px;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      image-rendering: pixelated;
    }
    .fighter::after {
      content: "";
      position: absolute;
      width: 32px;
      height: 12px;
      top: 34px;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 4px;
    }
    .fighter.knight::before {
      background: linear-gradient(180deg, #9ca3af 0%, #64748b 65%, #334155 100%);
      border-radius: 6px;
      box-shadow:
        0 -16px 0 0 #cbd5f5 inset,
        0 -30px 0 0 #475569 inset;
    }
    .fighter.knight::after {
      background: linear-gradient(90deg, #0f172a 0 24%, #38bdf8 24% 76%, #0f172a 76% 100%);
      box-shadow: 0 6px 0 0 #1f2937;
    }
    .fighter.enemy::before {
      background: linear-gradient(180deg, #047857 0%, #065f46 58%, #064e3b 100%);
      border-radius: 6px;
      box-shadow:
        0 -14px 0 0 #34d399 inset,
        0 -28px 0 0 #0f766e inset;
    }
    .fighter.enemy::after {
      background: linear-gradient(90deg, #111827 0 30%, #bef264 30% 70%, #111827 70% 100%);
      border-radius: 3px;
      box-shadow:
        -12px 0 0 -4px rgba(255,255,255,0.08),
        12px 0 0 -4px rgba(255,255,255,0.08);
    }
    .fighter.enemy.goblin-army::before {
      background: linear-gradient(180deg, #059669 0%, #047857 55%, #065f46 100%);
      box-shadow:
        0 -14px 0 0 #6ee7b7 inset,
        0 -28px 0 0 #047857 inset;
    }
    .fighter.enemy.goblin-king::before {
      background: linear-gradient(180deg, #d97706 0 18%, #10b981 18% 62%, #047857 62% 100%);
      box-shadow:
        0 -18px 0 0 #fcd34d inset,
        0 -34px 0 0 #047857 inset;
    }
    .fighter-name {
      position: absolute;
      bottom: -1.6rem;
      font-size: 0.78rem;
      letter-spacing: 0.02em;
      color: var(--muted);
    }
    .fighter.attacking-left { animation: attackLeft 0.5s ease-out; }
    .fighter.attacking-right { animation: attackRight 0.5s ease-out; }
    .fighter.hit { animation: hitFlash 0.42s ease-out; }
    .battle-bars {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }
    .hp-row {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.85rem;
    }
    .hp-track {
      flex: 1;
      height: 12px;
      border-radius: 999px;
      background: rgba(15,23,42,0.6);
      border: 1px solid rgba(148,163,184,0.35);
      overflow: hidden;
    }
    .hp-fill {
      height: 100%;
      width: 100%;
      transition: width 0.25s ease;
    }
    .hp-fill.hero {
      background: linear-gradient(90deg, #38bdf8, #0ea5e9);
    }
    .hp-fill.enemy {
      background: linear-gradient(90deg, #f97316, #ef4444);
    }
    .hp-value {
      width: 74px;
      text-align: right;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }
    .battle-foot {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .battle-result {
      margin: 0;
      min-height: 1.4rem;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .battle-next {
      align-self: flex-end;
      padding: 0.55rem 1.1rem;
      background: var(--accent);
      color: #1f2937;
      border-radius: 0.75rem;
      border: none;
      font-weight: 600;
      box-shadow: 0 12px 28px rgba(245,158,11,0.28);
    }
    .battle-next.hidden { display: none; }
    .damage-float {
      position: absolute;
      left: 50%;
      top: 45%;
      transform: translate(-50%, -10px);
      font-size: 1.1rem;
      font-weight: 700;
      color: #f87171;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
      animation: damageFloat 1s ease-out forwards;
      pointer-events: none;
      white-space: nowrap;
    }
    .damage-float.hero-hit {
      color: #38bdf8;
    }
    .damage-float.enemy-hit {
      color: #f87171;
    }
    .damage-float.crit {
      color: #fde68a;
      text-shadow: 0 0 12px rgba(250,204,21,0.9);
    }
    @keyframes damageFloat {
      0% {
        opacity: 0;
        transform: translate(-50%, -10px) scale(0.85);
      }
      15% {
        opacity: 1;
        transform: translate(-50%, -24px) scale(1.05);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -80px) scale(1.1);
      }
    }
    @keyframes attackLeft {
      0% { transform: translateX(0); }
      40% { transform: translateX(60px); }
      60% { transform: translateX(60px); }
      100% { transform: translateX(0); }
    }
    @keyframes attackRight {
      0% { transform: translateX(0); }
      40% { transform: translateX(-60px); }
      60% { transform: translateX(-60px); }
      100% { transform: translateX(0); }
    }
    @keyframes hitFlash {
      0% { filter: brightness(1); transform: translateY(0); }
      25% { filter: brightness(1.8); transform: translateY(-6px); }
      100% { filter: brightness(1); transform: translateY(0); }
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #coinAnimationLayer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 120;
    }
    .coin-celebration {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      transform: translate(-50%, -50%);
      animation: coinCelebrationRise 2.95s ease-out forwards;
    }
    .coin-main {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,241,179,0.95), rgba(245,158,11,0.95) 55%, rgba(161,98,7,0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 32px rgba(245,158,11,0.8), 0 0 70px rgba(245,158,11,0.4);
      border: 3px solid rgba(255,248,220,0.4);
      animation: coinMainPulse 2.81s ease-out forwards;
      position: relative;
      overflow: hidden;
    }
    .coin-main::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(255,255,255,0.6), rgba(255,255,255,0));
      mix-blend-mode: screen;
      transform: translateX(-120%);
      animation: coinShine 2.81s ease-out forwards;
    }
    .coin-symbol {
      font-size: 48px;
      color: #1f2937;
      text-shadow: 0 4px 12px rgba(0,0,0,0.35);
      animation: coinSymbolPop 2.34s ease-out forwards;
    }
    .coin-amount {
      margin-top: 0.6rem;
      font-size: 1.15rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: #fef3c7;
      text-shadow: 0 0 10px rgba(245,158,11,0.8);
      animation: coinAmountRise 2.73s ease-out forwards;
    }
    .coin-spark {
      --targetX: 0px;
      --targetY: -120px;
      position: absolute;
      width: 34px;
      height: 34px;
      left: 50%;
      top: 45%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fef3c7, #f59e0b);
      border: 2px solid rgba(255,255,255,0.55);
      box-shadow: 0 0 16px rgba(245,158,11,0.6);
      opacity: 0;
      animation: coinSparkFly 2.34s ease-out forwards;
    }
    .coin-spark::after {
      content: "💰";
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #1f2937;
    }
    .coin-badge-boost {
      animation: coinBadgePulse 2.6s ease-out;
    }
    .coin-celebration.loss .coin-main {
      background: radial-gradient(circle at 30% 30%, rgba(254,205,211,0.95), rgba(248,113,113,0.95) 55%, rgba(127,29,29,0.95));
      box-shadow: 0 0 32px rgba(248,113,113,0.8), 0 0 70px rgba(248,113,113,0.35);
      border-color: rgba(254,226,226,0.5);
    }
    .coin-celebration.loss .coin-symbol {
      color: #7f1d1d;
      text-shadow: 0 4px 12px rgba(127,29,29,0.55);
    }
    .coin-celebration.loss .coin-amount {
      color: #fecaca;
      text-shadow: 0 0 12px rgba(248,113,113,0.7);
    }
    .coin-celebration.loss .coin-spark {
      background: radial-gradient(circle at 30% 30%, rgba(254,226,226,1), rgba(248,113,113,0.95));
      border-color: rgba(254,226,226,0.65);
      box-shadow: 0 0 16px rgba(248,113,113,0.6);
    }
    .coin-celebration.loss .coin-spark::after {
      content: "💸";
      color: #7f1d1d;
    }
    .coin-badge-loss {
      animation: coinBadgeLoss 2.6s ease-out;
    }
    @keyframes coinCelebrationRise {
      0% {
        opacity: 0;
        transform: translate(-50%, -20%) scale(0.6);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -60%) scale(1.02);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -120%) scale(0.98);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -160%) scale(0.9);
      }
    }
    @keyframes coinMainPulse {
      0% { transform: scale(0.4) rotate(-12deg); }
      45% { transform: scale(1.1) rotate(6deg); }
      80% { transform: scale(1); }
      100% { transform: scale(0.92); }
    }
    @keyframes coinShine {
      0% { transform: translateX(-120%); }
      50% { transform: translateX(0%); }
      100% { transform: translateX(120%); }
    }
    @keyframes coinSymbolPop {
      0% { opacity: 0; transform: scale(0.4) rotate(-30deg); }
      50% { opacity: 1; transform: scale(1.15) rotate(10deg); }
      100% { opacity: 1; transform: scale(1) rotate(0deg); }
    }
    @keyframes coinAmountRise {
      0% { opacity: 0; transform: translateY(24px); }
      35% { opacity: 1; transform: translateY(-6px); }
      100% { opacity: 0; transform: translateY(-40px); }
    }
    @keyframes coinSparkFly {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
      25% { opacity: 1; }
      100% { opacity: 0; transform: translate(calc(-50% + var(--targetX)), calc(-50% + var(--targetY))) scale(0.15); }
    }
    @keyframes coinBadgePulse {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245,158,11,0.6); }
      35% { transform: scale(1.2); box-shadow: 0 0 32px 10px rgba(245,158,11,0.35); }
      70% { transform: scale(1.05); box-shadow: 0 0 12px 4px rgba(245,158,11,0.2); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245,158,11,0); }
    }
    @keyframes coinBadgeLoss {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(248,113,113,0.55); }
      35% { transform: scale(1.18); box-shadow: 0 0 32px 10px rgba(248,113,113,0.3); }
      70% { transform: scale(0.96); box-shadow: 0 0 12px 4px rgba(248,113,113,0.18); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(248,113,113,0); }
    }
    @media (max-width: 720px) {
      header { flex-direction: column; align-items: flex-start; gap: 0.75rem; }
      .hero-avatar { width: 130px; height: 160px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <span class="title">Shortcut Ritter-Akademie</span>
      <div class="top-nav">
        <button class="nav-toggle active" data-view="learn">Training</button>
        <button class="nav-toggle" data-view="inventory">Inventar</button>
        <button class="nav-toggle" data-view="shop">Shop</button>
        <button class="nav-toggle" data-view="battle">Battle</button>
      </div>
    </div>
    <div class="header-right">
      <span class="badge" id="coinTop">Coins: 0</span>
    </div>
  </header>
  <div id="coinAnimationLayer"></div>
  <main>
    <section id="learnView" class="view active">
      <div class="card nav-card">
        <div class="nav-row">
          <button class="section-tab active" data-goto="1">Abschnitt 1</button>
          <button class="section-tab" data-goto="2">Abschnitt 2</button>
          <button class="section-tab" data-goto="3">Abschnitt 3</button>
          <button class="section-tab" data-goto="4">Abschnitt 4</button>
        </div>
        <p class="small">Perfekte Loesungen bringen 20 Coins. Nach Zuruecksetzen und erneuter Perfektloesung gibt es 5 Coins.</p>
      </div>
      <div class="section active" data-section="1">
        <div class="card">
          <h2>1. Grundschlaege</h2>
          <p class="small">Waehle das passende Tastenkuerzel fuer die Aktion.</p>
          <label class="task-field">
            <span class="question-text">1. Kopieren</span>
            <select data-answer="Ctrl+C">
              <option value=">-- waehlen --</option>
              <option>Ctrl+X</option>
              <option>Ctrl+C</option>
              <option>Ctrl+V</option>
            </select>
          </label>
          <label class="task-field">
            <span class="question-text">2. Einfuegen</span>
            <select data-answer="Ctrl+V">
              <option value=">-- waehlen --</option>
              <option>Ctrl+S</option>
              <option>Ctrl+V</option>
              <option>Ctrl+Z</option>
            </select>
          </label>
          <label class="task-field">
            <span class="question-text">3. Alles markieren</span>
            <select data-answer="Ctrl+A">
              <option value=">-- waehlen --</option>
              <option>Ctrl+P</option>
              <option>Ctrl+A</option>
              <option>Ctrl+F</option>
            </select>
          </label>
        </div>
        <div class="card action-card">
          <button class="check-section" data-check-section="1">Abschnitt pruefen</button>
          <button class="reset-section" data-reset-section="1">Zuruecksetzen</button>
          <p class="small result-text" id="result-1"></p>
        </div>
      </div>
      <div class="section" data-section="2">
        <div class="card">
          <h2>2. Werkzeuge</h2>
          <p class="small">Welches Tastenkuerzel passt zur Beschreibung?</p>
          <label class="task-field">
            <span class="question-text">4. Dokument speichern</span>
            <select data-answer="Ctrl+S">
              <option value=">-- waehlen --</option>
              <option>Ctrl+S</option>
              <option>Ctrl+O</option>
              <option>Ctrl+Shift+S</option>
            </select>
          </label>
          <label class="task-field">
            <span class="question-text">5. Rueckgaengig</span>
            <select data-answer="Ctrl+Z">
              <option value=">-- waehlen --</option>
              <option>Ctrl+Z</option>
              <option>Ctrl+Y</option>
              <option>Ctrl+R</option>
            </select>
          </label>
          <label class="task-field">
            <span class="question-text">6. Im Text suchen</span>
            <select data-answer="Ctrl+F">
              <option value=">-- waehlen --</option>
              <option>Ctrl+F</option>
              <option>Ctrl+P</option>
              <option>Ctrl+Shift+F</option>
            </select>
          </label>
        </div>
        <div class="card action-card">
          <button class="check-section" data-check-section="2">Abschnitt pruefen</button>
          <button class="reset-section" data-reset-section="2">Zuruecksetzen</button>
          <p class="small result-text" id="result-2"></p>
        </div>
      </div>
      <div class="section" data-section="3">
        <div class="card">
          <h2>3. Selber tippen</h2>
          <p class="small">Schreibe das Tastenkuerzel exakt in das Feld.</p>
          <label class="task-field">
            <span class="question-text">7. Drucken</span>
            <input type="text" placeholder="z. B. Ctrl+P" data-answer="Ctrl+P">
          </label>
          <label class="task-field">
            <span class="question-text">8. Wiederholen</span>
            <input type="text" placeholder="z. B. Ctrl+Y" data-answer="Ctrl+Y">
          </label>
          <label class="task-field">
            <span class="question-text">9. Neuer Tab</span>
            <input type="text" placeholder="z. B. Ctrl+N" data-answer="Ctrl+N">
          </label>
        </div>
        <div class="card action-card">
          <button class="check-section" data-check-section="3">Abschnitt pruefen</button>
          <button class="reset-section" data-reset-section="3">Zuruecksetzen</button>
          <p class="small result-text" id="result-3"></p>
        </div>
      </div>
      <div class="section" data-section="4">
        <div class="card">
          <h2>4. Drag und Drop</h2>
          <p class="small">Ziehe jedes Tastenkuerzel auf die passende Beschreibung.</p>
          <div class="dnd-pool">
            <div class="dnd-token" draggable="true" data-value="Ctrl+C">Ctrl+C</div>
            <div class="dnd-token" draggable="true" data-value="Ctrl+V">Ctrl+V</div>
            <div class="dnd-token" draggable="true" data-value="Ctrl+X">Ctrl+X</div>
            <div class="dnd-token" draggable="true" data-value="Ctrl+F">Ctrl+F</div>
            <div class="dnd-token" draggable="true" data-value="Ctrl+S">Ctrl+S</div>
          </div>
          <div class="dnd-targets">
            <div class="dnd-target" data-answer="Ctrl+C">
              <span class="question-text">Markiertes kopieren</span>
              <div class="drop-slot"></div>
            </div>
            <div class="dnd-target" data-answer="Ctrl+V">
              <span class="question-text">Markiertes einfuegen</span>
              <div class="drop-slot"></div>
            </div>
            <div class="dnd-target" data-answer="Ctrl+X">
              <span class="question-text">Markiertes ausschneiden</span>
              <div class="drop-slot"></div>
            </div>
            <div class="dnd-target" data-answer="Ctrl+F">
              <span class="question-text">Inhalt durchsuchen</span>
              <div class="drop-slot"></div>
            </div>
            <div class="dnd-target" data-answer="Ctrl+S">
              <span class="question-text">Datei speichern</span>
              <div class="drop-slot"></div>
            </div>
          </div>
        </div>
        <div class="card action-card">
          <button class="check-section" data-check-section="4">Abschnitt pruefen</button>
          <button class="reset-section" data-reset-section="4">Zuruecksetzen</button>
          <p class="small result-text" id="result-4"></p>
        </div>
      </div>
      <div class="card" id="overviewCard">
        <h2>Gesamtuebersicht</h2>
        <p class="small" id="overallSummary">Noch keine Ergebnisse.</p>
      </div>
    </section>
    <section id="inventoryView" class="view">
      <div class="game-grid">
        <div class="card" id="playerCard">
          <h2>Inventar</h2>
        <div class="statline">
          <span class="badge" id="coinDisplay">Coins: 0</span>
          <span class="badge" id="atkDisplay">ATK 1</span>
          <span class="badge" id="defDisplay">DEF 0</span>
          <span class="badge" id="itemsDisplay">Gear: 0</span>
        </div>
        <p class="small" id="progressInfo">Noch kein Kampf bestritten.</p>
        <button id="testAnimationBtn" style="margin-top:0.6rem;padding:0.55rem 1.1rem;background:var(--accent);color:#1f2937;border:none;border-radius:0.7rem;font-weight:600;cursor:pointer;">Animation testen</button>
        <div class="hero-wrapper">
            <div class="hero-avatar" id="heroAvatar" data-atk-tier="1" data-def-tier="1">
              <svg class="hero-svg" viewBox="0 0 120 160" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <defs>
                  <linearGradient id="armorGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" stop-color="#94a3b8"></stop>
                    <stop offset="100%" stop-color="#475569"></stop>
                  </linearGradient>
                  <linearGradient id="capeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#1d4ed8"></stop>
                    <stop offset="100%" stop-color="#0f172a"></stop>
                  </linearGradient>
                </defs>
              <ellipse cx="60" cy="150" rx="32" ry="8" fill="rgba(8,15,30,0.85)"></ellipse>
              <circle class="armor-core head-shell" cx="60" cy="41" r="15" fill="url(#armorGradient)" stroke="#1e293b" stroke-width="2"></circle>
              <rect class="armor-core neck-piece" x="52" y="56" width="16" height="10" rx="4" fill="url(#armorGradient)" stroke="#1e293b" stroke-width="1.6"></rect>
              <rect class="armor-core" x="44" y="62" width="32" height="40" rx="12" fill="url(#armorGradient)" stroke="#1e293b" stroke-width="2"></rect>
              <rect x="51" y="36" width="7" height="7" rx="2" fill="#0f172a"></rect>
              <rect x="62" y="36" width="7" height="7" rx="2" fill="#0f172a"></rect>
              <path d="M49 44 h22" stroke="#0f172a" stroke-width="3" stroke-linecap="round"></path>
              <path d="M60 33 v-6" stroke="#e2e8f0" stroke-width="3" stroke-linecap="round"></path>
              <path class="cape-shape" d="M38 62 q-16 22 0 44" fill="url(#capeGradient)" opacity="0.8"></path>
              <path class="cape-shape" d="M82 62 q16 26 0 48" fill="url(#capeGradient)" opacity="0.5"></path>
              <g class="shield-group" transform="translate(18,72)">
                  <path class="shield-outline" d="M18 0 L36 8 v16 c0 12-18 24-18 24S0 36 0 24V8z" fill="rgba(15,23,42,0.9)" stroke="#38bdf8" stroke-width="2"></path>
                  <path d="M18 4 L32 10 v12 c0 8-14 16-14 16S8 30 8 22V10z" fill="rgba(59,130,246,0.35)"></path>
                </g>
                <g class="sword-group" transform="translate(72,64)">
                  <rect x="12" y="0" width="4" height="44" rx="2" fill="#e2e8f0" class="sword-blade" stroke="#94a3b8" stroke-width="1.5"></rect>
                  <rect x="8" y="38" width="12" height="4" rx="2" fill="#fcd34d"></rect>
                  <rect x="9.5" y="42" width="9" height="6" rx="2" fill="#b45309"></rect>
                  <circle cx="14" cy="44" r="2" fill="#1f2937"></circle>
                </g>
              <g class="leg-group">
                <rect class="leg-piece" x="48" y="96" width="11" height="32" rx="4" fill="url(#armorGradient)" stroke="#1e293b" stroke-width="1.5"></rect>
                <rect class="leg-piece" x="61" y="96" width="11" height="32" rx="4" fill="url(#armorGradient)" stroke="#1e293b" stroke-width="1.5"></rect>
                <rect class="leg-piece" x="46" y="124" width="13" height="8" rx="3" fill="#0f172a"></rect>
                <rect class="leg-piece" x="61" y="124" width="13" height="8" rx="3" fill="#0f172a"></rect>
              </g>
              </svg>
            </div>
            <div class="inventory">
              <h3>Ruestungskammer</h3>
              <div id="inventoryList" class="inventory-list"></div>
              <div id="inventoryEmpty" class="inventory-empty">Ziehe Ausruestung im Gacha, um sie hier zu sehen.</div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section id="shopView" class="view">
      <div class="game-grid">
        <div class="card">
          <h2>Shop</h2>
          <p class="small">Waehle die Kategorie deiner Belohnung, jede Ziehung kostet 20 Coins.</p>
          <div class="gacha-options" role="radiogroup" aria-label="Gacha Kategorie">
            <label class="gacha-option active">
              <input type="radio" name="gachaType" value="weapon" checked>
              <span>Waffe</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="armor">
              <span>Ausruestung</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="accessory">
              <span>Accessoire</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="any">
              <span>Zufall</span>
            </label>
          </div>
          <button id="gachaBtn">Gacha ziehen</button>
          <p class="gacha-msg" id="gachaMsg"></p>
          <div class="shop-latest" id="shopLatest">
            <h3>Neueste Belohnung</h3>
            <p class="shop-latest-empty" id="shopLatestEmpty">Noch keine Belohnung gezogen.</p>
          </div>
        </div>
      </div>
    </section>
    <section id="battleView" class="view">
      <div class="game-grid">
        <div class="card battle-card">
          <h2>Goblin-Scharmuetzel</h2>
          <p class="small">Fordere die Goblins vom Rang 1 (Kobold) bis Rang 11 (Goblinkoenig) heraus. Jeder Sieg schaltet den naechsten Rang frei.</p>
          <div class="battle-buttons" id="battleButtons"></div>
          <pre class="battle-log" id="battleLog">Waehle einen Kampf um die Simulation zu starten.</pre>
        </div>
      </div>
    </section>
  <div class="battle-modal" id="battleModal" aria-hidden="true">
    <div class="battle-window" role="dialog" aria-modal="true" aria-labelledby="battleTitle">
      <div class="battle-header">
        <h3 id="battleTitle">Goblin-Schlacht</h3>
        <button type="button" class="battle-close" id="battleCloseBtn" aria-label="Schliessen">&#x2715;</button>
      </div>
      <div class="battle-arena" id="battleArena">
        <div class="fighter knight" id="battleKnight">
          <div class="fighter-name">Ritter</div>
        </div>
        <div class="fighter enemy goblin" id="battleEnemy">
          <div class="fighter-name" id="battleEnemyName">Goblin</div>
        </div>
      </div>
      <div class="battle-bars">
        <div class="hp-row">
          <span>Ritter</span>
          <div class="hp-track">
            <div class="hp-fill hero" id="heroHpFill"></div>
          </div>
          <span class="hp-value" id="heroHpValue"></span>
        </div>
        <div class="hp-row">
          <span id="enemyHpLabel">Gegner</span>
          <div class="hp-track">
            <div class="hp-fill enemy" id="enemyHpFill"></div>
          </div>
          <span class="hp-value" id="enemyHpValue"></span>
        </div>
      </div>
      <div class="battle-foot">
        <p class="battle-result" id="battleResult"></p>
        <button type="button" class="battle-next hidden" id="battleNextBtn">Naechstes Level starten</button>
      </div>
    </div>
  </div>
  <script>
    const STORAGE_KEY = "shortcutRitter_v1";
    const BASE_ATK = 1;
    const BASE_DEF = 0;
    const MAX_ITEM_TIER = 5;
    const state = {
      coins: 0,
      atk: BASE_ATK,
      def: BASE_DEF,
      items: [],
      sectionClears: {},
      sectionResets: {},
      gachaPreference: "weapon",
      battleUnlocked: 1,
      battleClears: {}
    };
    function loadState() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const saved = JSON.parse(raw);
        Object.assign(state, saved);
        if (!state.gachaPreference) state.gachaPreference = "weapon";
      } catch (err) {
        console.warn("State konnte nicht geladen werden", err);
      }
      if (!Array.isArray(state.items)) state.items = [];
      if (typeof state.sectionClears !== "object" || !state.sectionClears) state.sectionClears = {};
      if (typeof state.sectionResets !== "object" || !state.sectionResets) state.sectionResets = {};
      if (typeof state.battleClears !== "object" || !state.battleClears) state.battleClears = {};
      if (typeof state.battleUnlocked !== "number" || !Number.isFinite(state.battleUnlocked)) {
        state.battleUnlocked = 1;
      } else {
        state.battleUnlocked = Math.max(1, Math.floor(state.battleUnlocked));
      }
    }
    function saveState() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }
    loadState();

    const coinTop = document.getElementById("coinTop");
    const coinDisplay = document.getElementById("coinDisplay");
    const atkDisplay = document.getElementById("atkDisplay");
    const defDisplay = document.getElementById("defDisplay");
    const itemsDisplay = document.getElementById("itemsDisplay");
    const progressInfo = document.getElementById("progressInfo");
    const shopLatest = document.getElementById("shopLatest");
    const shopLatestEmpty = document.getElementById("shopLatestEmpty");
    const heroAvatar = document.getElementById("heroAvatar");
    const inventoryList = document.getElementById("inventoryList");
    const inventoryEmpty = document.getElementById("inventoryEmpty");
    const overallSummary = document.getElementById("overallSummary");
    const coinAnimationLayer = document.getElementById("coinAnimationLayer");
    const gachaBtn = document.getElementById("gachaBtn");
    const gachaMsg = document.getElementById("gachaMsg");
    const gachaTypeInputs = document.querySelectorAll("input[name='gachaType']");
    const battleLog = document.getElementById("battleLog");
    const battleModal = document.getElementById("battleModal");
    const battleTitle = document.getElementById("battleTitle");
    const battleCloseBtn = document.getElementById("battleCloseBtn");
    const battleArena = document.getElementById("battleArena");
    const battleKnight = document.getElementById("battleKnight");
    const battleEnemy = document.getElementById("battleEnemy");
    const battleEnemyName = document.getElementById("battleEnemyName");
    const enemyHpLabel = document.getElementById("enemyHpLabel");
    const heroHpFill = document.getElementById("heroHpFill");
    const enemyHpFill = document.getElementById("enemyHpFill");
    const heroHpValue = document.getElementById("heroHpValue");
    const enemyHpValue = document.getElementById("enemyHpValue");
    const battleResult = document.getElementById("battleResult");
    const battleNextBtn = document.getElementById("battleNextBtn");
    const testAnimationBtn = document.getElementById("testAnimationBtn");
    const battleButtonContainer = document.getElementById("battleButtons");
    let battleButtons = [];
    if (inventoryList) {
      inventoryList.addEventListener("click", event => {
        const btn = event.target.closest(".item-upgrade");
        if (!btn || btn.disabled) return;
        const key = btn.dataset.itemKey;
        if (!key) return;
        triggerItemUpgrade(key);
      });
    }

    const learnView = document.getElementById("learnView");
    const inventoryView = document.getElementById("inventoryView");
    const shopView = document.getElementById("shopView");
    const battleView = document.getElementById("battleView");
    const viewRegistry = {
      learn: learnView,
      inventory: inventoryView,
      shop: shopView,
      battle: battleView
    };
    const navToggles = document.querySelectorAll(".nav-toggle");
    function setActiveView(viewKey) {
      Object.values(viewRegistry).forEach(section => {
        if (section) section.classList.remove("active");
      });
      const targetSection = viewRegistry[viewKey] || learnView;
      if (targetSection) targetSection.classList.add("active");
    }
    function setActiveNav(viewKey) {
      navToggles.forEach(btn => {
        const matches = btn.dataset.view === viewKey;
        btn.classList.toggle("active", matches);
      });
    }
    function activateView(viewKey) {
      setActiveNav(viewKey);
      setActiveView(viewKey);
    }
    navToggles.forEach(btn => {
      btn.addEventListener("click", () => {
        const view = btn.dataset.view;
        activateView(view);
      });
    });
    const defaultNav = Array.from(navToggles).find(btn => btn.classList.contains("active"));
    if (defaultNav) {
      setActiveView(defaultNav.dataset.view);
    } else {
      activateView("learn");
    }

    if (gachaTypeInputs && gachaTypeInputs.length) {
      gachaTypeInputs.forEach(input => {
        input.addEventListener("change", () => {
          if (!input.checked) return;
          state.gachaPreference = input.value;
          updateGachaOptionStyles();
          saveState();
        });
      });
    }

    applyGachaPreference(state.gachaPreference);

    const sections = document.querySelectorAll(".section");
    const sectionTabs = document.querySelectorAll(".section-tab");
    function showSection(id) {
      sections.forEach(sec => {
        sec.classList.toggle("active", sec.dataset.section === String(id));
      });
      sectionTabs.forEach(tab => {
        tab.classList.toggle("active", tab.dataset.goto === String(id));
      });
    }
    sectionTabs.forEach(tab => {
      tab.addEventListener("click", () => {
        showSection(tab.dataset.goto);
      });
    });
    showSection("1");

    const allCheckables = document.querySelectorAll("[data-answer], .dnd-target");
    let draggedValue = "";
    document.querySelectorAll(".dnd-token").forEach(token => {
      token.addEventListener("dragstart", event => {
        draggedValue = token.dataset.value;
        event.dataTransfer.setData("text/plain", draggedValue);
      });
    });
    document.querySelectorAll(".dnd-target").forEach(target => {
      const slot = target.querySelector(".drop-slot");
      slot.addEventListener("dragover", event => {
        event.preventDefault();
        target.classList.add("over");
      });
      slot.addEventListener("dragleave", () => {
        target.classList.remove("over");
      });
      slot.addEventListener("drop", event => {
        event.preventDefault();
        target.classList.remove("over");
        const value = event.dataTransfer.getData("text/plain") || draggedValue;
        if (!value) return;
        slot.textContent = value;
        slot.dataset.value = value;
        target.classList.remove("correct", "incorrect");
        const wrap = target.closest(".task-field");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        updateOverallSummary();
      });
    });

    allCheckables.forEach(el => {
      const wrap = el.closest(".task-field");
      const clear = () => {
        el.classList.remove("correct", "incorrect");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        updateOverallSummary();
      };
      if (el.tagName === "SELECT") {
        el.addEventListener("change", clear);
      } else if (el.tagName === "INPUT") {
        el.addEventListener("input", clear);
      }
    });

    const KNIGHT_POOL = [
      { key: "bronze_sword", name: "Bronzeklinge", atk: 2, def: 0, icon: "sword", description: "Verstaerkt deine Angriffskraft.", theme: "knight", category: "weapon" },

      { key: "stahl_sword", name: "Stahlklinge", atk: 3, def: 0, icon: "sword", description: "Praezise Hiebe fuer schnelle Kombos.", theme: "knight", category: "weapon" },
      { key: "schatten_klinge", name: "Schattenklinge", atk: 2, def: 1, icon: "sword", description: "Leicht und schnell, perfekt fuer Kombos.", theme: "knight", category: "weapon" },
      { key: "eichen_schild", name: "Eichenschild", atk: 0, def: 2, icon: "shield", description: "Blockt Fehler beim Tippen.", theme: "knight", category: "armor" },
      { key: "turm_schild", name: "Turmschild", atk: 0, def: 3, icon: "shield", description: "Massive Deckung fuer schwere Aufgaben.", theme: "knight", category: "armor" },
      { key: "taktik_helm", name: "Taktikhelm", atk: 1, def: 1, icon: "helm", description: "Haelt deinen Fokus auf Shortcuts.", theme: "knight", category: "armor" },
      { key: "falken_cape", name: "Falkencape", atk: 1, def: 0, icon: "cape", description: "Mehr Tempo beim Merken.", theme: "knight", category: "accessory" },
      { key: "runen_amulet", name: "Runen-Amulett", atk: 0, def: 1, icon: "talisman", description: "Leuchtet bei perfekten Antworten.", theme: "knight", category: "accessory" }
    ];
    const KNIGHT_BY_KEY = Object.create(null);
    const KNIGHT_BY_NAME = Object.create(null);
    KNIGHT_POOL.forEach(entry => {
      KNIGHT_BY_KEY[entry.key] = entry;
      KNIGHT_BY_NAME[entry.name] = entry;
    });
    const GACHA_CATEGORY_LABELS = {
      weapon: "Waffe",
      armor: "Ausruestung",
      accessory: "Accessoire",
      any: "Zufall"
    };
    const ITEM_ART = {
      sword: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><rect x="14" y="4" width="4" height="18" rx="2" fill="#e2e8f0" stroke="#94a3b8" stroke-width="1.5"></rect><rect x="10" y="16" width="12" height="3" rx="1.5" fill="#fcd34d"></rect><rect x="11.5" y="19" width="9" height="4" rx="2" fill="#b45309"></rect><circle cx="16" cy="21" r="1.4" fill="#1f2937"></circle></svg>',
      shield: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M16 3 L26 7 v10 c0 9-10 13-10 13S6 26 6 17V7z" fill="rgba(14,165,233,0.25)" stroke="#38bdf8" stroke-width="1.8"></path><path d="M16 6 L23 9 v8 c0 6-7 9-7 9s-7-3-7-9V9z" fill="rgba(14,116,144,0.45)"></path></svg>',
      helm: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M8 18 v-4 c0-6 4-11 8-11s8 5 8 11v4z" fill="#94a3b8" stroke="#1e293b" stroke-width="1.6"></path><rect x="10" y="12" width="12" height="4" rx="1.5" fill="#0f172a"></rect><path d="M16 7 v6" stroke="#e2e8f0" stroke-width="2"></path></svg>',
      cape: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M10 4 q6 4 12 0 l2 20 q-8 4-16 0z" fill="rgba(59,130,246,0.45)" stroke="#2563eb" stroke-width="1.4"></path><circle cx="16" cy="6" r="2.4" fill="#1d4ed8"></circle></svg>',
      talisman: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="9" fill="rgba(254,243,199,0.9)" stroke="#fbbf24" stroke-width="1.6"></circle><path d="M16 8 L18 14 L24 16 L18 18 L16 24 L14 18 L8 16 L14 14 Z" fill="rgba(250,204,21,0.8)" stroke="#92400e" stroke-width="0.8" stroke-linejoin="round"></path><circle cx="16" cy="16" r="2.4" fill="#f97316"></circle></svg>',
      default: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="6" width="14" height="18" rx="3" fill="#475569" stroke="#94a3b8" stroke-width="1.4"></rect><circle cx="16" cy="12" r="3" fill="#e2e8f0"></circle><path d="M12 22 h8" stroke="#e2e8f0" stroke-width="2" stroke-linecap="round"></path></svg>'
    };
    function cloneItem(template) {
      const now = Date.now();
      return {
        id: `${template.key}-${now}-${Math.random().toString(16).slice(2, 6)}`,
        key: template.key,
        name: template.name,
        baseAtk: template.atk,
        baseDef: template.def,
        atk: template.atk,
        def: template.def,
        icon: template.icon,
        description: template.description,
        theme: template.theme || "knight",
        category: template.category || "accessory",
        tier: 1,
        totalCopies: 1,
        createdAt: now,
        lastObtainedAt: now
      };
    }
    function copiesRequiredForTier(tier) {
      if (tier <= 1) return 1;
      return Math.pow(2, tier - 1);
    }
    function maxTierFromCopies(copies) {
      const safeCopies = Math.max(1, Math.floor(copies || 1));
      return Math.min(MAX_ITEM_TIER, Math.floor(Math.log2(safeCopies)) + 1);
    }
    function updateItemDerivedStats(item) {
      if (!item) return item;
      const safeTier = Math.max(1, Math.min(MAX_ITEM_TIER, Math.floor(item.tier || 1)));
      const safeCopies = Math.max(1, Math.floor(item.totalCopies || 1));
      const baseAtk = Number(item.baseAtk ?? item.atk ?? 0);
      const baseDef = Number(item.baseDef ?? item.def ?? 0);
      const maxTier = maxTierFromCopies(safeCopies);
      const tier = Math.min(safeTier, maxTier);
      item.tier = tier;
      item.totalCopies = safeCopies;
      item.baseAtk = baseAtk;
      item.baseDef = baseDef;
      item.atk = baseAtk * tier;
      item.def = baseDef * tier;
      if (!item.createdAt) item.createdAt = Date.now();
      if (!item.lastObtainedAt) item.lastObtainedAt = item.createdAt;
      return item;
    }
    function getNextTierRequirement(item) {
      if (!item) return Infinity;
      if (item.tier >= MAX_ITEM_TIER) return Infinity;
      return copiesRequiredForTier(item.tier + 1);
    }
    function canUpgradeItem(item) {
      if (!item) return false;
      if (item.tier >= MAX_ITEM_TIER) return false;
      const requirement = getNextTierRequirement(item);
      return item.totalCopies >= requirement;
    }
    function upgradeLegacyItem(item, index) {
      const now = Date.now();
      if (!item || typeof item !== "object") {
        return cloneItem(KNIGHT_POOL[index % KNIGHT_POOL.length]);
      }
      const template = item.key ? KNIGHT_BY_KEY[item.key] : (KNIGHT_BY_NAME[item.name] || null);
      const key = (template && template.key) || item.key || `legacy-${index}`;
      const baseAtk = Number(item.baseAtk ?? item.atk ?? (template ? template.atk : 0) ?? 0);
      const baseDef = Number(item.baseDef ?? item.def ?? (template ? template.def : 0) ?? 0);
      const tier = Math.max(1, Math.min(MAX_ITEM_TIER, Number(item.tier || 1)));
      const copiesSource = Number(item.totalCopies || item.copies || 0);
      const totalCopies = copiesSource > 0 ? copiesSource : 1;
      const createdAt = Number(item.createdAt || item.obtainedAt || now);
      const lastObtainedAt = Number(item.lastObtainedAt || item.updatedAt || createdAt);
      const name = item.name || (template ? template.name : `Relikt ${index + 1}`);
      const description = item.description || (template ? template.description : "Umgeschmiedet aus frueheren Belohnungen.");
      const category = item.category || (template ? template.category : "weapon");
      const icon = item.icon || (template ? template.icon : (category === "armor" ? "shield" : category === "accessory" ? "talisman" : "sword"));
      const theme = item.theme || (template ? template.theme : "knight");
      const normalized = {
        id: item.id || `${key}-${createdAt}-${Math.random().toString(16).slice(2, 6)}`,
        key,
        name,
        baseAtk,
        baseDef,
        atk: baseAtk * tier,
        def: baseDef * tier,
        icon,
        description,
        theme,
        category,
        tier,
        totalCopies,
        createdAt,
        lastObtainedAt
      };
      return normalized;
    }
    function ensureKnightInventory() {
      if (!Array.isArray(state.items)) {
        state.items = [];
        return;
      }
      const upgraded = state.items.map((item, index) => upgradeLegacyItem(item, index));
      const merged = new Map();
      upgraded.forEach(item => {
        if (!item) return;
        const key = item.key || item.name || item.id;
        if (!merged.has(key)) {
          merged.set(key, { ...item });
        } else {
          const existing = merged.get(key);
          const existingCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
          const incomingCopies = Math.max(1, Math.floor(item.totalCopies || 1));
          existing.totalCopies = existingCopies + incomingCopies;
          existing.lastObtainedAt = Math.max(
            Number(existing.lastObtainedAt || existing.createdAt || 0),
            Number(item.lastObtainedAt || item.createdAt || Date.now())
          );
          existing.createdAt = Math.min(
            Number(existing.createdAt || existing.lastObtainedAt || Date.now()),
            Number(item.createdAt || item.lastObtainedAt || Date.now())
          );
          existing.tier = Math.max(Number(existing.tier || 1), Number(item.tier || 1));
        }
      });
      state.items = Array.from(merged.values()).map(updateItemDerivedStats);
      sortInventoryByNewest();
    }
    function recalcStats() {
      let atk = BASE_ATK;
      let def = BASE_DEF;
      state.items.forEach(item => {
        if (!item) return;
        updateItemDerivedStats(item);
        atk += Number(item.atk || 0);
        def += Number(item.def || 0);
      });
      state.atk = atk;
      state.def = def;
    }
    function getItemIcon(iconKey) {
      return ITEM_ART[iconKey] || ITEM_ART.default;
    }
    function createInventoryRow(item, options = {}) {
      const { showUpgrade = true } = options;
      if (!item) return null;
      updateItemDerivedStats(item);
      const row = document.createElement("div");
      row.className = `inventory-item tier-${item.tier}`;
      row.dataset.itemKey = item.key || item.name;

      const left = document.createElement("div");
      left.className = "item-left";
      const icon = document.createElement("div");
      icon.className = "item-icon";
      icon.innerHTML = getItemIcon(item.icon);
      const text = document.createElement("div");
      text.className = "item-text";
      const nameEl = document.createElement("strong");
      nameEl.textContent = item.name;
      text.appendChild(nameEl);
      const categoryLabel = GACHA_CATEGORY_LABELS[item.category] || item.category || "";
      const descText = item.description ? item.description : (categoryLabel ? `Kategorie: ${categoryLabel}` : "");
      if (descText) {
        const desc = document.createElement("span");
        desc.textContent = descText;
        text.appendChild(desc);
      }
      const requirement = getNextTierRequirement(item);
      const meta = document.createElement("span");
      meta.className = "item-meta";
      if (item.tier >= MAX_ITEM_TIER) {
        meta.textContent = `Tier ${item.tier} | x${item.totalCopies} | Maximum erreicht`;
      } else {
        const progress = Math.min(item.totalCopies, requirement);
        meta.textContent = `Tier ${item.tier} | x${item.totalCopies} | Fortschritt: ${progress}/${requirement}`;
      }
      text.appendChild(meta);
      left.appendChild(icon);
      left.appendChild(text);
      row.appendChild(left);

      const controls = document.createElement("div");
      controls.className = "item-controls";
      const stats = document.createElement("div");
      stats.className = "item-stats";
      if (Number(item.atk) > 0) {
        const atkBadge = document.createElement("span");
        atkBadge.className = "badge atk";
        atkBadge.textContent = `ATK +${item.atk}`;
        stats.appendChild(atkBadge);
      }
      if (Number(item.def) > 0) {
        const defBadge = document.createElement("span");
        defBadge.className = "badge def";
        defBadge.textContent = `DEF +${item.def}`;
        stats.appendChild(defBadge);
      }
      controls.appendChild(stats);
      if (showUpgrade && item.tier < MAX_ITEM_TIER) {
        const upgradeBtn = document.createElement("button");
        const requirementText = requirement === Infinity ? "—" : requirement;
        upgradeBtn.className = "item-upgrade";
        upgradeBtn.dataset.itemKey = item.key || item.name;
        upgradeBtn.textContent = `Upgrade Tier ${item.tier + 1} (${item.totalCopies}/${requirementText})`;
        upgradeBtn.disabled = !canUpgradeItem(item);
        controls.appendChild(upgradeBtn);
      }
      row.appendChild(controls);
      return row;
    }
    function renderInventory() {
      if (!inventoryList) return;
      inventoryList.innerHTML = "";
      if (!state.items.length) {
        if (inventoryEmpty) inventoryEmpty.style.display = "block";
        return;
      }
      if (inventoryEmpty) inventoryEmpty.style.display = "none";
      const sorted = [...state.items].sort((a, b) => {
        const left = b.lastObtainedAt || b.createdAt || 0;
        const right = a.lastObtainedAt || a.createdAt || 0;
        return left - right;
      });
      sorted.forEach(item => {
        const row = createInventoryRow(item, { showUpgrade: true });
        if (row) inventoryList.appendChild(row);
      });
    }
    function renderShopLatest() {
      if (!shopLatest) return;
      shopLatest.querySelectorAll(".inventory-item").forEach(el => el.remove());
      if (!state.items.length) {
        if (shopLatestEmpty) shopLatestEmpty.style.display = "block";
        return;
      }
      if (shopLatestEmpty) shopLatestEmpty.style.display = "none";
      const sorted = [...state.items].sort((a, b) => {
        const left = b.lastObtainedAt || b.createdAt || 0;
        const right = a.lastObtainedAt || a.createdAt || 0;
        return left - right;
      });
      const newest = sorted[0];
      const row = createInventoryRow(newest, { showUpgrade: false });
      if (row) shopLatest.appendChild(row);
    }
    function sortInventoryByNewest() {
      state.items.sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0));
    }
    function triggerItemUpgrade(key) {
      const item = state.items.find(entry => (entry.key || entry.name) === key);
      if (!item || !canUpgradeItem(item)) return;
      item.tier = Math.min(MAX_ITEM_TIER, item.tier + 1);
      item.lastUpgradeAt = Date.now();
      updateItemDerivedStats(item);
      recalcStats();
      saveState();
      sortInventoryByNewest();
      updateUI(`${item.name} erreicht Tier ${item.tier}.`);
    }
    function addItemToInventory(template) {
      const now = Date.now();
      const key = template.key;
      const existing = state.items.find(entry => entry.key === key);
      if (existing) {
        existing.totalCopies = Math.max(1, Math.floor(existing.totalCopies || 1)) + 1;
        existing.lastObtainedAt = now;
        updateItemDerivedStats(existing);
        sortInventoryByNewest();
        return { item: existing, isNew: false };
      }
      const fresh = cloneItem(template);
      fresh.createdAt = now;
      fresh.lastObtainedAt = now;
      state.items.push(fresh);
      sortInventoryByNewest();
      return { item: fresh, isNew: true };
    }
    function updateGachaOptionStyles() {
      if (!gachaTypeInputs) return;
      gachaTypeInputs.forEach(input => {
        const wrapper = input.closest(".gacha-option");
        if (wrapper) wrapper.classList.toggle("active", input.checked);
      });
    }
    function applyGachaPreference(pref) {
      if (!gachaTypeInputs || !gachaTypeInputs.length) return;
      const target = pref || state.gachaPreference || "weapon";
      let found = false;
      gachaTypeInputs.forEach((input, idx) => {
        const match = input.value === target;
        input.checked = match;
        if (match) found = true;
        if (!found && idx === gachaTypeInputs.length - 1 && !match) {
          input.checked = false;
        }
      });
      if (!found) {
        gachaTypeInputs[0].checked = true;
        state.gachaPreference = gachaTypeInputs[0].value;
      } else {
        state.gachaPreference = target;
      }
      updateGachaOptionStyles();
    }
    function getSelectedGachaType() {
      if (!gachaTypeInputs || !gachaTypeInputs.length) {
        return state.gachaPreference || "weapon";
      }
      const selected = Array.from(gachaTypeInputs).find(input => input.checked);
      return selected ? selected.value : state.gachaPreference || "weapon";
    }
    let displayedCoins = state.coins;
    let pendingCoinAnimation = null;

    function spawnCoinAnimation(amount, anchor, variant = "gain") {
      const anchorEl = anchor || coinTop;
      if (!coinAnimationLayer || !anchorEl) return;
      const isLoss = variant === "loss" || amount < 0;
      const displayAmount = Math.abs(Math.round(amount));
      const rect = anchorEl.getBoundingClientRect();
      const celebration = document.createElement("div");
      celebration.className = `coin-celebration ${isLoss ? "loss" : "gain"}`;
      celebration.style.left = `${rect.left + rect.width / 2}px`;
      celebration.style.top = `${rect.top + rect.height / 2}px`;
      celebration.innerHTML = `
        <div class="coin-main">
          <div class="coin-symbol">${isLoss ? "💸" : "💰"}</div>
        </div>
        <div class="coin-amount">${isLoss ? "-" : "+"}${displayAmount} Coins</div>
      `;
      const sparkCount = isLoss ? 8 : 12;
      for (let i = 0; i < sparkCount; i++) {
        const spark = document.createElement("span");
        spark.className = "coin-spark";
        const angle = (Math.PI * 2 * (i / sparkCount)) + (Math.random() * 0.6 - 0.3);
        const radius = 140 + Math.random() * 45;
        const targetX = Math.cos(angle) * radius;
        const targetY = Math.sin(angle) * radius - 40;
        spark.style.setProperty("--targetX", `${targetX}px`);
        spark.style.setProperty("--targetY", `${targetY}px`);
        spark.style.animationDelay = `${0.12 * i}s`;
        celebration.appendChild(spark);
      }
      coinAnimationLayer.appendChild(celebration);
      setTimeout(() => celebration.remove(), 4000);
      const badgeClass = isLoss ? "coin-badge-loss" : "coin-badge-boost";
      coinTop.classList.add(badgeClass);
      coinTop.addEventListener("animationend", () => {
        coinTop.classList.remove(badgeClass);
      }, { once: true });
    }
    function updateHeroAvatar() {
      if (!heroAvatar) return;
      const atkBonus = Math.max(0, state.atk - BASE_ATK);
      const defBonus = Math.max(0, state.def - BASE_DEF);
      const atkTier = atkBonus >= 5 ? 3 : atkBonus >= 2 ? 2 : 1;
      const defTier = defBonus >= 5 ? 3 : defBonus >= 2 ? 2 : 1;
      const hasGear = state.items.length > 0;
      heroAvatar.setAttribute("data-atk-tier", String(atkTier));
      heroAvatar.setAttribute("data-def-tier", String(defTier));
      heroAvatar.classList.toggle("no-gear", !hasGear);
      heroAvatar.classList.toggle("has-gear", hasGear);
    }
    function updateUI(extraText) {
      const diff = state.coins - displayedCoins;
      if (pendingCoinAnimation) {
        const info = pendingCoinAnimation;
        spawnCoinAnimation(info.amount, info.anchor, info.variant || (info.amount < 0 ? "loss" : "gain"));
        pendingCoinAnimation = null;
      } else if (diff !== 0) {
        spawnCoinAnimation(diff, null, diff < 0 ? "loss" : "gain");
      }
      displayedCoins = state.coins;
      if (coinTop) coinTop.textContent = "Coins: " + state.coins;
      if (coinDisplay) coinDisplay.textContent = "Coins: " + state.coins;
      if (atkDisplay) atkDisplay.textContent = "ATK " + state.atk;
      if (defDisplay) defDisplay.textContent = "DEF " + state.def;
      if (itemsDisplay) {
        const totalCopies = state.items.reduce((sum, item) => sum + Math.max(1, Math.floor(item.totalCopies || 1)), 0);
        itemsDisplay.textContent = "Gear: " + totalCopies + " (Unique: " + state.items.length + ")";
      }
      if (progressInfo) progressInfo.textContent = extraText || "Trainiere weiter fuer mehr Coins!";
      updateHeroAvatar();
      renderInventory();
      renderShopLatest();
    }
    function updateOverallSummary() {
      if (!overallSummary) return;
      const total = allCheckables.length;
      let correctCount = 0;
      allCheckables.forEach(el => {
        if (el.classList.contains("correct")) {
          correctCount += 1;
        }
      });
      const percent = total === 0 ? 0 : Math.round((correctCount / total) * 100);
      overallSummary.textContent = `${correctCount}/${total} Aufgaben aktuell richtig (${percent}%)`;
    }
    function gradeSection(sectionId, triggerBtn) {
      const section = document.querySelector(`.section[data-section="${sectionId}"]`);
      if (!section) return;
      const fields = section.querySelectorAll("[data-answer], .dnd-target");
      let correctCount = 0;
      const total = fields.length;
      fields.forEach(field => {
        const wrap = field.closest(".task-field");
        field.classList.remove("correct", "incorrect");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        const solution = (field.getAttribute("data-answer") || "").trim();
        let userValue = "";
        if (field.classList.contains("dnd-target")) {
          const slot = field.querySelector(".drop-slot");
          userValue = slot ? (slot.dataset.value || slot.textContent || "").trim() : "";
        } else if (field.tagName === "SELECT") {
          userValue = field.value.trim();
        } else if (field.tagName === "INPUT") {
          userValue = field.value.trim();
        }
        let isCorrect = false;
        if (field.tagName === "INPUT") {
          isCorrect = userValue.toUpperCase() === solution.toUpperCase();
        } else {
          isCorrect = userValue === solution;
        }
        if (isCorrect) {
          correctCount += 1;
          field.classList.add("correct");
          if (wrap) wrap.classList.add("correct");
        } else {
          field.classList.add("incorrect");
          if (wrap) wrap.classList.add("incorrect");
        }
      });
      const percent = total === 0 ? 0 : Math.round((correctCount / total) * 100);
      let resultMsg = `${correctCount}/${total} richtig (${percent}%)`;
      let infoMsg = `Abschnitt ${sectionId}: ${resultMsg}`;
      if (correctCount === total) {
        const clears = state.sectionClears[sectionId] || 0;
        const resets = state.sectionResets[sectionId] || 0;
        let reward = 0;
        if (clears === 0) {
          reward = 20;
        } else if (resets > 0) {
          reward = 5;
          state.sectionResets[sectionId] = resets - 1;
        }
        state.sectionClears[sectionId] = clears + 1;
        if (reward > 0) {
          state.coins += reward;
          pendingCoinAnimation = { amount: reward, anchor: triggerBtn || null, variant: "gain" };
          resultMsg += ` | +${reward} Coins`;
          infoMsg += ` | +${reward} Coins`;
        } else if (clears > 0) {
          resultMsg += " | fuer mehr Coins erst zuruecksetzen.";
        }
      } else {
        resultMsg += " | versuche es erneut.";
      }
      const resultEl = document.getElementById(`result-${sectionId}`);
      if (resultEl) resultEl.textContent = resultMsg;
      updateUI(infoMsg);
      updateOverallSummary();
      recalcStats();
      saveState();
    }
    function resetSection(sectionId) {
      const section = document.querySelector(`.section[data-section="${sectionId}"]`);
      if (!section) return;
      const fields = section.querySelectorAll("[data-answer], .dnd-target");
      fields.forEach(field => {
        const wrap = field.closest(".task-field");
        field.classList.remove("correct", "incorrect");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        if (field.tagName === "SELECT") {
          field.value = "";
        } else if (field.tagName === "INPUT") {
          field.value = "";
        } else if (field.classList.contains("dnd-target")) {
          const slot = field.querySelector(".drop-slot");
          if (slot) {
            slot.textContent = "";
            delete slot.dataset.value;
          }
        }
      });
      const resultEl = document.getElementById(`result-${sectionId}`);
      if (resultEl) resultEl.textContent = "Abschnitt wurde zurueckgesetzt.";
      state.sectionResets[sectionId] = (state.sectionResets[sectionId] || 0) + 1;
      updateUI(`Abschnitt ${sectionId} wurde zurueckgesetzt.`);
      updateOverallSummary();
      saveState();
    }
    document.querySelectorAll(".check-section").forEach(btn => {
      btn.addEventListener("click", () => {
        gradeSection(btn.dataset.checkSection, btn);
      });
    });
    document.querySelectorAll(".reset-section").forEach(btn => {
      btn.addEventListener("click", () => {
        resetSection(btn.dataset.resetSection);
      });
    });

    if (testAnimationBtn) {
      testAnimationBtn.addEventListener("click", () => {
        state.coins += 20;
        pendingCoinAnimation = { amount: 20, anchor: testAnimationBtn, variant: "gain" };
        updateUI("Testanimation: +20 Coins");
        saveState();
      });
    }

    function clearLocalProgress() {
      const message = "Lokale Fortschrittsdaten wirklich loeschen? (Taste: Ctrl + Delete)";
      if (confirm(message)) {
        localStorage.removeItem(STORAGE_KEY);
        location.reload();
      }
    }

    document.addEventListener("keydown", (event) => {
      if (event.ctrlKey && (event.key === "Delete" || event.key === "Del")) {
        event.preventDefault();
        clearLocalProgress();
      }
    });

    gachaBtn.addEventListener("click", () => {
      const cost = 20;
      if (state.coins < cost) {
        gachaMsg.textContent = "Nicht genug Coins (20 noetig).";
        return;
      }
      state.coins -= cost;
      const type = getSelectedGachaType();
      state.gachaPreference = type;
      pendingCoinAnimation = { amount: -cost, anchor: gachaBtn, variant: "loss" };
      let pool = KNIGHT_POOL;
      if (type && type !== "any") {
        const filtered = KNIGHT_POOL.filter(item => item.category === type);
        if (filtered.length) pool = filtered;
      }
      const blueprint = pool[Math.floor(Math.random() * pool.length)];
      const { item, isNew } = addItemToInventory(blueprint);
      recalcStats();
      const categoryLabel = GACHA_CATEGORY_LABELS[item.category] || item.category || "Item";
      let message = "";
      if (isNew) {
        message = "Neu: " + item.name + " [" + categoryLabel + "] Tier " + item.tier + " (ATK +" + item.baseAtk + ", DEF +" + item.baseDef + ") -20 Coins";
      } else if (item.tier >= MAX_ITEM_TIER) {
        message = item.name + " erweitert! x" + item.totalCopies + " Kopien | Tier " + item.tier + " (Max) -20 Coins";
      } else {
        const requirement = getNextTierRequirement(item);
        const progress = Math.min(item.totalCopies, requirement);
        message = item.name + " +1 Kopie (Tier " + item.tier + ") | Fortschritt " + progress + "/" + requirement + " fuer Tier " + (item.tier + 1) + " -20 Coins";
      }
      gachaMsg.textContent = message;
      updateUI("Gacha gezogen: " + item.name);
      saveState();
      updateGachaOptionStyles();
    });

    const ENEMY_VARIANTS = ["goblin", "goblin-army", "goblin-king"];
    const ENEMY_DATA = [
      { name: "Kobold", hp: 16, atk: 2, def: 0, variance: 1, crit: 0.06, variant: "goblin" },
      { name: "Gruener Goblin", hp: 20, atk: 3, def: 0, variance: 1, crit: 0.07, variant: "goblin" },
      { name: "Hobgoblin", hp: 24, atk: 4, def: 1, variance: 1, crit: 0.08, variant: "goblin" },
      { name: "Waldgoblin", hp: 26, atk: 4, def: 2, variance: 2, crit: 0.09, variant: "goblin" },
      { name: "Hoehlengoblin", hp: 30, atk: 5, def: 2, variance: 2, crit: 0.1, variant: "goblin" },
      { name: "Bergtroll", hp: 34, atk: 6, def: 2, variance: 2, crit: 0.11, variant: "goblin-army" },
      { name: "Dunkelgoblin", hp: 38, atk: 6, def: 3, variance: 2, crit: 0.12, variant: "goblin-army" },
      { name: "Kriegsgoblin", hp: 42, atk: 7, def: 3, variance: 3, crit: 0.13, variant: "goblin-army" },
      { name: "Schattengoblin", hp: 46, atk: 7, def: 4, variance: 3, crit: 0.14, variant: "goblin-army" },
      { name: "Daemonengoblin", hp: 52, atk: 8, def: 4, variance: 3, crit: 0.15, variant: "goblin-army" },
      { name: "Goblinkoenig", hp: 60, atk: 9, def: 5, variance: 3, crit: 0.18, variant: "goblin-king" }
    ];
    const ENEMIES = {};
    ENEMY_DATA.forEach((enemy, index) => {
      const level = index + 1;
      ENEMIES[level] = { ...enemy, level };
    });
    state.battleUnlocked = Math.min(ENEMY_DATA.length, Math.max(1, Math.floor(state.battleUnlocked || 1)));
    Object.keys(state.battleClears || {}).forEach(key => {
      const level = Number(key);
      if (!level || level > ENEMY_DATA.length) {
        delete state.battleClears[key];
      }
    });
    let battleInProgress = false;
    function renderBattleButtons() {
      if (!battleButtonContainer) return;
      battleButtonContainer.innerHTML = "";
      battleButtons = [];
      ENEMY_DATA.forEach((enemy, index) => {
        const level = index + 1;
        const btn = document.createElement("button");
        btn.className = "battle-btn";
        btn.dataset.enemy = String(level);
        const label = `Rang ${level} ${enemy.name}`;
        btn.dataset.label = label;
        btn.textContent = label;
        btn.addEventListener("click", () => {
          startBattle(level);
        });
        battleButtonContainer.appendChild(btn);
        battleButtons.push(btn);
      });
      updateBattleButtons();
    }

    if (battleCloseBtn) {
      battleCloseBtn.addEventListener("click", () => {
        closeBattleModal();
      });
    }
    if (battleModal) {
      battleModal.addEventListener("click", event => {
        if (event.target === battleModal) {
          closeBattleModal();
        }
      });
    }
    if (battleNextBtn) {
      battleNextBtn.addEventListener("click", () => {
        if (battleInProgress) return;
        const targetLevel = Number(battleNextBtn.dataset.targetLevel || "0");
        if (!targetLevel) return;
        startBattle(targetLevel);
      });
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && battleModal && battleModal.classList.contains("active")) {
        closeBattleModal();
      }
    });

    async function startBattle(level) {
      if (battleInProgress) return;
      if (level > state.battleUnlocked) return;
      const enemyBlueprint = ENEMIES[level];
      if (!enemyBlueprint) return;
      battleInProgress = true;
      prepareBattleModal(enemyBlueprint, level);
      const hero = createHeroState();
      const enemy = createEnemyState(enemyBlueprint);
      updateHpUi(hero, enemy);
      battleLog.textContent = "Kampf gegen " + enemy.name + " (Rang " + level + ") gestartet.";
      let heroWon = false;
      try {
        heroWon = await runBattleLoop(hero, enemy);
      } finally {
        battleInProgress = false;
        if (battleCloseBtn) battleCloseBtn.disabled = false;
      }
      finishBattle(hero, enemy, level, heroWon);
    }

    function prepareBattleModal(enemy, level) {
      if (!battleModal) return;
      openBattleModal();
      battleModal.setAttribute("aria-hidden", "false");
      if (battleCloseBtn) battleCloseBtn.disabled = true;
      if (battleResult) battleResult.textContent = "Der Kampf beginnt!";
      if (battleNextBtn) {
        battleNextBtn.classList.add("hidden");
        battleNextBtn.removeAttribute("data-target-level");
      }
      if (battleTitle) battleTitle.textContent = "Kampf gegen " + enemy.name + " (Rang " + level + ")";
      if (battleEnemyName) battleEnemyName.textContent = enemy.name;
      if (enemyHpLabel) enemyHpLabel.textContent = enemy.name;
      if (battleKnight) battleKnight.classList.remove("attacking-left", "attacking-right", "hit");
      if (battleEnemy) {
        battleEnemy.classList.remove("attacking-left", "attacking-right", "hit");
        ENEMY_VARIANTS.forEach(variant => battleEnemy.classList.remove(variant));
        if (enemy.variant) battleEnemy.classList.add(enemy.variant);
      }
      resetBattleArena();
    }

    function openBattleModal() {
      if (!battleModal) return;
      battleModal.classList.add("active");
    }

    function closeBattleModal() {
      if (!battleModal) return;
      if (battleInProgress) return;
      battleModal.classList.remove("active");
      battleModal.setAttribute("aria-hidden", "true");
    }

    function resetBattleArena() {
      if (!battleArena) return;
      battleArena.querySelectorAll(".damage-float").forEach(el => el.remove());
    }

    function createHeroState() {
      const baseHp = 28 + (Math.max(0, state.def) * 6);
      return {
        name: "Ritter",
        maxHp: baseHp,
        hp: baseHp,
        atk: Math.max(1, state.atk),
        def: Math.max(0, state.def),
        variance: Math.max(1, Math.floor(Math.max(1, state.atk) / 4)),
        crit: 0.18
      };
    }

    function createEnemyState(blueprint) {
      return {
        name: blueprint.name,
        maxHp: blueprint.hp,
        hp: blueprint.hp,
        atk: blueprint.atk,
        def: blueprint.def,
        variance: blueprint.variance || 1,
        crit: blueprint.crit || 0.1,
        variant: blueprint.variant || "goblin"
      };
    }

    async function runBattleLoop(hero, enemy) {
      let attacker = hero;
      let defender = enemy;
      let attackerEl = battleKnight;
      let defenderEl = battleEnemy;
      while (hero.hp > 0 && enemy.hp > 0) {
        const { amount, crit } = calculateDamage(attacker, defender);
        playAttack(attackerEl, defenderEl);
        applyDamage(defender, amount);
        spawnDamageNumber(defenderEl, amount, defender === hero ? "hero" : "enemy", crit);
        updateHpUi(hero, enemy);
        await delay(680);
        if (defender.hp <= 0) break;
        [attacker, defender] = attacker === hero ? [enemy, hero] : [hero, enemy];
        [attackerEl, defenderEl] = attackerEl === battleKnight ? [battleEnemy, battleKnight] : [battleKnight, battleEnemy];
        await delay(220);
      }
      return enemy.hp <= 0;
    }

    function finishBattle(hero, enemy, level, heroWon) {
      const remainingHeroHp = Math.max(0, Math.round(hero.hp));
      if (heroWon) {
        state.battleClears[level] = true;
        const nextLevel = level + 1;
        let unlockText = "";
        if (ENEMIES[nextLevel]) {
          if (state.battleUnlocked < nextLevel) {
            state.battleUnlocked = nextLevel;
            unlockText = " Naechstes Level freigeschaltet.";
          }
          if (battleNextBtn) {
            battleNextBtn.dataset.targetLevel = String(nextLevel);
            battleNextBtn.textContent = "Rang " + nextLevel + " " + ENEMIES[nextLevel].name + " starten";
            battleNextBtn.classList.remove("hidden");
          }
        } else if (battleNextBtn) {
          battleNextBtn.classList.add("hidden");
          battleNextBtn.removeAttribute("data-target-level");
        }
        if (battleResult) battleResult.textContent = "Sieg! Der Ritter besiegt " + enemy.name + "." + unlockText;
        battleLog.textContent = "Sieg gegen " + enemy.name + " (Rang " + level + "). Verbleibende HP: " + remainingHeroHp + ".";
      } else {
        if (battleResult) battleResult.textContent = "Niederlage gegen " + enemy.name + ". Versuche es erneut.";
        battleLog.textContent = "Niederlage gegen " + enemy.name + " (Rang " + level + ").";
        if (battleNextBtn) {
          battleNextBtn.classList.add("hidden");
          battleNextBtn.removeAttribute("data-target-level");
        }
      }
      updateBattleButtons();
      saveState();
    }

    function updateBattleButtons() {
      if (!battleButtons || !battleButtons.length) return;
      battleButtons.forEach(btn => {
        const base = btn.dataset.label || btn.textContent;
        const level = Number(btn.dataset.enemy || "0");
        if (!level) return;
        const locked = level > state.battleUnlocked;
        const cleared = Boolean(state.battleClears && state.battleClears[level]);
        let label = base;
        if (locked) {
          label += " (gesperrt)";
        } else if (cleared) {
          label += " (gewonnen)";
        }
        btn.textContent = label;
        btn.disabled = locked;
      });
    }

    function updateHpUi(hero, enemy) {
      updateBar(heroHpFill, heroHpValue, hero.hp, hero.maxHp);
      updateBar(enemyHpFill, enemyHpValue, enemy.hp, enemy.maxHp);
    }

    function updateBar(fillEl, valueEl, hp, max) {
      if (!fillEl || !valueEl || !max) return;
      const clampedHp = Math.max(0, Math.round(hp));
      const clampedMax = Math.max(1, Math.round(max));
      const pct = Math.max(0, Math.min(1, clampedHp / clampedMax));
      fillEl.style.width = (pct * 100).toFixed(0) + "%";
      valueEl.textContent = clampedHp + " / " + clampedMax;
    }

    function calculateDamage(attacker, defender) {
      const variance = attacker.variance || 0;
      const spread = variance ? (Math.floor(Math.random() * (variance * 2 + 1)) - variance) : 0;
      let amount = attacker.atk + spread - defender.def;
      let crit = false;
      if (attacker.crit && Math.random() < attacker.crit) {
        crit = true;
        amount = Math.round(amount * 1.5) + 1;
      }
      amount = Math.max(1, amount);
      return { amount, crit };
    }

    function applyDamage(target, amount) {
      target.hp = Math.max(0, target.hp - amount);
    }

    function playAttack(attackerEl, defenderEl) {
      if (!attackerEl || !defenderEl) return;
      const attackClass = attackerEl === battleKnight ? "attacking-left" : "attacking-right";
      attackerEl.classList.remove("attacking-left", "attacking-right");
      defenderEl.classList.remove("hit");
      void attackerEl.offsetWidth;
      void defenderEl.offsetWidth;
      attackerEl.classList.add(attackClass);
      defenderEl.classList.add("hit");
      setTimeout(() => attackerEl.classList.remove("attacking-left", "attacking-right"), 520);
      setTimeout(() => defenderEl.classList.remove("hit"), 420);
    }

    function spawnDamageNumber(targetEl, amount, targetType, crit) {
      if (!battleArena || !targetEl) return;
      const float = document.createElement("div");
      float.className = "damage-float";
      float.classList.add(targetType === "hero" ? "hero-hit" : "enemy-hit");
      if (crit) {
        float.classList.add("crit");
        float.textContent = "-" + amount + "!";
      } else {
        float.textContent = "-" + amount;
      }
      const arenaRect = battleArena.getBoundingClientRect();
      const targetRect = targetEl.getBoundingClientRect();
      const offsetX = (targetRect.left + targetRect.width / 2) - arenaRect.left + (Math.random() * 30 - 15);
      const offsetY = (targetRect.top + targetRect.height / 2) - arenaRect.top - 10 + (Math.random() * 12 - 6);
      float.style.left = `${offsetX}px`;
      float.style.top = `${offsetY}px`;
      battleArena.appendChild(float);
      setTimeout(() => float.remove(), 950);
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    ensureKnightInventory();
    renderBattleButtons();
    updateBattleButtons();
    recalcStats();
    updateUI();
    updateOverallSummary();
    battleLog.textContent = "Waehle einen Kampf um die Simulation zu starten.";
  </script>
</body>
</html>

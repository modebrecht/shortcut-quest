<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Shortcut Ritter-Akademie - v1.2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f172a;
      --card: #1d273b;
      --border: rgba(148,163,184,0.25);
      --accent: #f59e0b;
      --accent-soft: rgba(245,158,11,0.18);
      --good: #22c55e;
      --good-soft: rgba(34,197,94,0.15);
      --bad: #f87171;
      --bad-soft: rgba(248,113,113,0.18);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --slot-row-height: 200px;
      --icon-visual-size: 116px;
      --inventory-icon-frame: 96px;
      --memory-card-size: clamp(8rem, 12vw, 11rem);
      --memory-card-radius: 18px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: rgba(13,22,41,0.85);
      backdrop-filter: blur(8px);
      position: sticky;
      top: 0;
      z-index: 20;
    }
    .title {
      font-weight: 600;
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }
    .header-left { display: flex; align-items: center; gap: 1rem; }
    .header-right { display: flex; align-items: center; gap: 0.6rem; }
    .top-nav { display: flex; gap: 0.5rem; }
    .mobile-nav-toggle {
      display: none;
      align-items: center;
      padding: 0.35rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(148,163,184,0.16);
      color: var(--text);
      font-size: 0.85rem;
    }
    .nav-toggle {
      padding: 0.35rem 0.9rem;
      border-radius: 0.75rem;
      border: 1px solid transparent;
      background: rgba(148,163,184,0.12);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
    }
    .nav-toggle.active {
      border-color: rgba(245,158,11,0.5);
      background: var(--accent-soft);
    }
    .emoji {
      font-size: 1.1em;
      line-height: 1;
      display: inline-block;
      margin-right: 0.2em;
    }
    .report-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .report-tabs {
      display: flex;
      gap: 0.5rem;
      margin: 0;
      align-items: stretch;
    }
    .report-tabs button {
      flex: 1;
      padding: 0.9rem 1.2rem;
      min-height: 3.2rem;
      border-radius: 0.9rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.45);
      color: var(--text);
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
    }
    .report-tabs button.active {
      background: rgba(59,130,246,0.3);
      border-color: rgba(59,130,246,0.6);
    }
    .report-card {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }
    .report-header {
      position: relative;
      padding: 1.2rem 1.4rem;
      border-radius: 1rem;
      background: linear-gradient(135deg, rgba(37,99,235,0.4), rgba(14,165,233,0.18));
      border: 1px solid rgba(37,99,235,0.5);
      overflow: hidden;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem 1.25rem;
      align-items: flex-start;
      isolation: isolate;
      box-shadow: inset 0 0 25px rgba(13,23,42,0.6);
    }
    .report-header::after {
      content: "";
      position: absolute;
      top: -45%;
      right: -20%;
      width: 320px;
      height: 320px;
      background: radial-gradient(circle, rgba(14,165,233,0.4), transparent 65%);
      opacity: 0.7;
      pointer-events: none;
      z-index: 0;
    }
    .report-header-info {
      flex: 1;
      min-width: 220px;
      z-index: 1;
    }
    .report-header-info h2 {
      margin: 0.15rem 0 0.25rem;
      font-size: 1.45rem;
    }
    .report-meta {
      margin: 0;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .report-header-actions {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: flex-end;
      z-index: 1;
      min-width: 220px;
    }
    .report-secondary-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      justify-content: flex-end;
    }
    .report-action {
      padding: 0.65rem 1.25rem;
      border-radius: 0.9rem;
      border: 1px solid transparent;
      background: rgba(15,23,42,0.6);
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .report-action:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(2,6,23,0.4);
    }
    .report-action.primary {
      background: rgba(234,179,8,0.3);
      border-color: rgba(234,179,8,0.65);
    }
    .report-action.ghost {
      border-color: rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.55);
    }
    .report-action.danger {
      border-color: rgba(248,113,113,0.7);
      background: rgba(190,24,93,0.25);
      color: #fecaca;
    }
    @media (max-width: 700px) {
      .report-header {
        flex-direction: column;
        align-items: stretch;
      }
      .report-header-actions {
        width: 100%;
        align-items: stretch;
      }
      .report-secondary-actions {
        justify-content: flex-start;
      }
      .report-action {
        width: 100%;
        text-align: center;
      }
    }
    .report-block {
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 0.95rem;
      padding: 1rem;
      background: linear-gradient(135deg, rgba(14,116,144,0.15), rgba(15,23,42,0.65));
      box-shadow: inset 0 0 0 1px rgba(59,130,246,0.12), 0 10px 24px rgba(2,6,23,0.35);
      position: relative;
      overflow: visible;
    }
    .report-block::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at 15% 20%, rgba(59,130,246,0.25), transparent 45%);
      border-radius: inherit;
      opacity: 0.6;
    }
    .report-block h3 {
      margin: 0 0 0.4rem;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
      position: relative;
      z-index: 1;
    }
    .report-block h3 .report-icon {
      font-size: 1.1em;
    }
    .report-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      background: rgba(15,23,42,0.7);
      border-radius: 999px;
      padding: 0.2rem 0.5rem;
      font-size: 0.78rem;
      border: 1px solid rgba(148,163,184,0.3);
    }
    .report-highlights {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.75rem;
    }
    .highlight-card {
      border-radius: 0.75rem;
      padding: 0.75rem;
      background: rgba(15,118,110,0.18);
      border: 1px solid rgba(45,212,191,0.35);
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }
    .highlight-card.bad {
      background: rgba(190,24,93,0.12);
      border-color: rgba(244,63,94,0.35);
    }
    .highlight-label {
      font-size: 0.78rem;
      opacity: 0.85;
    }
    .highlight-value {
      font-size: 1rem;
      font-weight: 700;
    }
    .highlight-value.emphasized {
      font-size: 2rem;
    }
    .report-chart-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 1rem;
    }
    .report-chart-grid > .chart-card:only-child,
    .report-chart-grid > .chart-card:last-child:nth-child(odd) {
      grid-column: 1 / -1;
    }
    @media (max-width: 900px) {
      .report-chart-grid {
        grid-template-columns: 1fr;
      }
    }
    .chart-card {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      min-height: 300px;
    }
    .chart-shell {
      flex: 1;
      min-height: 260px;
    }
    .chart-shell .apexcharts-canvas {
      margin: 0 auto;
    }
    .report-insights {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      font-size: 0.9rem;
    }
    .report-insights li {
      padding: 0.4rem 0.6rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(15,23,42,0.55);
    }
    .apexcharts-tooltip,
    .apexcharts-xaxistooltip,
    .apexcharts-yaxistooltip {
      background: rgba(15,23,42,0.95) !important;
      color: var(--text) !important;
      border: 1px solid rgba(148,163,184,0.35) !important;
      box-shadow: 0 10px 25px rgba(2,6,23,0.55) !important;
      z-index: 30 !important;
      overflow: visible !important;
    }
    .apexcharts-tooltip-title {
      background: rgba(15,23,42,0.8) !important;
      border-bottom: 1px solid rgba(148,163,184,0.25) !important;
      color: var(--text) !important;
    }
    .apexcharts-tooltip-text {
      color: var(--text) !important;
    }
    .report-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin-top: 0.5rem;
      position: relative;
      z-index: 1;
      table-layout: fixed;
    }
    .report-table th,
    .report-table td {
      padding: 0.35rem 0.5rem;
      border-bottom: 1px solid rgba(148,163,184,0.2);
      text-align: left;
      position: relative;
      z-index: 1;
      vertical-align: middle;
      width: auto;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .report-table col.col-40 { width: 40%; }
    .report-table col.col-60 { width: 60%; }
    .report-table col.col-20 { width: 20%; }
    .report-table th {
      font-weight: 600;
      color: var(--text);
    }
    .report-table tbody tr:nth-child(odd) {
      background: rgba(15,23,42,0.35);
    }
    .report-table tbody tr:hover {
      background: rgba(59,130,246,0.12);
    }
    .badge {
      border-radius: 999px;
      padding: 0.3rem 0.8rem;
      border: 1px solid var(--border);
      font-size: 0.78rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: rgba(15,23,42,0.4);
    }
    main {
      flex: 1;
      width: min(1100px, 95%);
      margin: 0.8rem auto 2.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .view { display: none; flex-direction: column; gap: 1rem; }
    .view.active { display: flex; }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.2rem 1.4rem;
      box-shadow: 0 18px 36px rgba(8,15,30,0.35);
    }
    .nav-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .section {
      display: none;
      flex-direction: column;
      gap: 1rem;
    }
    .section.active { display: flex; }
    h2 { margin: 0; font-size: 1.2rem; }
    .small { font-size: 0.85rem; color: var(--muted); }
    .task-field {
      display: block;
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 0.75rem;
      padding: 0.65rem 0.75rem;
      margin-top: 0.75rem;
      position: relative;
      background: rgba(15,23,42,0.3);
    }
    .task-field.correct {
      border-color: var(--good);
      background: var(--good-soft);
    }
    .task-field.incorrect {
      border-color: var(--bad);
      background: var(--bad-soft);
    }
    .task-field span.question-text {
      display: block;
      font-weight: 500;
      margin-bottom: 0.4rem;
    }
    select, input[type="text"] {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.65);
      color: var(--text);
      font-size: 0.92rem;
    }
    select:focus, input[type="text"]:focus {
      outline: 2px solid rgba(245,158,11,0.45);
      outline-offset: 2px;
    }
    select option {
      color: #f8fafc;
      background: #1e293b;
      font-size: 0.95rem;
    }
    .input-with-hint {
      position: relative;
    }
    .input-with-hint input[type="text"] {
      background: transparent;
    }
    .input-with-hint .input-hint-overlay {
      position: absolute;
      top: 50%;
      left: var(--input-hint-offset, 0.6rem);
      transform: translateY(-50%);
      pointer-events: none;
      color: var(--muted);
      font-size: 0.92rem;
      letter-spacing: 0.01em;
      transition: opacity 0.15s ease;
      white-space: pre;
      opacity: 0.85;
    }
    .input-with-hint .input-hint-overlay.hidden {
      opacity: 0;
    }
    .input-with-hint .input-hint-measure {
      position: absolute;
      visibility: hidden;
      pointer-events: none;
      white-space: pre;
      font: inherit;
    }
    button {
      font-family: inherit;
      cursor: pointer;
      border-radius: 0.75rem;
      border: none;
      font-weight: 600;
    }
    @media (max-width: 720px) {
      header {
        flex-wrap: wrap;
        gap: 0.6rem;
        padding: 0.9rem 1rem;
      }
      .header-left {
        width: 100%;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.4rem 1rem;
      }
      .header-right {
        width: 100%;
        justify-content: flex-start;
      }
      .header-right .badge {
        width: 100%;
        justify-content: center;
      }
      .mobile-nav-toggle {
        display: inline-flex;
      }
      .top-nav {
        display: none;
        width: 100%;
        flex-direction: column;
        gap: 0.4rem;
        padding-top: 0.4rem;
        border-top: 1px solid rgba(148,163,184,0.16);
      }
      .top-nav.open {
        display: flex;
      }
      .nav-toggle {
        width: 100%;
        text-align: left;
      }
    }
    .action-card {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
      z-index: 1;
      position: relative;
    }
    .action-card button {
      padding: 1.55rem 1.1rem;
      background: var(--accent);
      color: #1f2937;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .reset-section {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
    }
    .result-text { flex: 1 1 100%; margin: 0; }
    .result-text:empty { display: none; }
    .dnd-pool {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-top: 0.9rem;
    }
    .dnd-targets {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 0.75rem;
      margin-top: 1rem;
    }
    .dnd-token {
      padding: 0.3rem 0.7rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(148,163,184,0.15);
      cursor: grab;
      user-select: none;
    }
    .dnd-target {
      width: 100%;
      padding: 0.6rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148,163,184,0.4);
      min-width: 0;
      background: rgba(15,23,42,0.3);
      position: relative;
      box-sizing: border-box;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .dnd-target.correct {
      border-color: var(--good);
      background: var(--good-soft);
    }
    .dnd-target.incorrect {
      border-color: var(--bad);
      background: var(--bad-soft);
    }
    .dnd-target.over {
      border-color: var(--accent);
    }
    .drop-slot {
      margin-top: 0.45rem;
      min-height: 34px;
      border-radius: 0.45rem;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(10,20,40,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
    }
    .drop-slot.correct {
      border-color: rgba(34,197,94,0.6);
      background: rgba(34,197,94,0.12);
      color: var(--good);
    }
    .drop-slot.incorrect {
      border-color: rgba(248,113,113,0.6);
      background: rgba(248,113,113,0.12);
      color: var(--bad);
    }
    @media (max-width: 900px) {
      .dnd-targets {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .memory-grid {
        grid-template-columns: repeat(2, var(--memory-card-size));
        gap: 0.8rem;
      }
    }
    @media (max-width: 520px) {
      .dnd-targets {
        grid-template-columns: 1fr;
      }
      .memory-grid {
        grid-template-columns: var(--memory-card-size);
        gap: 0.7rem;
      }
    }
    .memory-game {
      margin: 0;
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
    }
    .card--section {
      padding: 0;
      overflow: hidden;
    }
    .card-body {
      padding: 1.2rem 1.4rem 1.4rem;
    }
    .card-header {
      padding: 1rem 1.4rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.9rem;
      background: rgba(15,23,42,0.35);
      border-bottom: 1px solid rgba(148,163,184,0.12);
      transition: background 150ms ease;
    }
    .card-header.completed {
      background: rgba(15,23,42,0.35);
      border-color: rgba(245,158,11,0.35);
      box-shadow: 0 0 0 1px rgba(245,158,11,0.35);
    }
    .card-header-text {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .card-header-text h2,
    .card-header-text h3 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.02em;
    }
    .section-tab {
      padding: 0.4rem 0.85rem;
      border-radius: 0.75rem;
      border: 1px solid transparent;
      background: rgba(148,163,184,0.12);
      color: var(--text);
      font-size: 0.82rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      transition: background 150ms ease, border 150ms ease;
    }
    .section-tab.active {
      border-color: rgba(245,158,11,0.45);
      background: var(--accent-soft);
    }
    .section-tab.completed {
      background: linear-gradient(180deg, var(--accent) 0%, #fbbf24 100%);
      border-color: rgba(210,125,18,0.6);
      color: #1f2937;
    }
    .section-tab-label {
      white-space: nowrap;
    }
    .memory-game h3 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.02em;
    }
    .memory-status {
      margin: 12px 14px 0;
      font-size: 0.95rem;
      color: #1f2937;
      font-weight: 600;
      padding: 0.3rem 0.85rem;
      border-radius: 999px;
      background: var(--accent);
      border: 1px solid rgba(245,158,11,0.65);
      box-shadow: 0 3px 12px rgba(245,158,11,0.25);
    }
    .memory-status + .memory-grid {
      margin-top: 0;
    }
    .memory-grid {
      margin: 0 auto;
      display: grid;
      gap: 0.7rem;
      grid-template-columns: repeat(auto-fill, minmax(var(--memory-card-size), var(--memory-card-size)));
      justify-content: start;
      justify-items: center;
      padding-top: 0;
    }
    .memory-section-card {
      padding: 0;
      position: relative;
      z-index: 0;
    }
    .memory-section-card > h2,
    .memory-section-card > p.small {
      margin: 0;
      padding: 0.5rem 1.2rem 0;
    }
    .memory-section-card > p.small:last-of-type {
      padding-bottom: 0.4rem;
    }
    .memory-section-card .memory-grid {
      margin: 2rem 1REM 1rem 2rem;
      z-index: 0;
    }
    .memory-card {
      padding: 0;
      margin: 0;
      cursor: pointer;
      position: relative;
      width: var(--memory-card-size);
      height: var(--memory-card-size);
      perspective: 900px;
      border: none;
      background: transparent;
      transition: transform 0.25s ease;
    }
    .memory-card:not(.matched):not(.revealed):hover {
      transform: translateY(-4px);
    }
    .memory-card:focus-visible {
      outline: 2px solid rgba(250,204,21,0.85);
      outline-offset: 4px;
    }
    .memory-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: var(--memory-card-radius);
      transform-style: preserve-3d;
      transition: transform 0.65s cubic-bezier(0.25, 0.8, 0.25, 1);
      box-shadow: 0 8px 18px rgba(15,23,42,0.35);
    }
    .memory-card.revealed .memory-card-inner,
    .memory-card.matched .memory-card-inner {
      transform: rotateY(180deg);
    }
    .memory-card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: var(--memory-card-radius);
      display: flex;
      align-items: center;
      justify-content: center;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      padding: 0;
      background: #e5e7eb;
      border: 1px solid rgba(148,163,184,0.35);
      box-sizing: border-box;
    }
    .memory-card-back {
      background: #e5e7eb;
    }
    .memory-card-icon {
      display: block;
      width: 86%;
      height: 86%;
      object-fit: contain;
      pointer-events: none;
    }
    .memory-card-front {
      background: #e5e7eb;
      border: 1px solid rgba(148,163,184,0.35);
      transform: rotateY(180deg);
      color: #1f2937;
      font-size: clamp(0.9rem, 1.4vw, 1.1rem);
      font-weight: 600;
      text-align: center;
      line-height: 1.2;
      width: 100%;
      height: 100%;
      padding: 0.6rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
    }
    .fast-paced {
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 1.2rem;
      padding: 1.6rem;
      margin-top: 1.2rem;
      background: radial-gradient(circle at top, rgba(30,41,59,0.92), rgba(15,23,42,0.9));
      box-shadow: 0 12px 32px rgba(8,15,30,0.5);
      display: flex;
      flex-direction: column;
      gap: 1.15rem;
      align-items: center;
      text-align: center;
    }
    .fast-paced-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 1.4rem;
      width: 100%;
    }
    .fast-paced-timer-wrap {
      display: inline-flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 0;
      width: 130px;
      height: 130px;
      border-radius: 999px;
      border: 2px solid rgba(245,158,11,0.55);
      background: radial-gradient(circle, rgba(245,158,11,0.16), rgba(245,158,11,0.05));
      box-shadow: 0 0 28px rgba(245,158,11,0.22), inset 0 0 16px rgba(245,158,11,0.14);
    }
    .fast-paced-timer {
      font-weight: 700;
      color: var(--accent);
      min-width: 72px;
      text-align: right;
      font-size: 2.4rem;
      letter-spacing: 0.02em;
    }
    .fast-paced-hourglass {
      width: 40px;
      height: 40px;
      stroke: var(--accent);
      stroke-width: 1.6;
      fill: none;
      transform-origin: 50% 50%;
      transition: transform 0.35s ease;
    }
    .fast-paced-hourglass .hourglass-sand {
      fill: rgba(245,158,11,0.75);
      stroke: none;
    }
    .fast-paced-prompt {
      font-size: 1.6rem;
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: linear-gradient(90deg, #f8fafc 0%, #fbbf24 50%, #fef3c7 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-top: 0.2rem;
    }
    .fast-paced-options {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 0.85rem;
      width: 100%;
      max-width: 700px;
    }
    @media (max-width: 980px) {
      .fast-paced-options {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        max-width: 520px;
      }
    }
    @media (max-width: 520px) {
      .fast-paced-options {
        grid-template-columns: repeat(1, minmax(0, 1fr));
      }
    }
    .fast-paced-option {
      border: 1px solid rgba(148,163,184,0.4);
      border-radius: 1rem;
      padding: 0.95rem;
      font-size: 1rem;
      font-weight: 600;
      background: rgba(15,23,42,0.55);
      color: var(--text);
      transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
      box-shadow: inset 0 0 0 0 rgba(245,158,11,0.25);
    }
    .fast-paced-option:hover:not(:disabled) {
      border-color: var(--accent);
      background: rgba(245,158,11,0.18);
      transform: translateY(-3px);
    }
    .fast-paced-option.correct {
      border-color: var(--good);
      background: var(--good-soft);
      color: var(--good);
    }
    .fast-paced-option.incorrect {
      border-color: var(--bad);
      background: var(--bad-soft);
      color: var(--bad);
    }
    .fast-paced-footer {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: center;
      }
    .fast-paced-progress {
      font-weight: 600;
      color: var(--muted);
    }
    .fast-paced-result {
      flex: 1 1 100%;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .fast-paced-start {
      padding: 0.6rem 1.4rem;
      border-radius: 0.8rem;
      border: none;
      background: var(--accent);
      color: #1f2937;
      font-weight: 700;
      box-shadow: 0 10px 20px rgba(245,158,11,0.25);
    }
    .narrative-card {
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 1.4rem;
      padding: 1.8rem;
      margin-top: 1.2rem;
      background: linear-gradient(150deg, rgba(15,23,42,0.85), rgba(30,41,59,0.9));
      box-shadow: 0 20px 30px rgba(8,15,30,0.5);
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      align-items: center;
      text-align: center;
    }
    .narrative-scene {
      max-width: 560px;
    }
    .narrative-prompt {
      font-size: 1.4rem;
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: block;
    }
    .narrative-blanks {
      display: inline-flex;
      align-items: baseline;
      gap: 0.55rem;
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--accent);
      flex-wrap: wrap;
      justify-content: center;
    }
    .narrative-blank {
      min-width: 42px;
      border-bottom: 2.5px solid rgba(248,250,252,0.7);
      text-align: center;
      padding: 0.3rem 0.5rem;
      transition: border-color 0.2s ease, color 0.2s ease;
    }
    .narrative-blank.active {
      border-bottom-color: rgba(245,158,11,0.9);
      color: var(--accent);
    }
    .narrative-blank.correct {
      border-bottom-color: rgba(34,197,94,0.85);
      color: var(--good);
    }
    .narrative-blank.incorrect {
      border-bottom-color: rgba(248,113,113,0.85);
      color: var(--bad);
    }
    .narrative-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: center;
      max-width: 600px;
    }
    .narrative-option {
      padding: 0.55rem 1.2rem;
      border-radius: 1.1rem;
      border: none;
      background: rgba(248,248,255,0.98);
      color: #1f2937;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 14px rgba(15,23,42,0.35);
    }
    .narrative-fly {
      position: fixed;
      padding: 0.5rem 1rem;
      border-radius: 1rem;
      background: rgba(248,248,255,0.95);
      color: #1f2937;
      font-weight: 700;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: left 0.35s ease, top 0.35s ease, transform 0.35s ease, opacity 0.35s ease;
      box-shadow: 0 8px 18px rgba(15,23,42,0.4);
      z-index: 999;
      opacity: 1;
    }
    .combo-builder {
      margin-top: 1.2rem;
      border: 1px dashed var(--border);
      border-radius: 1.25rem;
      padding: 1.25rem;
      background: rgba(15,23,42,0.45);
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .combo-builder h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .combo-rows {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
    }
    .combo-row {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 1rem;
      padding: 0.9rem 1.1rem;
      background: rgba(15,23,42,0.5);
    }
    .combo-prompt {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }
    .combo-title {
      font-weight: 600;
      font-size: 0.95rem;
    }
    .combo-text {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }
    .combo-slots {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.35rem;
    }
    .combo-plus {
      font-weight: 700;
      color: var(--muted);
    }
    .combo-slot select {
      min-width: 90px;
      padding: 0.5rem 0.7rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.35);
      color: var(--text);
      font-weight: 600;
      text-transform: none;
    }
    .combo-slot select.correct {
      border-color: var(--good);
      background: var(--good-soft);
      color: var(--good);
    }
    .combo-slot select.incorrect {
      border-color: var(--bad);
      background: var(--bad-soft);
      color: var(--bad);
    }
    @media (min-width: 720px) {
      .combo-row {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
      .combo-prompt {
        flex: 1 1 45%;
      }
      .combo-slots {
        flex: 1 1 55%;
        justify-content: flex-end;
      }
    }
    #overviewCard { margin-top: 0.5rem; }
    .hero-wrapper {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      margin-top: 1rem;
    }
    .equipment-layout {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      align-items: center;
      width: 100%;
    }
    .hero-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      width: 100%;
      height: 100%;
      min-height: 0;
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.1);
      box-shadow: inset 0 0 16px rgba(8,15,30,0.35);
    }
    .hero-avatar {
      --atk-low: #5b6ff5;
      --atk-mid: #f59e0b;
      --atk-high: #facc15;
      --def-low: #38bdf8;
      --def-mid: #0ea5e9;
      --def-high: #22c55e;
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: none;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.65rem;
      box-shadow: inset 0 0 16px rgba(8,15,30,0.7);
      overflow: hidden;
      position: relative;
    }
    .hero-avatar .hero-illustration {
      width: 100%;
      height: 100%;
      object-fit: contain;
      object-position: center 60%;
      display: block;
      transform-origin: center 70%;
      transition: transform 180ms ease;
    }
    .hero-avatar .hero-illustration.is-knight {
      transform: translateY(-2px) scale(1.22);
    }
    .hero-avatar .hero-illustration.is-blueprint {
      transform: translateY(-4px) scale(1.16);
    }
    .hero-avatar.no-gear {
      background: linear-gradient(165deg, rgba(45,64,124,0.95), rgba(17,24,39,0.88));
    }
    .hero-svg { width: 120px; height: 160px; }
    .hero-avatar[data-atk-tier="1"] .sword-blade { stroke: var(--atk-low); }
    .hero-avatar[data-atk-tier="2"] .sword-blade { stroke: var(--atk-mid); }
    .hero-avatar[data-atk-tier="3"] .sword-blade { stroke: var(--atk-high); }
    .hero-avatar[data-def-tier="1"] .shield-outline { stroke: var(--def-low); }
    .hero-avatar[data-def-tier="2"] .shield-outline { stroke: var(--def-mid); }
    .hero-avatar[data-def-tier="3"] .shield-outline { stroke: var(--def-high); }
    .hero-avatar.no-gear .sword-group,
    .hero-avatar.no-gear .shield-group,
    .hero-avatar.no-gear .cape-shape {
      opacity: 0;
    }
    .hero-avatar.no-gear .armor-core,
    .hero-avatar.no-gear .leg-piece {
      opacity: 0.35;
      filter: grayscale(0.6);
    }
    .slot-row {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-auto-rows: var(--slot-row-height);
      gap: 0.45rem;
      width: 100%;
      align-items: stretch;
    }
    .slot-row.middle-row {
      align-items: stretch;
      justify-items: stretch;
    }
    .slot-row.middle-row .hero-center {
      min-width: 0;
      width: 100%;
      flex: 1 1 0;
    }
    .equipment-slot {
      border: 1px solid var(--border);
      border-radius: 0.9rem;
      padding: 0.65rem 0.8rem 0.55rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      background: rgba(15,23,42,0.5);
      min-height: 0;
      position: relative;
      width: 100%;
      height: 100%;
    }
    .equipment-slot.equipped {
      border-style: solid;
      /*border-color: rgba(245,158,11,0.55);
      box-shadow: 0 12px 28px rgba(245,158,11,0.18);*/
    }
    .equipment-slot.tier-1 {
      border-color: rgba(148,163,184,0.4);
      background: rgba(148,163,184,0.12);
    }
    .equipment-slot.tier-2 {
      border-color: rgba(34,197,94,0.5);
      background: rgba(34,197,94,0.12);
      box-shadow: 0 6px 14px rgba(34,197,94,0.15);
    }
    .equipment-slot.tier-3 {
      border-color: rgba(37,99,235,0.55);
      background: rgba(37,99,235,0.12);
      box-shadow: 0 6px 14px rgba(37,99,235,0.18);
    }
    .equipment-slot.tier-4 {
      border-color: rgba(192,132,252,0.6);
      background: rgba(192,132,252,0.12);
      box-shadow: 0 6px 18px rgba(192,132,252,0.2);
    }
    .equipment-slot.tier-5 {
      border-color: rgba(251,191,36,0.75);
      background: rgba(251,191,36,0.18);
      box-shadow: 0 8px 20px rgba(251,191,36,0.22);
    }
    .equipment-slot.tier-1 .slot-icon { border-color: rgba(148,163,184,0.55); background: rgba(148,163,184,0.18); }
    .equipment-slot.tier-2 .slot-icon { border-color: rgba(34,197,94,0.65); background: rgba(34,197,94,0.22); }
    .equipment-slot.tier-3 .slot-icon { border-color: rgba(37,99,235,0.7); background: rgba(37,99,235,0.24); }
    .equipment-slot.tier-4 .slot-icon { border-color: rgba(192,132,252,0.75); background: rgba(192,132,252,0.25); }
    .equipment-slot.tier-5 .slot-icon { border-color: rgba(251,191,36,0.8); background: rgba(251,191,36,0.3); }
    .slot-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.78rem;
      color: var(--muted);
    }
    .slot-unequip {
      display: none;
    }
    .slot-body {
      display: flex;
      align-items: stretch;
      gap: 0.85rem;
      flex: 1;
      height: 100%;
    }
    .equipment-slot.equipped .slot-body {
      align-items: stretch;
    }
    .slot-icon {
      width: 130px;
      height: 100%;
      border-radius: 0.9rem;
      border: 1px solid rgba(148,163,184,0.35);
      background:
        radial-gradient(120% 120% at 20% 0%, rgba(255,255,255,0.08), transparent),
        rgba(3,8,23,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      gap: 0.4rem;
      padding: 0.45rem;
      position: relative;
      box-shadow: inset 0 0 32px rgba(2,6,23,0.8);
      align-self: stretch;
    }
    .slot-icon::after {
      content: "";
      position: absolute;
      inset: 0.25rem;
      border-radius: 0.7rem;
      border: 1px solid rgba(148,163,184,0.15);
      pointer-events: none;
    }
    .slot-icon img,
    .slot-icon svg,
    .item-icon img,
    .item-icon svg {
      width: var(--icon-visual-size);
      height: var(--icon-visual-size);
      max-width: none;
      max-height: none;
      transform-origin: center center;
      transform: scale(1.4); /* adjust scale factor as desired */
      object-fit: contain;
      display: block;
    }
    /* Allow the larger visual to overflow the small inventory icon box so sizes match visually */
    .slot-icon,
    .item-icon { overflow: visible; 
      box-shadow: inset 0 0 32px rgba(2,6,23,0.8);
    }

    .inventory-stat-badge {
      padding: 0.24rem 0.65rem;
      font-size: 0.72rem;
    }
    .slot-placeholder {
      font-size: 1.1rem;
      color: rgba(148,163,184,0.5);
    }
    .slot-info {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      gap: 0.6rem;
      flex: 1;
      height: 100%;
      min-width: 0;
      padding: 0.15rem 0;
    }
    .slot-stats {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 0;
    }
    @media (max-width: 720px) {
      .slot-row {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        grid-auto-rows: auto;
      }
      .slot-row.middle-row {
        align-items: stretch;
      }
      .slot-row.middle-row .hero-center {
        min-width: 0;
      }
      .slot-row .equipment-slot,
      .slot-row [data-equip-slot="weapon"],
      .slot-row [data-equip-slot="offhand"] {
        width: 100%;
        flex: 1 1 auto;
        height: auto;
      }
      .equipment-slot.tall {
        min-height: 140px;
      }
    }
    .inventory {
      flex: 1 1 240px;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .inventory-actions {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: wrap;
      margin-left: auto;
    }
    .inventory-filter-bar {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
      padding: 0.4rem 0.1rem;
    }
    .inventory-filter-buttons {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.6rem;
      flex: 1 1 auto;
    }
    .inventory-filter-btn {
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.3);
      background: rgba(148,163,184,0.12);
      color: var(--text);
      font-size: 0.8rem;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease, color 0.15s ease;
    }
    .inventory-filter-btn.active {
      border-color: rgba(245,158,11,0.65);
      background: var(--accent-soft);
      color: var(--accent);
    }
    .primary-btn {
      padding: 0.55rem 1.1rem;
      background: var(--accent);
      color: #1f2937;
      border: none;
      border-radius: 0.7rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .primary-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(245,158,11,0.25);
    }
    .primary-btn.secondary {
      background: rgba(148,163,184,0.18);
      color: var(--text);
      border: 1px solid rgba(148,163,184,0.35);
    }
    .primary-btn.secondary:hover {
      box-shadow: 0 10px 22px rgba(148,163,184,0.18);
      border-color: rgba(245,158,11,0.5);
    }
    .inventory h3 { margin: 0; font-size: 1rem; }
    .inventory-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .inventory-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.8rem;
      padding: 0.6rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.45);
      transition: border 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }
    .inventory-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(15,23,42,0.4);
    }
    .item-left {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex: 1 1 55%;
      min-width: 260px;
    }
    .item-icon {
      width: var(--inventory-icon-frame);
      height: var(--inventory-icon-frame);
      padding: 0.35rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(148,163,184,0.35);
      background:
        radial-gradient(120% 120% at 20% 0%, rgba(255,255,255,0.08), transparent),
        rgba(3,8,23,0.88);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      flex-shrink: 0;
    }
    .item-icon::after {
      content: "";
      position: absolute;
      inset: 0.25rem;
      border-radius: 0.65rem;
      border: 1px solid rgba(148,163,184,0.2);
      pointer-events: none;
    }
    .item-icon img,
    .item-icon svg {
      width: calc(var(--inventory-icon-frame) - 18px);
      height: calc(var(--inventory-icon-frame) - 18px);
      max-width: 100%;
      max-height: 100%;
      display: block;
      transform: none;
    }
    .item-text { display: flex; flex-direction: column; gap: 0.2rem; }
    .item-text strong { font-size: 0.85rem; }
    .item-text span { font-size: 0.75rem; color: var(--muted); }
    .item-meta { font-size: 0.75rem; color: rgba(226,232,240,0.85); }
    .item-stats {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      margin-right: auto;
    }
    .item-controls {
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      gap: 0.6rem;
      flex: 1 1 45%;
      flex-wrap: wrap;
      min-width: 220px;
    }
    @media (max-width: 640px) {
      .inventory-item {
        flex-direction: column;
        align-items: flex-start;
      }
      .inventory-item .item-left,
      .inventory-item .item-controls {
        flex: 1 1 100%;
        min-width: 0;
        width: 100%;
      }
      .inventory-item .item-controls {
        justify-content: flex-start;
      }
    }
    .item-equip {
      padding: 0.4rem 0.9rem;
      border-radius: 0.65rem;
      border: 1px solid rgba(245,158,11,0.5);
      background: rgba(245,158,11,0.15);
      color: var(--text);
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }
    .item-equip:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(245,158,11,0.2);
    }
    .item-equip.equipped {
      background: rgba(245,158,11,0.15);
      color: var(--text);
    }
    .item-equip:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .item-upgrade {
      padding: 0.4rem 0.8rem;
      border-radius: 0.65rem;
      border: 1px solid rgba(248,250,252,0.18);
      background: rgba(248,250,252,0.08);
      color: var(--text);
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
    }
    .item-upgrade.tier-2 { border-color: rgba(34,197,94,0.55); background: rgba(34,197,94,0.18); color: #f8fafc; }
    .item-upgrade.tier-3 { border-color: rgba(37,99,235,0.6); background: rgba(37,99,235,0.2); color: #f8fafc; }
    .item-upgrade.tier-4 { border-color: rgba(192,132,252,0.65); background: rgba(192,132,252,0.2); color: #f8fafc; }
    .item-upgrade.tier-5 { border-color: rgba(251,191,36,0.75); background: rgba(251,191,36,0.25); color: #fff; }
    .item-upgrade.tier-6 { border-color: rgba(248,113,113,0.85); background: rgba(248,113,113,0.3); color: #fff5f5; box-shadow: 0 0 22px rgba(248,113,113,0.35); }
    .item-upgrade:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 26px rgba(59,130,246,0.25);
      border-color: rgba(59,130,246,0.55);
    }
    .item-upgrade:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      border-color: rgba(148,163,184,0.25);
    }
    .skill-bonus-indicator {
      flex: 1 1 220px;
      min-width: 180px;
      padding: 0.55rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(250,204,21,0.35);
      background: rgba(250,204,21,0.08);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      position: relative;
      transition: border 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
      cursor: default;
      user-select: none;
    }
    .skill-bonus-indicator[data-item-upgrade="true"][data-item-upgrade-ready="true"],
    .skill-bonus-indicator[data-skill-upgrade="true"][data-item-upgrade-ready="true"],
    .skill-bonus-indicator[data-item-upgrade="true"][data-item-upgrade-ready="true"] *,
    .skill-bonus-indicator[data-skill-upgrade="true"][data-skill-upgrade-ready="true"] {
      cursor: pointer;
    }
    .skill-bonus-indicator::after {
      content: "";
      position: absolute;
      inset: 0.15rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(250,204,21,0.12);
      pointer-events: none;
    }
    .skill-bonus-indicator .skill-bonus-title {
      font-size: 0.75rem;
      letter-spacing: 0.02em;
      color: rgba(248,250,252,0.85);
    }
    .skill-bonus-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.55rem;
    }
    .skill-bonus-progress {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.55);
      overflow: hidden;
      border: 1px solid rgba(250,204,21,0.3);
    }
    .skill-bonus-progress-fill {
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, rgba(250,204,21,0.9), rgba(250,204,21,0.45));
      width: 0%;
      transition: width 0.35s ease, background-position 1.2s linear;
      background-size: 200% 100%;
      animation: skillBonusStripe 4.5s linear infinite;
    }
    @keyframes skillBonusStripe {
      0% { background-position: 0% 0; }
      100% { background-position: -200% 0; }
    }
    .skill-bonus-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.72rem;
      color: rgba(248,250,252,0.8);
    }
    .skill-bonus-meta span + span {
      margin-left: 0.4rem;
    }
    .skill-bonus-progress-label {
      margin-left: auto;
      font-variant-numeric: tabular-nums;
      font-size: 0.72rem;
      color: rgba(248,250,252,0.85);
    }
    .skill-bonus-ready {
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(250,204,21,0.6);
      background: rgba(250,204,21,0.15);
      font-size: 0.75rem;
      color: #fff;
    }
    .skill-bonus-indicator[data-skill-bonus-ready="true"],
    .skill-bonus-indicator[data-skill-upgrade-ready="true"] {
      border-color: rgba(250,204,21,0.8);
      box-shadow: 0 12px 28px rgba(250,204,21,0.22);
      cursor: pointer;
    }
    .skill-bonus-indicator[data-skill-bonus-ready="true"] .skill-bonus-progress,
    .skill-bonus-indicator[data-skill-upgrade-ready="true"] .skill-bonus-progress {
      border-color: rgba(250,204,21,0.65);
    }
    .skill-bonus-indicator.tier-1 {
      border-color: rgba(148,163,184,0.4);
      background: rgba(148,163,184,0.12);
    }
    .skill-bonus-indicator.tier-2 {
      border-color: rgba(74,222,128,0.4);
      background: rgba(34,197,94,0.12);
    }
    .skill-bonus-indicator.tier-3 {
      border-color: rgba(37,99,235,0.45);
      background: rgba(37,99,235,0.12);
    }
    .skill-bonus-indicator.tier-4 {
      border-color: rgba(192,132,252,0.45);
      background: rgba(192,132,252,0.12);
    }
    .skill-bonus-indicator.tier-5 {
      border-color: rgba(251,191,36,0.5);
      background: rgba(251,191,36,0.12);
    }
    .skill-bonus-indicator.tier-6 {
      border-color: rgba(248,113,113,0.55);
      background: rgba(248,113,113,0.14);
    }
    .inventory-item[data-skill-key] .item-left {
      flex: 0 0 52%;
      min-width: 280px;
    }
    .inventory-item[data-skill-key] .item-icon {
      flex: 0 0 auto;
    }
    .inventory-item[data-skill-key] .item-text {
      flex: 1 1 auto;
      min-width: 200px;
    }
    .inventory-item[data-skill-key] .item-controls {
      flex: 1 1 48%;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }
    .inventory-item[data-skill-key] .item-stats {
      justify-content: flex-start;
    }
    .inventory-item .skill-bonus-indicator { margin-left: auto; }
    .inventory-list .inventory-item .skill-bonus-indicator {
      flex: 1 1 100%;
      width: 100%;
      margin-left: 0;
    }
    .inventory-item[data-skill-key] .skill-bonus-indicator {
      flex: 1 1 280px;
      max-width: 360px;
    }
    .shop-latest .inventory-item {
      align-items: stretch;
      gap: 0.75rem;
      border-color: rgba(148,163,184,0.35);
      background: linear-gradient(135deg, rgba(148,163,184,0.18), rgba(15,23,42,0.55));
    }
    .shop-latest .inventory-item .item-left {
      flex: 0 0 52%;
      min-width: 240px;
    }
    .shop-latest .inventory-item .item-text {
      flex: 1 1 auto;
      min-width: 180px;
    }
    .shop-latest .inventory-item .item-controls {
      flex: 1 1 48%;
      justify-content: flex-end;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .shop-latest .inventory-item .item-equip {
      display: none;
    }
    .shop-latest .inventory-item .skill-bonus-indicator {
      flex: 1 1 260px;
      max-width: 340px;
    }
    .shop-latest .skill-bonus-ready {
      display: none;
    }
    .inventory-item.tier-1 {
      border-color: rgba(148,163,184,0.35);
      background: linear-gradient(135deg, rgba(148,163,184,0.18), rgba(15,23,42,0.55));
    }
    .inventory-item.tier-2 {
      border-color: rgba(74,222,128,0.55);
      background: linear-gradient(135deg, rgba(34,197,94,0.28), rgba(15,23,42,0.55));
    }
    .inventory-item.tier-3 {
      border-color: rgba(37,99,235,0.66);
      background: linear-gradient(135deg, rgba(37,99,235,0.28), rgba(15,23,42,0.58));
    }
    .inventory-item.tier-4 {
      border-color: rgba(192,132,252,0.65);
      background: linear-gradient(135deg, rgba(168,85,247,0.3), rgba(15,23,42,0.6));
    }
    .inventory-item.tier-5 {
      border-color: rgba(251,191,36,0.75);
      background: linear-gradient(135deg, rgba(251,191,36,0.32), rgba(15,23,42,0.62));
      box-shadow: 0 14px 38px rgba(251,191,36,0.28);
    }
    .inventory-item.tier-6 {
      border-color: rgba(248,113,113,0.85);
      background: linear-gradient(135deg, rgba(248,113,113,0.36), rgba(76,5,25,0.7));
      box-shadow: 0 16px 44px rgba(248,113,113,0.3);
    }
    .inventory-item.tier-1 .item-icon { border-color: rgba(148,163,184,0.55); background: rgba(148,163,184,0.18); }
    .inventory-item.tier-2 .item-icon { border-color: rgba(34,197,94,0.65); background: rgba(34,197,94,0.22); }
    .inventory-item.tier-3 .item-icon { border-color: rgba(37,99,235,0.7); background: rgba(37,99,235,0.24); }
    .inventory-item.tier-4 .item-icon { border-color: rgba(192,132,252,0.75); background: rgba(192,132,252,0.25); }
    .inventory-item.tier-5 .item-icon { border-color: rgba(251,191,36,0.8); background: rgba(251,191,36,0.3); }
    .inventory-item.tier-6 .item-icon { border-color: rgba(248,113,113,0.9); background: rgba(248,113,113,0.35); }
    .badge.atk { background: rgba(248,113,113,0.5); border: 1px solid rgba(248,113,113,0.45); color: #fecaca; }
    .badge.def { background: rgba(96,165,250,0.5); border: 1px solid rgba(96,165,250,0.45); color: #bfdbfe; }
    .game-grid { display: flex; flex-wrap: wrap; gap: 1rem; }
    .game-grid .card { flex: 1 1 280px; }
    .statline { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .statline-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    #gachaBtn {
      padding: 0.6rem 1.2rem;
      background: var(--accent);
      color: #1f2937;
    }
    .battle-card { position: relative; }
    .battle-overview {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: stretch;
    }
    .battle-side {
      flex: 1 1 280px;
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 1rem;
      padding: 1.1rem;
      background: linear-gradient(145deg, rgba(15,23,42,0.92), rgba(15,23,42,0.75));
      box-shadow: inset 0 0 18px rgba(2,6,23,0.5);
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      position: relative;
      overflow: hidden;
    }
    .battle-side.hero {
      border-color: rgba(59,130,246,0.45);
      background: linear-gradient(145deg, rgba(15,23,42,0.95), rgba(30,64,175,0.4));
    }
    .battle-side.enemy {
      border-color: rgba(248,113,113,0.45);
      background: linear-gradient(145deg, rgba(36,12,23,0.95), rgba(153,27,27,0.35));
    }
    .battle-side.attacking {
      box-shadow: 0 18px 38px rgba(248,250,252,0.22);
      border-color: rgba(248,250,252,0.6);
    }
    .battle-side.hit {
      animation: battleHitPulse 0.4s ease;
    }
    @keyframes battleHitPulse {
      0% { transform: translateY(0); box-shadow: 0 0 0 rgba(248,250,252,0); }
      30% { transform: translateY(-2px); box-shadow: 0 12px 26px rgba(248,250,252,0.25); }
      100% { transform: translateY(0); box-shadow: 0 0 0 rgba(248,250,252,0); }
    }
    .battle-side-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
    }
    .battle-side-label {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(248,250,252,0.75);
    }
    .battle-side-head h3 {
      margin: 0.15rem 0 0;
      font-size: 1.1rem;
    }
    .battle-side-tier {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(248,250,252,0.25);
      font-size: 0.75rem;
      color: rgba(248,250,252,0.85);
    }
    .battle-trait {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      border-radius: 999px;
      border: 1px solid rgba(248,250,252,0.25);
      padding: 0.1rem 0.55rem;
      font-size: 0.7rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(248,250,252,0.75);
    }
    .battle-trait::before {
      content: "✧";
      font-size: 0.8rem;
      color: inherit;
    }
    @keyframes portraitFloat {
      0% { transform: translateY(0); }
      45% { transform: translateY(-4px); }
      100% { transform: translateY(0); }
    }
    .battle-portrait {
      width: 190px;
      height: 190px;
      border-radius: 50%;
      border: 1px solid rgba(248,250,252,0.25);
      background: radial-gradient(circle at 40% 30%, rgba(248,250,252,0.2), transparent 60%),
        rgba(15,23,42,0.4);
      margin: 0 auto;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 18px 30px rgba(15,23,42,0.45);
    }
    .battle-portrait.hero {
      border-color: rgba(59,130,246,0.55);
    }
    .battle-portrait.enemy {
      border-color: rgba(248,113,113,0.55);
    }
    .battle-portrait-icon {
      font-size: 2rem;
      color: rgba(248,250,252,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }
    .battle-portrait.enemy .battle-portrait-icon {
      font-size: 2.8rem;
    }
    .battle-portrait-icon img {
      width: 70%;
      height: auto;
      filter: drop-shadow(0 6px 12px rgba(15,23,42,0.6));
      animation: portraitFloat 4.5s ease-in-out infinite;
    }
    .battle-statline {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .battle-stat-badge {
      padding: 0.25rem 0.6rem;
      border-radius: 0.65rem;
      font-size: 0.75rem;
      letter-spacing: 0.03em;
      border: 1px solid rgba(148,163,184,0.35);
      color: rgba(248,250,252,0.9);
    }
    .battle-stat-badge strong {
      margin-left: 0.2rem;
    }
    .battle-side-meta {
      margin: 0;
      font-size: 0.78rem;
      color: rgba(248,250,252,0.75);
    }
    .battle-gear {
      margin-top: 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .battle-gear-label {
      font-size: 0.72rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(248,250,252,0.65);
    }
    .battle-gear-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
    }
    .battle-gear-card {
      border-radius: 0.75rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.4);
      padding: 0.45rem 0.55rem;
      display: flex;
      gap: 0.45rem;
      align-items: center;
      min-height: 80px;
    }
    .battle-gear-card .gear-icon {
      width: 46px;
      height: 46px;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .battle-gear-card .gear-icon img,
    .battle-gear-card .gear-icon svg {
      width: 80%;
      height: 80%;
      object-fit: contain;
    }
    .battle-gear-card .gear-text {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      font-size: 0.74rem;
    }
    .battle-gear-card .gear-text strong {
      font-size: 0.78rem;
      color: rgba(248,250,252,0.95);
    }
    .battle-gear-card .gear-text span {
      color: rgba(226,232,240,0.8);
    }
    .battle-gear-card .gear-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }
    .battle-gear-card .gear-stats .badge {
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
    }
    .battle-gear-empty {
      opacity: 0.65;
      font-style: italic;
      grid-column: 1 / -1;
    }
    .battle-center {
      flex: 1 1 320px;
      min-width: 280px;
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 1rem;
      background: linear-gradient(135deg, rgba(8,47,73,0.9), rgba(15,23,42,0.85));
      box-shadow: inset 0 0 24px rgba(2,6,23,0.55);
      padding: 1.4rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .battle-crest {
      text-align: center;
    }
    .battle-crest-label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: 2px solid rgba(248,250,252,0.35);
      font-size: 1.6rem;
      letter-spacing: 0.1em;
      color: rgba(248,250,252,0.9);
      box-shadow: 0 15px 40px rgba(15,23,42,0.45);
    }
    .battle-crest p {
      margin: 0.7rem 0 0;
      font-size: 0.85rem;
      color: rgba(226,232,240,0.85);
    }
    .battle-center-actions {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }
    .battle-log {
      margin: 0;
    }
    #battleLog {
      display: none;
    }
    @media (max-width: 900px) {
      .battle-side,
      .battle-center {
        flex: 1 1 100%;
      }
      .battle-portrait {
        margin: 0.5rem auto;
      }
      .battle-gear-list {
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      }
    }
    .battle-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }
    .battle-btn {
      flex: 1 1 150px;
      padding: 0.6rem 1rem;
      background: rgba(245,158,11,0.18);
      border: 1px solid rgba(245,158,11,0.45);
      color: var(--text);
      transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
    }
    .battle-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 22px rgba(245,158,11,0.22);
      border-color: rgba(245,158,11,0.7);
    }
    .battle-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
      border-color: rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.35);
    }
    .gacha-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.9rem;
      margin-top: 1rem;
    }
    .gacha-option {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
      padding: 1.2rem 1rem;
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(148,163,184,0.12);
      cursor: pointer;
      color: var(--text);
      transition: all 0.2s ease;
      text-align: center;
      min-height: 150px;
    }
    .gacha-option input { display: none; }
    .gacha-option .gacha-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(15,23,42,0.45);
    }
    .gacha-option .gacha-icon svg {
      width: 40px;
      height: 40px;
      color: var(--accent);
    }
    .gacha-option .gacha-label {
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.01em;
    }
    .gacha-remaining {
      font-size: 0.78rem;
      color: var(--muted);
      letter-spacing: 0.01em;
    }
    .gacha-option.active {
      border-color: rgba(245,158,11,0.6);
      background: rgba(245,158,11,0.18);
      transform: translateY(-2px);
      box-shadow: 0 10px 24px rgba(245,158,11,0.18);
    }
    .shop-buy-btn {
      width: 100%;
      margin-top: 1.2rem;
      padding: 1rem 1.2rem;
      font-size: 1rem;
      border-radius: 1rem;
      background: linear-gradient(135deg, rgba(245,158,11,0.9), rgba(248,196,69,0.95));
      color: #1f2937;
      font-weight: 700;
      border: 1px solid rgba(245,158,11,0.9);
      box-shadow: 0 14px 28px rgba(245,158,11,0.35);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }
    .shop-buy-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 34px rgba(245,158,11,0.4);
    }
    .shop-buy-btn:active {
      transform: translateY(0);
      box-shadow: 0 8px 20px rgba(245,158,11,0.3);
    }
    @media (max-width: 640px) {
      .gacha-options {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .gacha-option {
        min-height: 130px;
        padding: 1rem 0.8rem;
      }
      .gacha-option .gacha-label {
        font-size: 0.9rem;
      }
    }
    .battle-log {
      display: none;
      margin-top: 0;
      background: rgba(8,15,35,0.65);
      border: 1px solid rgba(148,163,184,0.3);
      border-radius: 0.85rem;
      padding: 0.75rem 0.85rem;
      font-size: 0.82rem;
      color: rgba(226,232,240,0.85);
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .battle-entry {
      position: relative;
      padding-left: 1.2rem;
      line-height: 1.35;
    }
    .battle-entry::before {
      content: "";
      position: absolute;
      left: 0.35rem;
      top: 0.55rem;
      width: 0.4rem;
      height: 0.4rem;
      border-radius: 50%;
      border: 2px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
    }
    .battle-entry-hero {
      color: rgba(125,211,252,0.95);
    }
    .battle-entry-hero::before {
      border-color: rgba(59,130,246,0.8);
    }
    .battle-entry-enemy {
      color: rgba(252,165,165,0.95);
    }
    .battle-entry-enemy::before {
      border-color: rgba(248,113,113,0.8);
    }
    .battle-entry-system {
      color: rgba(226,232,240,0.85);
      opacity: 0.85;
    }
    .skill-wrapper {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
      align-items: stretch;
    }
    .skill-avatar {
      --skill-svg-min: 240px;
      --skill-svg-fluid: 28vw;
      --skill-svg-max: 420px;
      min-width: 210px;
      min-height: 252px;
      padding: clamp(0.95rem, 2.2vw, 1.7rem);
      width: fit-content;
      height: fit-content;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: linear-gradient(155deg, rgba(32,27,68,0.95), rgba(15,23,42,0.85));
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: inset 0 0 16px rgba(8,15,30,0.7);
      overflow: hidden;
      align-self: center;
    }
    .skill-avatar::before {
      content: "";
      position: absolute;
      inset: clamp(14px, 2vw, 22px);
      border-radius: 0.85rem;
      background: radial-gradient(circle at 50% 40%, rgba(59,130,246,0.35), rgba(99,102,241,0.2), rgba(15,23,42,0));
      opacity: 0.75;
      filter: blur(0.4px);
    }
    .skill-avatar svg {
      width: clamp(var(--skill-svg-min), var(--skill-svg-fluid), var(--skill-svg-max));
      height: auto;
      display: block;
      position: relative;
      z-index: 1;
      transform: translateY(-4%);
    }
    .skill-svg {
      width: 120px;
      height: 150px;
      position: relative;
      z-index: 1;
    }
    .skill-avatar .spellbook-glow {
      animation: spellbookGlow 6.2s ease-in-out infinite;
      transform-origin: 50% 45%;
    }
    @keyframes spellbookGlow {
      0%, 100% {
        opacity: 0.55;
        transform: scale(0.92);
      }
      45% {
        opacity: 0.98;
        transform: scale(1.07);
      }
    }
    .skill-avatar .spellbook-page {
      stroke: rgba(203,213,225,0.85);
      stroke-width: 1.5;
    }
    .skill-avatar .spellbook-page-turn {
      stroke: rgba(148,163,184,0.55);
      stroke-width: 1.2;
      transform-box: fill-box;
      transform-origin: 55% 55%;
    }
    .skill-avatar .spellbook-bookmark {
      transform-box: fill-box;
      transform-origin: 50% 8%;
      animation: spellbookBookmark 5.8s ease-in-out infinite;
      animation-delay: 0.6s;
    }
    @keyframes spellbookBookmark {
      0%, 100% { transform: rotate(3deg); }
      50% { transform: rotate(-5deg); }
    }
    .skill-avatar .spellbook-rune {
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: 28;
      animation: spellbookRunePulse 7s ease-in-out infinite;
    }
    .skill-avatar .spellbook-rune.rune-2 {
      animation-delay: 1.4s;
    }
    @keyframes spellbookRunePulse {
      0%, 100% {
        stroke-dashoffset: 28;
        opacity: 0.2;
      }
      40% {
        stroke-dashoffset: 12;
        opacity: 0.85;
      }
      65% {
        stroke-dashoffset: 0;
        opacity: 1;
      }
    }
    .skill-avatar .spellbook-sparkle {
      fill: rgba(224,242,254,0.9);
      transform-box: fill-box;
      transform-origin: center;
      animation: spellbookSparkle 6.4s ease-in-out infinite;
    }
    .skill-avatar .spellbook-sparkle.sparkle-2 { animation-delay: 1.8s; }
    .skill-avatar .spellbook-sparkle.sparkle-3 { animation-delay: 3.2s; }
    @keyframes spellbookSparkle {
      0% {
        opacity: 0;
        transform: scale(0.6) translateY(0);
      }
      25% {
        opacity: 1;
        transform: scale(1) translateY(-4px);
      }
      55% {
        opacity: 0.7;
        transform: scale(1.08) translateY(-10px);
      }
      100% {
        opacity: 0;
        transform: scale(0.5) translateY(-16px);
      }
    }
    .skill-compendium {
      flex: 1 1 240px;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .skill-compendium h3 {
      margin: 0;
      font-size: 1rem;
    }
    .skill-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .skill-empty {
      padding: 0.75rem 0.85rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148,163,184,0.3);
      background: rgba(15,23,42,0.35);
      font-size: 0.85rem;
      color: var(--muted);
      text-align: center;
    }
    .shop-latest {
      margin-top: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .shop-latest h3 {
      margin: 0;
      font-size: 0.95rem;
    }
    .shop-latest-empty {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .battle-sim {
      margin-bottom: 1rem;
      border: 1px solid var(--border);
      border-radius: 1.2rem;
      background:
        radial-gradient(circle at 15% -20%, rgba(59,130,246,0.1), transparent 55%),
        radial-gradient(circle at 85% -10%, rgba(248,113,113,0.1), transparent 55%),
        rgba(15,23,42,0.92);
      box-shadow: 0 22px 60px rgba(8,15,30,0.45);
      padding: 1.1rem 1.25rem 1.35rem;
      display: flex;
      flex-direction: column;
      gap: 0.7rem;
      position: relative;
      overflow: hidden;
    }
    .battle-sim.hidden {
      display: none;
    }
    .battle-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }
    .battle-header h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .battle-arena {
      --battle-art: none;
      --battle-art-size: cover;
      --battle-art-position: center;
      position: relative;
      height: 230px;
      background-color: transparent;
      background-image: var(--battle-art);
      background-size: var(--battle-art-size);
      background-position: var(--battle-art-position);
      background-repeat: no-repeat;
      filter: saturate(1.25) brightness(1.05);
      border: 1px solid rgba(148,163,184,0.25);
      border-radius: 0.9rem;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      padding: 1.5rem 2rem;
      overflow: hidden;
    }
    .battle-arena::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 30% -10%, rgba(59,130,246,0.018), transparent 65%),
        radial-gradient(circle at 70% -20%, rgba(248,113,113,0.02), transparent 60%);
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .battle-arena[data-battle-theme="forest"] {
      --battle-art: url("assets/battle-bg-forest.svg");
    }
    .battle-arena[data-battle-theme="mountain"] {
      --battle-art: url("assets/battle-bg-mountain.svg");
    }
    .battle-arena[data-battle-theme="celestial"] {
      --battle-art: url("assets/battle-bg-celestial.svg");
      --battle-art-position: center top;
    }
    .battle-arena::after {
      content: "";
      position: absolute;
      inset: auto 0 0;
      height: 80px;
      background: linear-gradient(180deg, rgba(30,41,59,0.12), rgba(15,23,42,0.55));
    }
    .storm-strike {
      position: absolute;
      width: var(--storm-size, 220px);
      height: var(--storm-size, 220px);
      pointer-events: none;
      z-index: 6;
      animation: stormStrikeFade 1.2s ease-out forwards;
      filter: drop-shadow(0 12px 24px rgba(56,189,248,0.55));
    }
    .storm-strike svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    .storm-strike .storm-cloud {
      fill: rgba(148,163,184,0.85);
      animation: stormCloudDrift 1.3s ease-out forwards;
    }
    .storm-strike .storm-cloud.cloud-2 {
      animation-delay: 0.08s;
      fill: rgba(203,213,225,0.9);
    }
    .storm-strike .storm-cloud.cloud-3 {
      animation-delay: 0.16s;
      fill: rgba(148,163,184,0.75);
    }
    .storm-strike .storm-bolt,
    .storm-strike .storm-bolt-echo {
      fill: #fde68a;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: 280;
      stroke-dashoffset: 280;
      animation: stormBoltFlash 0.95s ease-out forwards;
    }
    .storm-strike .storm-bolt {
      stroke: #fef3c7;
      stroke-width: 5px;
      filter: drop-shadow(0 0 18px rgba(250,204,21,0.8));
    }
    .storm-strike .storm-bolt-echo {
      stroke: rgba(253,230,138,0.45);
      stroke-width: 8px;
      opacity: 0.65;
      animation-delay: 0.03s;
      filter: drop-shadow(0 0 22px rgba(14,165,233,0.6));
    }
    .storm-strike .storm-glow {
      fill: rgba(191,219,254,0.8);
      opacity: 0.9;
      filter: drop-shadow(0 0 24px rgba(59,130,246,0.55));
      animation: stormGlowPulse 1.1s ease-out forwards;
    }
    .storm-strike .storm-glow-outline {
      fill: none;
      stroke: rgba(125,211,252,0.65);
      stroke-width: 2;
      stroke-dasharray: 14 10;
      animation: stormRingPulse 1.1s ease-out forwards;
    }
    .storm-strike .storm-rain line {
      stroke: rgba(125,211,252,0.75);
      stroke-width: 2;
      stroke-linecap: round;
      animation: stormRainFall 0.8s ease-out forwards;
    }
    @keyframes stormStrikeFade {
      0% { opacity: 0; transform: translateY(-20px) scale(0.9); }
      25% { opacity: 1; transform: translateY(0) scale(1); }
      65% { opacity: 1; transform: translateY(6px) scale(1.02); }
      100% { opacity: 0; transform: translateY(40px) scale(0.9); }
    }
    @keyframes stormCloudDrift {
      0% { opacity: 0; transform: translateY(-20px) scale(0.9); }
      35% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0.4; transform: translate(20px, 10px) scale(1.05); }
    }
    @keyframes stormBoltFlash {
      0% { stroke-dashoffset: 280; opacity: 0; }
      30% { stroke-dashoffset: 140; opacity: 1; }
      55% { stroke-dashoffset: 0; opacity: 1; }
      100% { stroke-dashoffset: 0; opacity: 0; }
    }
    @keyframes stormGlowPulse {
      0% { opacity: 0; transform: scale(0.6); }
      40% { opacity: 0.9; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.4); }
    }
    @keyframes stormRingPulse {
      0% { opacity: 0; transform: scale(0.8); }
      50% { opacity: 0.9; transform: scale(1.05); }
      100% { opacity: 0; transform: scale(1.3); }
    }
    @keyframes stormRainFall {
      0% { opacity: 0; transform: translateY(-20px); }
      40% { opacity: 1; }
      100% { opacity: 0; transform: translateY(60px); }
    }
    @keyframes arenaGlow {
      0%, 100% { transform: translate(-5%, -5%) scale(1); opacity: 0.35; }
      50% { transform: translate(5%, 5%) scale(1.1); opacity: 0.65; }
    }
    .modal-battle-overview {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
    }
    .modal-battle-card {
      flex: 1 1 280px;
      border-radius: 1rem;
      border: 1px solid rgba(59,130,246,0.25);
      background: linear-gradient(135deg, rgba(15,23,42,0.98), rgba(13,25,46,0.75));
      padding: 1rem 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      box-shadow: inset 0 0 18px rgba(2,6,23,0.55);
    }
    .modal-battle-card.hero {
      border-color: rgba(56,189,248,0.45);
      background: linear-gradient(140deg, rgba(13,23,42,0.95), rgba(15,118,255,0.18));
    }
    .modal-battle-card.enemy {
      border-color: rgba(248,113,113,0.4);
      background: linear-gradient(140deg, rgba(36,12,23,0.92), rgba(190,24,93,0.16));
    }
    .modal-card-head {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .modal-card-top {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 0.8rem;
      flex-wrap: wrap;
      width: 100%;
    }
    .modal-card-head h4 {
      margin: 0;
      font-size: 1.1rem;
      flex: 0 0 auto;
    }
    .modal-card-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: auto;
    }
    .modal-card-meta {
      margin: 0;
      font-size: 0.76rem;
      color: rgba(226,232,240,0.85);
    }
    .modal-card-hp {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.4rem 0.7rem;
      border-radius: 999px;
      background: rgba(15,23,42,0.65);
      border: 1px solid rgba(148,163,184,0.35);
      min-width: 220px;
    }
    .modal-card-top .modal-card-hp {
      flex: 1 1 auto;
    }
    .modal-card-hp.hero {
      border-color: rgba(56,189,248,0.35);
      box-shadow: 0 8px 18px rgba(14,165,233,0.18);
    }
    .modal-card-hp.enemy {
      border-color: rgba(248,113,113,0.35);
      box-shadow: 0 8px 18px rgba(248,113,113,0.18);
    }
    .modal-card-hp .hp-label {
      font-size: 0.72rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.8);
    }
    .modal-card-hp .hp-track {
      flex: 1;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.5);
    }
    .modal-card-hp .hp-fill.hero {
      background: linear-gradient(90deg, #38bdf8, #0ea5e9);
    }
    .modal-card-hp .hp-fill.enemy {
      background: linear-gradient(90deg, #fb923c, #f43f5e);
    }
    .modal-card-hp .hp-value {
      font-size: 0.85rem;
      font-weight: 600;
      color: rgba(226,232,240,0.9);
      min-width: 80px;
      text-align: right;
    }
    .arena-particles {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }
    .arena-particles span {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(248,250,252,0.65);
      opacity: 0.4;
      box-shadow: 0 0 8px rgba(248,250,252,0.8);
      animation: particleDrift 6s linear infinite;
    }
    .arena-particles span:nth-child(2) { animation-duration: 7s; background: rgba(59,130,246,0.8); }
    .arena-particles span:nth-child(3) { animation-duration: 8s; background: rgba(248,113,113,0.8); }
    .arena-particles span:nth-child(4) { animation-duration: 9s; }
    .arena-particles span:nth-child(5) { animation-duration: 10s; background: rgba(251,191,36,0.85); }
    .arena-particles span:nth-child(6) { animation-duration: 11s; }
    .arena-particles span:nth-child(7) { animation-duration: 12s; }
    .arena-particles span:nth-child(8) { animation-duration: 13s; }
    @keyframes particleDrift {
      0% { transform: translateY(20px) scale(0.8); opacity: 0; }
      10% { opacity: 0.5; }
      50% { opacity: 0.8; }
      100% { transform: translateY(-220px) scale(1.2); opacity: 0; }
    }
    .fighter {
      position: relative;
      width: 140px;
      height: 140px;
      border-radius: 0.85rem;
      background: transparent;
      border: none;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 0.6rem;
      overflow: visible;
    }
    .fighter.knight {
      width: 98px;
      height: 98px;
      margin-bottom: -82px;
    }
    .shield-wall-overlay {
      position: absolute;
      width: 165px;
      height: 242px;
      top: -223px;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 4;
      opacity: 0;
      filter: drop-shadow(0 0 32px rgba(191,219,254,0.6));
      transition: opacity 0.35s ease;
    }
    .shield-wall-overlay.active {
      opacity: 1;
    }
    .shield-wall-overlay svg {
      width: 100%;
      height: auto;
      display: block;
    }
    .shield-wall-overlay .shield-wall-shape {
      fill: rgba(125,211,252,0.18);
      stroke: rgba(186,230,253,0.7);
      stroke-width: 2.2;
      filter: drop-shadow(0 0 14px rgba(59,130,246,0.45));
      animation: shieldWallPulse 4s ease-in-out infinite;
      transform-origin: 50% 70%;
    }
    .shield-wall-overlay .shield-wall-rune {
      fill: none;
      stroke: rgba(224,242,254,0.8);
      stroke-width: 1.4;
      stroke-linecap: round;
      stroke-dasharray: 18;
      animation: shieldWallRune 5s linear infinite;
    }
    .shield-wall-overlay .shield-wall-rune.rune-2 { animation-delay: 0.6s; }
    .shield-wall-overlay .shield-wall-rune.rune-3 { animation-delay: 1.2s; }
    .shield-wall-overlay .shield-wall-spark {
      fill: rgba(191,219,254,0.9);
      opacity: 0;
      animation: shieldWallSpark 3.8s linear infinite;
    }
    .shield-wall-overlay .shield-wall-spark.spark-2 { animation-delay: 0.5s; }
    .shield-wall-overlay .shield-wall-spark.spark-3 { animation-delay: 1.1s; }
    .shield-wall-overlay .shield-wall-counter {
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      color: #e0f2fe;
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-shadow: 0 0 10px rgba(14,165,233,0.9);
    }
    .shield-wall-overlay.hit .shield-wall-shape {
      animation: shieldWallHit 0.45s ease-out;
    }
    .shield-wall-overlay.spent {
      opacity: 0;
      transition: opacity 0.4s ease;
    }
    .frenzy-aura {
      position: absolute;
      width: 240px;
      height: 240px;
      top: -140px;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 7;
      opacity: 0.95;
      mix-blend-mode: screen;
      animation: frenzyAuraPulse 1.8s ease-in-out infinite;
      filter: drop-shadow(0 0 25px rgba(248,113,113,0.8));
    }
    .frenzy-aura svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    .frenzy-aura .frenzy-ring {
      fill: none;
      stroke: rgba(248,113,113,0.9);
      stroke-width: 3.6;
      stroke-dasharray: 18 8;
      animation: frenzyRingSpin 2s linear infinite;
    }
    .frenzy-aura .frenzy-ring.ring-2 {
      stroke: rgba(225,29,72,0.75);
      stroke-width: 2.8;
      animation-duration: 2.4s;
      animation-direction: reverse;
    }
    .frenzy-aura .frenzy-surge {
      fill: rgba(248,113,113,0.45);
      filter: blur(18px);
      animation: frenzySurgeFlash 1.4s ease-in-out infinite;
    }
    .frenzy-aura .frenzy-spark {
      fill: rgba(254,226,226,0.9);
      animation: frenzySparkDrift 1.2s ease-in-out infinite;
    }
    .frenzy-aura .frenzy-spark.spark-2 { animation-delay: 0.3s; }
    .frenzy-aura .frenzy-spark.spark-3 { animation-delay: 0.6s; }
    .healing-wave {
      position: absolute;
      width: 220px;
      height: 220px;
      top: -120px;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
      opacity: 0;
      z-index: 3;
      animation: healingWaveFade 1.4s ease-out forwards;
    }
    .healing-wave svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    .healing-wave .healing-ring {
      fill: none;
      stroke: rgba(134,239,172,0.85);
      stroke-width: 2.4;
      stroke-dasharray: 12 18;
      animation: healingRingPulse 1.4s ease-out forwards;
    }
    .healing-wave .healing-ring.ring-2 {
      stroke: rgba(59,130,246,0.5);
      stroke-width: 3;
      animation-delay: 0.08s;
    }
    .healing-wave .healing-glow {
      fill: rgba(134,239,172,0.35);
      filter: blur(12px);
      animation: healingGlowPulse 1.4s ease-out forwards;
    }
    .healing-wave .healing-spark {
      fill: rgba(224,255,255,0.9);
      animation: healingSparkRise 1.2s ease-out forwards;
    }
    .healing-wave .healing-spark.spark-2 { animation-delay: 0.2s; }
    .healing-wave .healing-spark.spark-3 { animation-delay: 0.35s; }
    .battle-weapon-slot {
      position: absolute;
      width: 66px;
      height: 66px;
      border-radius: 999px;
      display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        box-shadow: none;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 2;
    }
    .battle-weapon-slot[data-empty="true"] {
      opacity: 0;
      transform: scale(0.85);
    }
    .battle-weapon-slot svg,
    .battle-weapon-slot img {
      width: 120%;
      height: 120%;
      object-fit: contain;
      display: block;
    }
    .fighter.knight .battle-weapon-slot.weapon-left {
      left: -22px;
      bottom: 70px;
    }
    .fighter.knight .battle-weapon-slot.weapon-right {
      right: -27px;
      bottom: 70px;
    }
    .fighter::before {
      content: "";
      position: absolute;
      width: 96px;
      height: 96px;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      image-rendering: pixelated;
    }
    .fighter::after {
      content: "";
      position: absolute;
      width: 64px;
      height: 20px;
      top: 64px;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 6px;
    }
    .fighter.knight::before {
      display: none;
    }
    .fighter.knight::after {
      background: transparent;
      box-shadow: none;
    }
    .fighter.enemy {
      background: rgba(30,41,59,0.25);
      margin-bottom: 12px;
      margin-right: 6px;
    }
    .fighter.enemy::before {
      display: none;
    }
    .fighter.enemy::after {
      display: none;
    }
    .fighter.enemy.defeated .fighter-sprite {
      animation: battleDefeatShrink 0.7s ease forwards;
      transform-origin: 50% 70%;
    }
    .fighter.knight.defeated {
      animation: battleHeroDefeatShrink 0.7s ease forwards;
      transform-origin: 50% 90%;
    }
    .fighter-sprite {
      position: absolute;
      width: 240px;
      max-width: 180%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      filter: drop-shadow(0 18px 34px rgba(3,7,18,0.75));
      transition: transform 0.8s ease, opacity 0.8s ease;
    }
    .fighter.knight .fighter-sprite {
      transform: translate(-50%, -104%);
    }
    .fighter.attacking-left { animation: attackLeft 0.5s ease-out; }
    .fighter.attacking-right { animation: attackRight 0.5s ease-out; }
    .fighter.hit { animation: hitFlash 0.42s ease-out; }
    @keyframes shieldWallPulse {
      0% { transform: scale(0.95); opacity: 0.85; }
      45% { transform: scale(1.02); opacity: 1; }
      100% { transform: scale(0.95); opacity: 0.85; }
    }
    @keyframes shieldWallRune {
      0% { stroke-dashoffset: 18; opacity: 0.4; }
      40% { stroke-dashoffset: 6; opacity: 0.8; }
      80% { stroke-dashoffset: 0; opacity: 0.4; }
      100% { stroke-dashoffset: -18; opacity: 0.3; }
    }
    @keyframes shieldWallSpark {
      0% { opacity: 0; transform: translate(0,0) scale(0.4); }
      30% { opacity: 0.9; transform: translate(4px,-6px) scale(0.85); }
      70% { opacity: 0.4; transform: translate(-6px,-12px) scale(1.1); }
      100% { opacity: 0; transform: translate(2px,-20px) scale(0.6); }
    }
    @keyframes shieldWallHit {
      0% { transform: scale(1); filter: drop-shadow(0 0 14px rgba(59,130,246,0.6)); }
      50% { transform: scale(1.05); filter: drop-shadow(0 0 24px rgba(248,250,252,0.9)); }
      100% { transform: scale(1); filter: drop-shadow(0 0 14px rgba(59,130,246,0.6)); }
    }
    @keyframes healingWaveFade {
      0% { opacity: 0; transform: translateX(-50%) scale(0.85); }
      25% { opacity: 1; transform: translateX(-50%) scale(1); }
      100% { opacity: 0; transform: translateX(-50%) scale(1.15); }
    }
    @keyframes healingRingPulse {
      0% { stroke-dashoffset: 24; opacity: 0.6; transform: scale(0.9); }
      60% { stroke-dashoffset: 0; opacity: 1; transform: scale(1.05); }
      100% { stroke-dashoffset: -30; opacity: 0; transform: scale(1.2); }
    }
    @keyframes healingGlowPulse {
      0% { opacity: 0.1; transform: scale(0.5); }
      40% { opacity: 0.65; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.4); }
    }
    @keyframes healingSparkRise {
      0% { opacity: 0; transform: translate(0, 20px) scale(0.4); }
      35% { opacity: 1; transform: translate(4px, -10px) scale(0.9); }
      100% { opacity: 0; transform: translate(-6px, -60px) scale(1.2); }
    }
    @keyframes frenzyAuraPulse {
      0% { opacity: 0.45; transform: translateX(-50%) scale(0.95); }
      50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
      100% { opacity: 0.45; transform: translateX(-50%) scale(0.95); }
    }
    @keyframes frenzyRingSpin {
      0% { stroke-dashoffset: 0; transform: rotate(0deg); }
      100% { stroke-dashoffset: -60; transform: rotate(360deg); }
    }
    @keyframes frenzySurgeFlash {
      0% { opacity: 0.2; transform: scale(0.8); }
      40% { opacity: 0.8; transform: scale(1); }
      100% { opacity: 0.2; transform: scale(1.2); }
    }
    @keyframes frenzySparkDrift {
      0% { opacity: 0; transform: translate(0, 10px) scale(0.6); }
      40% { opacity: 1; transform: translate(4px, -10px) scale(1); }
      100% { opacity: 0; transform: translate(-6px, -26px) scale(0.6); }
    }
    .hp-track {
      flex: 1;
      height: 14px;
      border-radius: 999px;
      background: rgba(15,23,42,0.6);
      border: 1px solid rgba(148,163,184,0.35);
      overflow: hidden;
    }
    .hp-fill {
      height: 100%;
      width: 100%;
      transition: width 0.25s ease;
    }
    .hp-fill.hero {
      background: linear-gradient(90deg, #38bdf8, #0ea5e9);
    }
    .hp-fill.enemy {
      background: linear-gradient(90deg, #f97316, #ef4444);
    }
    .hp-value {
      width: 74px;
      text-align: right;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }
    .battle-foot {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .battle-result {
      margin: 0;
      min-height: 1.4rem;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .battle-reward[hidden] {
      display: none;
    }
    .battle-reward {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 0.4rem 0 0.8rem;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.25s ease, transform 0.25s ease;
    }
    .battle-reward.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .battle-reward-chest {
      position: relative;
      width: 92px;
      height: 92px;
    }
    .battle-reward-chest .chest-svg {
      width: 100%;
      height: auto;
      display: block;
      filter: drop-shadow(0 10px 18px rgba(15,23,42,0.6));
    }
    .battle-reward-coins {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .battle-reward-coins span {
      position: absolute;
      left: 50%;
      bottom: 36%;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 30%, #fff7c2, #facc15 55%, #b45309 92%);
      box-shadow: 0 4px 12px rgba(250,204,21,0.45);
      opacity: 0;
      transform: translate(-50%, 10px) scale(0.5);
    }
    .battle-reward.visible .battle-reward-coins span {
      animation: battleRewardCoin 1.4s ease-out forwards;
      animation-delay: var(--coin-delay, 0s);
    }
    .battle-reward-coins span:nth-child(1) { --coin-shift-x: -40px; --coin-delay: 0s; }
    .battle-reward-coins span:nth-child(2) { --coin-shift-x: 10px; --coin-delay: 0.08s; }
    .battle-reward-coins span:nth-child(3) { --coin-shift-x: -5px; --coin-delay: 0.15s; }
    .battle-reward-coins span:nth-child(4) { --coin-shift-x: 24px; --coin-delay: 0.25s; }
    .battle-reward-coins span:nth-child(5) { --coin-shift-x: -22px; --coin-delay: 0.32s; }
    .battle-reward-copy {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }
    .battle-reward-copy strong {
      font-size: 0.95rem;
      color: #facc15;
    }
    .battle-reward-copy small {
      font-size: 0.75rem;
      color: rgba(226,232,240,0.8);
    }
    .battle-victory-chest {
      position: absolute;
      left: 50%;
      bottom: 10px;
      transform: translate(-50%, 50px) scale(0.5);
      opacity: 0;
      transition: transform 4.5s cubic-bezier(0.22, 1, 0.36, 1), opacity 4.5s ease;
      pointer-events: none;
      z-index: 30;
    }
    .battle-victory-chest.visible {
      opacity: 1;
      transform: translate(-50%, 0) scale(1.1);
    }
    .battle-victory-chest .chest-svg {
      width: 180px;
      height: auto;
      display: block;
      filter: drop-shadow(0 12px 24px rgba(8,15,30,0.65));
    }
    .battle-reward[hidden] {
      display: none;
    }
    .battle-reward {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 0.4rem 0 0.8rem;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.25s ease, transform 0.25s ease;
    }
    .battle-reward.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .battle-reward-chest {
      position: relative;
      width: 92px;
      height: 92px;
    }
    .battle-reward-chest img {
      width: 100%;
      height: auto;
      display: block;
      filter: drop-shadow(0 10px 18px rgba(15,23,42,0.6));
    }
    .battle-reward-coins {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .battle-reward-coins span {
      position: absolute;
      left: 50%;
      bottom: 36%;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 30%, #fff7c2, #facc15 55%, #b45309 92%);
      box-shadow: 0 4px 12px rgba(250,204,21,0.45);
      opacity: 0;
      transform: translate(-50%, 10px) scale(0.5);
    }
    .battle-reward.visible .battle-reward-coins span {
      animation: battleRewardCoin 1.4s ease-out forwards;
      animation-delay: var(--coin-delay, 0s);
    }
    .battle-reward-coins span:nth-child(1) { --coin-shift-x: -40px; --coin-delay: 0s; }
    .battle-reward-coins span:nth-child(2) { --coin-shift-x: 10px; --coin-delay: 0.08s; }
    .battle-reward-coins span:nth-child(3) { --coin-shift-x: -5px; --coin-delay: 0.15s; }
    .battle-reward-coins span:nth-child(4) { --coin-shift-x: 24px; --coin-delay: 0.25s; }
    .battle-reward-coins span:nth-child(5) { --coin-shift-x: -22px; --coin-delay: 0.32s; }
    .battle-reward-copy {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }
    .battle-reward-copy strong {
      font-size: 0.95rem;
      color: #facc15;
    }
    .battle-reward-copy small {
      font-size: 0.75rem;
      color: rgba(226,232,240,0.8);
    }
    .battle-skill-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .battle-skill {
      flex: 1 1 180px;
      min-width: 160px;
      padding: 0.45rem 0.6rem;
      border-radius: 0.65rem;
      background: rgba(59,130,246,0.18);
      border: 1px solid rgba(59,130,246,0.45);
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .battle-skill.headline {
      flex: 1 1 100%;
      border: none;
      background: transparent;
      padding: 0;
      min-width: 100%;
    }
    .battle-skill button {
      all: unset;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      cursor: pointer;
      font-weight: 600;
      color: var(--text);
    }
    .battle-skill button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .battle-skill.skill-locked {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .battle-skill.skill-locked button {
      cursor: not-allowed;
    }
    .battle-skill-hotkey {
      background: rgba(148,163,184,0.2);
      color: var(--text);
      border-radius: 0.55rem;
      padding: 0.1rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.03em;
    }
    .battle-skill-desc {
      font-size: 0.78rem;
      color: rgba(226,232,240,0.75);
    }
    .battle-skill.used {
      background: rgba(71,85,105,0.25);
      border-color: rgba(71,85,105,0.55);
    }
    .battle-next {
      align-self: flex-end;
      padding: 0.55rem 1.1rem;
      background: var(--accent);
      color: #1f2937;
      border-radius: 0.75rem;
      border: none;
      font-weight: 600;
      box-shadow: 0 12px 28px rgba(245,158,11,0.28);
    }
    .battle-next.hidden { display: none; }
    .damage-float {
      position: absolute;
      left: 50%;
      top: 45%;
      transform: translate(-50%, -10px);
      font-size: 1.1rem;
      font-weight: 700;
      color: #f87171;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
      animation: damageFloat 1s ease-out forwards;
      pointer-events: none;
      white-space: nowrap;
    }
    .damage-float.hero-hit {
      color: #38bdf8;
    }
    .damage-float.enemy-hit {
      color: #f87171;
    }
    .damage-float.crit {
      color: #fde68a;
      text-shadow: 0 0 12px rgba(250,204,21,0.9);
    }
    .damage-float.heal {
      color: #34d399;
      text-shadow: 0 2px 8px rgba(16,185,129,0.4);
    }
    .status-float {
      position: absolute;
      left: 50%;
      top: 45%;
      transform: translate(-50%, -10px);
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      color: #e2e8f0;
      text-shadow: 0 2px 8px rgba(0,0,0,0.45);
      animation: damageFloat 1s ease-out forwards;
      pointer-events: none;
      white-space: nowrap;
    }
    .status-float.buff {
      color: #4ade80;
    }
    .status-float.debuff {
      color: #fbbf24;
    }
    @keyframes damageFloat {
      0% {
        opacity: 0;
        transform: translate(-50%, -10px) scale(0.85);
      }
      15% {
        opacity: 1;
        transform: translate(-50%, -24px) scale(1.05);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -80px) scale(1.1);
      }
    }
    @keyframes attackLeft {
      0% { transform: translateX(0); }
      40% { transform: translateX(60px); }
      60% { transform: translateX(60px); }
      100% { transform: translateX(0); }
    }
    @keyframes attackRight {
      0% { transform: translateX(0); }
      40% { transform: translateX(-60px); }
      60% { transform: translateX(-60px); }
      100% { transform: translateX(0); }
    }
    @keyframes hitFlash {
      0% { filter: brightness(1); transform: translateY(0); }
      25% { filter: brightness(1.8); transform: translateY(-6px); }
      100% { filter: brightness(1); transform: translateY(0); }
    }
    @keyframes battleDefeatShrink {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(0.05); opacity: 0; }
    }
    @keyframes battleHeroDefeatShrink {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0.1); opacity: 0; }
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #coinAnimationLayer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 120;
    }
    .coin-celebration {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      transform: translate(-50%, -50%);
      animation: coinCelebrationRise 2.95s ease-out forwards;
    }
    .coin-main {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,241,179,0.95), rgba(245,158,11,0.95) 55%, rgba(161,98,7,0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 32px rgba(245,158,11,0.8), 0 0 70px rgba(245,158,11,0.4);
      border: 3px solid rgba(255,248,220,0.4);
      animation: coinMainPulse 2.81s ease-out forwards;
      position: relative;
      overflow: hidden;
    }
    .coin-main::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(255,255,255,0.6), rgba(255,255,255,0));
      mix-blend-mode: screen;
      transform: translateX(-120%);
      animation: coinShine 2.81s ease-out forwards;
    }
    .coin-symbol {
      font-size: 48px;
      color: #1f2937;
      text-shadow: 0 4px 12px rgba(0,0,0,0.35);
      animation: coinSymbolPop 2.34s ease-out forwards;
    }
    .coin-amount {
      margin-top: 0.6rem;
      font-size: 1.15rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: #fef3c7;
      text-shadow: 0 0 10px rgba(245,158,11,0.8);
      animation: coinAmountRise 2.73s ease-out forwards;
    }
    .coin-spark {
      --targetX: 0px;
      --targetY: -120px;
      position: absolute;
      width: 34px;
      height: 34px;
      left: 50%;
      top: 45%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fef3c7, #f59e0b);
      border: 2px solid rgba(255,255,255,0.55);
      box-shadow: 0 0 16px rgba(245,158,11,0.6);
      opacity: 0;
      animation: coinSparkFly 2.34s ease-out forwards;
    }
    .coin-spark::after {
      content: "💰";
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #1f2937;
    }
    .coin-badge-boost {
      animation: coinBadgePulse 2.6s ease-out;
    }
    .coin-celebration.loss .coin-main {
      background: radial-gradient(circle at 30% 30%, rgba(254,205,211,0.95), rgba(248,113,113,0.95) 55%, rgba(127,29,29,0.95));
      box-shadow: 0 0 32px rgba(248,113,113,0.8), 0 0 70px rgba(248,113,113,0.35);
      border-color: rgba(254,226,226,0.5);
    }
    .coin-celebration.loss .coin-symbol {
      color: #7f1d1d;
      text-shadow: 0 4px 12px rgba(127,29,29,0.55);
    }
    .coin-celebration.loss .coin-amount {
      color: #fecaca;
      text-shadow: 0 0 12px rgba(248,113,113,0.7);
    }
    .coin-celebration.loss .coin-spark {
      background: radial-gradient(circle at 30% 30%, rgba(254,226,226,1), rgba(248,113,113,0.95));
      border-color: rgba(254,226,226,0.65);
      box-shadow: 0 0 16px rgba(248,113,113,0.6);
    }
    .coin-celebration.loss .coin-spark::after {
      content: "💸";
      color: #7f1d1d;
    }
    .coin-badge-loss {
      animation: coinBadgeLoss 2.6s ease-out;
    }
    @keyframes coinCelebrationRise {
      0% {
        opacity: 0;
        transform: translate(-50%, -20%) scale(0.6);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -60%) scale(1.02);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -120%) scale(0.98);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -160%) scale(0.9);
      }
    }
    @keyframes coinMainPulse {
      0% { transform: scale(0.4) rotate(-12deg); }
      45% { transform: scale(1.1) rotate(6deg); }
      80% { transform: scale(1); }
      100% { transform: scale(0.92); }
    }
    @keyframes coinShine {
      0% { transform: translateX(-120%); }
      50% { transform: translateX(0%); }
      100% { transform: translateX(120%); }
    }
    @keyframes coinSymbolPop {
      0% { opacity: 0; transform: scale(0.4) rotate(-30deg); }
      50% { opacity: 1; transform: scale(1.15) rotate(10deg); }
      100% { opacity: 1; transform: scale(1) rotate(0deg); }
    }
    @keyframes coinAmountRise {
      0% { opacity: 0; transform: translateY(24px); }
      35% { opacity: 1; transform: translateY(-6px); }
      100% { opacity: 0; transform: translateY(-40px); }
    }
    @keyframes coinSparkFly {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
      25% { opacity: 1; }
      100% { opacity: 0; transform: translate(calc(-50% + var(--targetX)), calc(-50% + var(--targetY))) scale(0.15); }
    }
    @keyframes coinBadgePulse {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245,158,11,0.6); }
      35% { transform: scale(1.2); box-shadow: 0 0 32px 10px rgba(245,158,11,0.35); }
      70% { transform: scale(1.05); box-shadow: 0 0 12px 4px rgba(245,158,11,0.2); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245,158,11,0); }
    }
    @keyframes coinBadgeLoss {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(248,113,113,0.55); }
      35% { transform: scale(1.18); box-shadow: 0 0 32px 10px rgba(248,113,113,0.3); }
      70% { transform: scale(0.96); box-shadow: 0 0 12px 4px rgba(248,113,113,0.18); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(248,113,113,0); }
    }
    @keyframes battleRewardCoin {
      0% {
        opacity: 0;
        transform: translate(-50%, 20px) scale(0.4);
      }
      30% {
        opacity: 1;
      }
      70% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translate(calc(-50% + var(--coin-shift-x, 0px)), -120px) scale(0.95);
      }
    }
    @media (max-width: 720px) {
      header { flex-direction: column; align-items: flex-start; gap: 0.75rem; }
      .hero-avatar { width: 130px; height: 160px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <span class="title">Shortcut Ritter-Akademie</span>
      <button class="mobile-nav-toggle" id="mobileNavToggle" type="button" aria-expanded="false" aria-controls="topNav">Menü &#8801;</button>
      <div class="top-nav" id="topNav">
        <button class="nav-toggle active" data-view="learn"><span class="emoji">🎯</span>Training</button>
        <button class="nav-toggle" data-view="inventory"><span class="emoji">🎒</span>Inventar</button>
        <button class="nav-toggle" data-view="skills"><span class="emoji">✨</span>Skills</button>
        <button class="nav-toggle" data-view="shop"><span class="emoji">🏪</span>Shop</button>
        <button class="nav-toggle" data-view="battle"><span class="emoji">⚔️</span>Battle</button>
        <button class="nav-toggle" data-view="report"><span class="emoji">📊</span>Report</button>
      </div>
    </div>
    <div class="header-right">
      <span class="badge" id="coinTop">Coins: 0</span>
    </div>
  </header>
  <div id="coinAnimationLayer"></div>
  <main>
    <section id="learnView" class="view active">
      <div class="card nav-card">
        <div class="nav-row" id="sectionTabs"></div>
        <p class="small">Jede perfekte Lösung bringt 10 Coins pro Aufgabe (3 Aufgaben = 30 Coins). Nach Zurücksetzen gibt es 5 Coins pro Aufgabe.</p>
      </div>
      <div id="learnSections"></div>
      <div class="card" id="overviewCard">
        <h2>Gesamtübersicht</h2>
        <p class="small" id="overallSummary">Noch keine Ergebnisse.</p>
      </div>
    </section>
    <section id="inventoryView" class="view">
      <div class="game-grid">
        <div class="card" id="playerCard">
        <div class="statline-row">
          <div class="statline">
            <span class="badge" id="atkDisplay">ATK 1</span>
            <span class="badge" id="defDisplay">DEF 0</span>
            <span class="badge" id="hpDisplay">HP 0</span>
            <span class="badge" id="itemsDisplay">Gear: 0/0</span>
          </div>
        </div>
        <div class="hero-wrapper">
          <div class="equipment-layout">
            <div class="slot-row top-row">
              <div class="equipment-slot" data-equip-slot="gloves">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Handschuhe</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="gloves" aria-label="Handschuhe entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="equipment-slot" data-equip-slot="helm">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Helm</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="helm" aria-label="Helm entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="equipment-slot" data-equip-slot="necklace">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Halskette</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="necklace" aria-label="Halskette entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
            </div>
            <div class="slot-row middle-row">
              <div class="equipment-slot tall" data-equip-slot="weapon">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Schwert</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="weapon" aria-label="Schwert entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="hero-center">
                <div class="hero-avatar" id="heroAvatar" data-atk-tier="1" data-def-tier="1">
                  <img
                    id="heroAvatarImage"
                    class="hero-illustration is-blueprint"
                    src="assets/blueprint_clean.svg"
                    alt="Blueprint deines Helden"
                    loading="lazy"
                  />
                </div>
              </div>
              <div class="equipment-slot tall" data-equip-slot="offhand">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Schwert 2 / Schild</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="offhand" aria-label="Schild entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
            </div>
            <div class="slot-row bottom-row">
              <div class="equipment-slot" data-equip-slot="ring_left">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Ring / Amulett 1</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="ring_left" aria-label="Ring links entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="equipment-slot" data-equip-slot="boots">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Stiefel</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="boots" aria-label="Stiefel entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
              <div class="equipment-slot" data-equip-slot="ring_right">
                <div class="slot-body">
                  <div class="slot-icon"><span class="slot-placeholder">?</span></div>
                  <div class="slot-info">
                    <div class="slot-header">
                      <span>Ring / Amulett 2</span>
                    </div>
                    <div class="slot-stats"></div>
                    <button class="slot-unequip" type="button" data-slot="ring_right" aria-label="Ring rechts entfernen" hidden>&times;</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="inventory">
            <div class="inventory-filter-bar" aria-label="Inventarfilter">
              <div class="inventory-filter-buttons" role="group" aria-label="Kategorie wählen">
                <button class="inventory-filter-btn active" type="button" data-inventory-filter="weapon" aria-pressed="true">Waffe</button>
                <button class="inventory-filter-btn" type="button" data-inventory-filter="armor" aria-pressed="false">Ausrüstung</button>
                <button class="inventory-filter-btn" type="button" data-inventory-filter="accessory" aria-pressed="false">Accessoire</button>
              </div>
              <div class="inventory-actions">
                <button id="autoEquipBtn" class="primary-btn secondary" type="button">Auto anziehen</button>
                <button id="unequipAllBtn" class="primary-btn secondary" type="button">Alle ausziehen</button>
              </div>
            </div>
            <div id="inventoryList" class="inventory-list"></div>
            <div id="inventoryFilterEmpty" class="skill-empty" hidden>Keine Items in dieser Kategorie.</div>
            <div id="inventoryEmpty" class="skill-empty">Noch keine Ausrüstung vorhanden. Besuche den Shop, um neue Items zu kaufen.</div>
          </div>
        </div>
      </div>
    </section>
    <section id="skillsView" class="view">
      <div class="game-grid">
        <div class="card" id="skillCard">
          <div class="skill-wrapper">
            <div class="skill-avatar" aria-hidden="true">
          <!--    <svg class="skill-svg" viewBox="0 0 120 150" xmlns="http://www.w3.org/2000/svg" role="img" aria-labelledby="skillSpellbookTitle">
          -->

                <svg viewBox="35 0 140 190" xmlns="http://www.w3.org/2000/svg" role="img" preserveAspectRatio="xMidYMid meet">
  <defs>
    <filter id="emblemGlow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="3" result="blur"/>
      <feMerge>
        <feMergeNode in="blur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
    <!-- Funken-Basis: 60s wie Mond -->
    <circle id="spark" cx="0" cy="0" r="2" fill="#ffe9a9">
      <animate attributeName="fill"
               values="#ffe9a9;#ffe9a9;#9b5cff;#9b5cff;#ffe9a9"
               keyTimes="0;0.4667;0.5;0.9667;1"
               dur="60s"
               repeatCount="indefinite" />
    </circle>
  </defs>

  <g id="book" transform="translate(0,6.6)">
    <!-- Spine -->
    <rect x="43" y="25" width="7" height="140" fill="#5a371e" stroke="#3f2411" stroke-width="2"/>

    <!-- Book cover -->
    <path d="M50 25 H160 a6 6 0 0 1 6 6 V159 a6 6 0 0 1 -6 6 H50 Z"
          fill="#7b4b26" stroke="#3f2411" stroke-width="3" />

    <!-- Pages -->
    <rect x="160" y="31" width="3" height="130" rx="1.5" ry="1.5"
          fill="#f3e7d4" stroke="#c8b49a" stroke-width="1"/>

    <!-- Emblem + Glow -->
    <g filter="url(#emblemGlow)">
      <circle cx="105" cy="85" r="28" fill="#f3e7d4" stroke="#caa052" stroke-width="3">
        <animate attributeName="fill"
                 values="#f3e7d4;#f3e7d4;#2b2b2b;#2b2b2b;#f3e7d4"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 repeatCount="indefinite" />
      </circle>
      <circle cx="105" cy="85" r="30" fill="none" stroke="#ffe9a9" stroke-width="1.5" opacity="0.4">
        <animate attributeName="r" values="28;35;28" dur="3s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0.1;0.5;0.1" dur="3s" repeatCount="indefinite" />
        <animate attributeName="stroke"
                 values="#ffe9a9;#ffe9a9;#9b5cff;#9b5cff;#ffe9a9"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 repeatCount="indefinite" />
      </circle>
    </g>

    <!-- MOND -->
    <g>
      <circle cx="105" cy="85" r="12" fill="#caa052">
        <animate attributeName="r"
                 values="12;13;12"
                 keyTimes="0;0.5;1"
                 dur="20s"
                 repeatCount="indefinite"
                 calcMode="spline"
                 keySplines="0.42 0 0.58 1; 0.42 0 0.58 1" />
        <animate attributeName="fill"
                 values="#caa052;#caa052;#9b5cff;#9b5cff;#caa052"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 repeatCount="indefinite" />
      </circle>
      <!-- Cutout fährt im selben Takt und färbt mit -->
      <circle cx="111" cy="82" r="10" fill="#f3e7d4">
        <animate attributeName="cx"
                 values="111;111;99;99;111"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 calcMode="spline"
                 keySplines="0 0 1 1;
                             0.42 0 0.58 1;
                             0 0 1 1;
                             0.42 0 0.58 1"
                 repeatCount="indefinite" />
        <animate attributeName="fill"
                 values="#f3e7d4;#f3e7d4;#2b2b2b;#2b2b2b;#f3e7d4"
                 keyTimes="0;0.4667;0.5;0.9667;1"
                 dur="60s"
                 repeatCount="indefinite" />
      </circle>
    </g>

    <!-- Goldene Ecken -->
    <path d="M52 25 h26 v10 h-16 v14 h-10 z" fill="#caa052" stroke="#8f6f34" stroke-width="1"/>
    <path d="M158 25 h-26 v10 h16 v14 h10 z" fill="#caa052" stroke="#8f6f34" stroke-width="1"/>
    <path d="M52 165 v-24 h10 v14 h16 v10 z" fill="#caa052" stroke="#8f6f34" stroke-width="1"/>
    <path d="M158 165 v-24 h-10 v14 h-16 v10 z" fill="#caa052" stroke="#8f6f34" stroke-width="1"/>

    <!-- Bookmark -->
    <path d="M140 165 L150 165 L150 180 L145 173 L140 180 Z"
          fill="#b83232" stroke="#6d1a1a" stroke-width="1"/>

    <!-- Funken (besser verteilt) -->
    <g>
      <use href="#spark" x="120" y="70">
        <animate attributeName="y" values="70;40" dur="2.5s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="2.5s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="95" y="90">
        <animate attributeName="y" values="90;55" dur="2.8s" begin="0.3s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="2.8s" begin="0.3s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="135" y="110">
        <animate attributeName="y" values="110;70" dur="3s" begin="0.6s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3s" begin="0.6s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="60" y="145">
        <animate attributeName="y" values="145;105" dur="3.2s" begin="0.2s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3.2s" begin="0.2s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="110" y="148">
        <animate attributeName="y" values="148;110" dur="3.1s" begin="1.0s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3.1s" begin="1.0s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="140" y="155">
        <animate attributeName="y" values="155;115" dur="3.4s" begin="0.4s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3.4s" begin="0.4s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="175" y="125">
        <animate attributeName="y" values="125;85" dur="3.4s" begin="0.5s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="3.4s" begin="0.5s" repeatCount="indefinite" />
      </use>
      <use href="#spark" x="75" y="50">
        <animate attributeName="y" values="50;25" dur="2.6s" begin="0.9s" repeatCount="indefinite" />
        <animate attributeName="opacity" values="0;1;0" dur="2.6s" begin="0.9s" repeatCount="indefinite" />
      </use>
    </g>

    <!-- float -->
    <animateTransform
      attributeName="transform"
      attributeType="XML"
      type="translate"
      dur="4s"
      repeatCount="indefinite"
      values="0,6.6; 0,6.6; 0,0; 0,6.6; 0,6.6"
      keyTimes="0; 0.25; 0.6; 0.95; 1"
      keySplines="0 0 1 1;
                  0.42 0 0.58 1;
                  0.42 0 0.58 1;
                  0 0 1 1"
      calcMode="spline" />
  </g>
</svg>
            </div>
            <div class="skill-compendium">
              <div id="skillList" class="skill-list"></div>
              <div id="skillEmpty" class="skill-empty">Noch keine Skills vorhanden. Wechsle in den Shop, um welche zu kaufen.</div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section id="shopView" class="view">
      <div class="game-grid">
        <div class="card">
          <div class="gacha-options" role="radiogroup" aria-label="Shop Kategorie">
            <label class="gacha-option active">
              <input type="radio" name="gachaType" value="weapon" checked>
              <span class="gacha-icon" aria-hidden="true">
                <svg viewBox="0 0 32 32" focusable="false">
                  <rect x="14" y="4" width="4" height="15" rx="2" fill="currentColor" opacity="0.85"/>
                  <rect x="10" y="17" width="12" height="3.3" rx="1.6" fill="currentColor" opacity="0.7"/>
                  <rect x="13" y="20" width="6" height="5" rx="1.5" fill="currentColor" opacity="0.85"/>
                  <circle cx="16" cy="26.5" r="2" fill="currentColor"/>
                </svg>
              </span>
              <span class="gacha-label">Waffe</span>
              <span class="gacha-remaining" data-remaining-category="weapon">--</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="armor">
              <span class="gacha-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false">
                  <path fill="currentColor" d="M12 3l7 2.8v5.4c0 4.9-3.3 9.5-7 10.3-3.7-0.8-7-5.4-7-10.3V5.8L12 3z"/>
                </svg>
              </span>
              <span class="gacha-label">Ausrüstung</span>
              <span class="gacha-remaining" data-remaining-category="armor">--</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="accessory">
              <span class="gacha-icon" aria-hidden="true">
                <svg viewBox="0 0 32 32" focusable="false">
                  <circle cx="16" cy="16" r="9" fill="none" stroke="currentColor" stroke-width="1.8"/>
                  <circle cx="16" cy="16" r="6" fill="currentColor" opacity="0.18"/>
                  <path d="M16 8 L18 14 L24 16 L18 18 L16 24 L14 18 L8 16 L14 14 Z" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round"/>
                  <circle cx="16" cy="16" r="2.4" fill="currentColor" opacity="0.85"/>
                  <path d="M13.5 6c1.6-1.4 3.4-1.4 5 0" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
                  <path d="M16 25.5v2.2" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/>
                </svg>
              </span>
              <span class="gacha-label">Accessoire</span>
              <span class="gacha-remaining" data-remaining-category="accessory">--</span>
            </label>
            <label class="gacha-option">
              <input type="radio" name="gachaType" value="skill">
              <span class="gacha-icon" aria-hidden="true">
                <svg viewBox="35 0 140 190" focusable="false">
                  <rect x="43" y="25" width="7" height="140" fill="currentColor" opacity="0.55" stroke="currentColor" stroke-width="2"/>
                  <path d="M50 25 H160 a6 6 0 0 1 6 6 V159 a6 6 0 0 1 -6 6 H50 Z" fill="none" stroke="currentColor" stroke-width="5"/>
                  <rect x="160" y="31" width="3" height="130" rx="1.5" ry="1.5" fill="currentColor" opacity="0.25" stroke="currentColor" stroke-width="1"/>
                  <circle cx="105" cy="85" r="28" fill="none" stroke="currentColor" stroke-width="4"/>
                  <circle cx="105" cy="85" r="12" fill="currentColor" opacity="0.85"/>
                  <path d="M105 72 L110 87 L125 90 L112 99 L118 115 L105 106 L92 115 L98 99 L85 90 L100 87 Z" fill="none" stroke="currentColor" stroke-width="3" stroke-linejoin="round"/>
                  <path d="M52 25 h26 v10 h-16 v14 h-10 z" fill="currentColor" opacity="0.6" stroke="currentColor" stroke-width="1"/>
                  <path d="M158 25 h-26 v10 h16 v14 h10 z" fill="currentColor" opacity="0.6" stroke="currentColor" stroke-width="1"/>
                  <path d="M52 165 v-24 h10 v14 h16 v10 z" fill="currentColor" opacity="0.6" stroke="currentColor" stroke-width="1"/>
                  <path d="M158 165 v-24 h-10 v14 h-16 v10 z" fill="currentColor" opacity="0.6" stroke="currentColor" stroke-width="1"/>
                  <path d="M140 165 h10 v15 l-5-6-5 6z" fill="currentColor" opacity="0.8" stroke="currentColor" stroke-width="1"/>
                </svg>
              </span>
              <span class="gacha-label">Skill</span>
              <span class="gacha-remaining" data-remaining-category="skill">--</span>
            </label>
          </div>
          <button id="gachaBtn" class="shop-buy-btn"><span class="emoji">🛍️</span>Item kaufen (25x Coins)</button>
          <div class="shop-latest" id="shopLatest">
            <h3>Neueste Belohnung</h3>
            <p class="shop-latest-empty" id="shopLatestEmpty">Noch keine Belohnung gezogen.</p>
          </div>
        </div>
      </div>
    </section>
    <section id="battleView" class="view">
      <div class="game-grid">
        <div class="card battle-card">
          <div id="battleSimulation" class="battle-sim hidden" aria-live="polite">
            <div class="battle-header">
              <h3 id="battleTitle"></h3>
            </div>
            <div class="battle-arena" id="battleArena">
              <div class="arena-particles" aria-hidden="true">
                <span style="left:10%; animation-delay:0s;"></span>
                <span style="left:25%; animation-delay:0.8s;"></span>
                <span style="left:40%; animation-delay:1.5s;"></span>
                <span style="left:55%; animation-delay:2.3s;"></span>
                <span style="left:70%; animation-delay:3.1s;"></span>
                <span style="left:82%; animation-delay:3.8s;"></span>
                <span style="left:90%; animation-delay:4.6s;"></span>
                <span style="left:5%; animation-delay:5.2s;"></span>
              </div>
              <div class="fighter knight" id="battleKnight">
                <img id="battleKnightSprite" class="fighter-sprite" src="assets/knight_idle_blink.svg" alt="Shortcut Knight">
                <div class="battle-weapon-slot weapon-left" id="battleWeaponSlot1" data-empty="true" aria-hidden="true"></div>
                <div class="battle-weapon-slot weapon-right" id="battleWeaponSlot2" data-empty="true" aria-hidden="true"></div>
              </div>
              <div class="fighter enemy goblin" id="battleEnemy">
                <img id="battleEnemySprite" class="fighter-sprite" src="assets/enemy-kobold.png" alt="Goblin">
              </div>
            </div>
            <div class="battle-skill-bar" id="battleSkillBar" hidden></div>
            <div class="modal-battle-overview">
              <div class="modal-battle-card hero" id="modalHeroCard">
                <div class="modal-card-head">
                  <div class="modal-card-top">
                    <h4 id="modalHeroName">Shortcut Knight</h4>
                    <div class="modal-card-hp hero">
                      <div class="hp-track">
                        <div class="hp-fill hero" id="heroHpFill"></div>
                      </div>
                      <span class="hp-value" id="heroHpValue"></span>
                    </div>
                  </div>
                </div>
                <div class="modal-card-stats">
                  <span class="battle-stat-badge atk">ATK<strong id="modalHeroAtk">1</strong></span>
                  <span class="battle-stat-badge def">DEF<strong id="modalHeroDef">0</strong></span>
                  <span class="battle-stat-badge meta" id="modalHeroVarBadge">Var ±0</span>
                  <span class="battle-stat-badge meta" id="modalHeroCritBadge">Krit 0%</span>
                </div>
              </div>
              <div class="modal-battle-card enemy" id="modalEnemyCard">
                <div class="modal-card-head">
                  <div class="modal-card-top">
                    <h4 id="modalEnemyName">Kobold</h4>
                    <div class="modal-card-hp enemy">
                      <div class="hp-track">
                        <div class="hp-fill enemy" id="enemyHpFill"></div>
                      </div>
                      <span class="hp-value" id="enemyHpValue"></span>
                    </div>
                  </div>
                </div>
                <p class="modal-card-meta" id="modalEnemyMeta">Details folgen.</p>
                <div class="modal-card-stats">
                  <span class="battle-trait" id="modalEnemyTrait">Unbekannt</span>
                  <span class="battle-stat-badge atk">ATK<strong id="modalEnemyAtk">0</strong></span>
                  <span class="battle-stat-badge def">DEF<strong id="modalEnemyDef">0</strong></span>
                  <span class="battle-stat-badge meta" id="modalEnemyVarBadge">Var ±0</span>
                  <span class="battle-stat-badge meta" id="modalEnemyCritBadge">Krit 0%</span>
                </div>
              </div>
            </div>
            <div class="battle-foot">
              <p class="battle-result" id="battleResult"></p>
              <div class="battle-reward" id="battleReward" hidden>
                <div class="battle-reward-chest">
                  <object id="battleRewardChest" class="chest-svg" type="image/svg+xml" data="assets/chest.svg" aria-label="Belohnungstruhe"></object>
                  <div class="battle-reward-coins" aria-hidden="true">
                    <span></span>
                    <span></span>
                    <span></span>
                    <span></span>
                    <span></span>
                  </div>
                </div>
                <div class="battle-reward-copy">
                  <strong id="battleRewardText">+0 Coins</strong>
                  <small id="battleRewardBreakdown">Basis +0 • Skills +0</small>
                </div>
              </div>
              <button type="button" class="battle-next hidden" id="battleNextBtn">Nächstes Level starten</button>
            </div>
          </div>
          <div class="battle-overview">
              <div class="battle-side hero">
                <div class="battle-side-head">
                  <div>
                    <span class="battle-side-label">Held</span>
                    <h3>Shortcut Knight</h3>
                  </div>
                </div>
              <div class="battle-portrait hero">
                <span class="battle-portrait-icon"><img src="assets/knight_idle_fin.svg" alt="Shortcut Knight"></span>
              </div>
              <div class="battle-statline">
                <span class="battle-stat-badge atk">ATK<strong id="battleHeroAtkStat">1</strong></span>
                <span class="battle-stat-badge def">DEF<strong id="battleHeroDefStat">0</strong></span>
                <span class="battle-stat-badge">HP<strong id="battleHeroHpStat">0</strong></span>
              </div>
              <div class="battle-gear">
                <span class="battle-gear-label">Gear</span>
                <ul class="battle-gear-list" id="battleHeroGearList"></ul>
              </div>
            </div>
            <div class="battle-center">
              <div class="battle-crest">
                <span class="battle-crest-label">VS</span>
                <p>Wähle deinen Kampf und nutze Skills in der Schlacht.</p>
              </div>
              <div class="battle-center-actions">
                <div class="battle-buttons" id="battleButtons"></div>
                <div class="battle-log" id="battleLog"></div>
              </div>
            </div>
            <div class="battle-side enemy">
              <div class="battle-side-head">
                <div>
                  <span class="battle-side-label">Nächster Gegner</span>
                  <h3 id="battleEnemyPreviewName">Goblin</h3>
                </div>
                <div>
                  <span class="battle-side-tier" id="battleEnemyPreviewLevel">Rang 1</span>
                  <span class="battle-trait" id="battleEnemyTrait">Unbekannt</span>
                </div>
              </div>
              <div class="battle-portrait enemy">
                <span class="battle-portrait-icon">
                  <img id="battleEnemyPreviewIcon" src="assets/enemy-kobold.png" alt="Kobold">
                </span>
              </div>
              <div class="battle-statline">
                <span class="battle-stat-badge atk">ATK<strong id="battleEnemyAtkStat">0</strong></span>
                <span class="battle-stat-badge def">DEF<strong id="battleEnemyDefStat">0</strong></span>
                <span class="battle-stat-badge">HP<strong id="battleEnemyHpStat">0</strong></span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section id="reportView" class="view">
      <div class="game-grid">
        <div class="card report-card">
          <div class="report-header">
            <div class="report-header-info">
              <h2>📊 Lern-Report</h2>
              <p class="report-meta" id="reportTimestamp">Noch kein Report erstellt.</p>
            </div>
            <div class="report-header-actions">
              <button id="reportGenerateBtn" type="button" class="report-action primary">📊 Report aktualisieren</button>
              <div class="report-secondary-actions">
                <button id="reportExportBtn" type="button" class="report-action ghost">💾 Exportieren</button>
                <button id="reportImportBtn" type="button" class="report-action ghost">📂 Importieren</button>
                <button id="reportResetBtn" type="button" class="report-action danger">🗑️ Spielfortschritt löschen</button>
              </div>
            </div>
          </div>
          <input id="reportImportInput" type="file" accept="application/json" hidden>
          <div class="report-tabs">
            <button type="button" class="report-tab active" data-report-tab="overview">📌 Überblick</button>
            <button type="button" class="report-tab" data-report-tab="combos">⌨️ Kombinationen</button>
            <button type="button" class="report-tab" data-report-tab="sections">📚 Abschnitte</button>
          </div>
          <div id="reportContent" class="report-content">
            <p class="small">Noch keine Daten vorhanden. Bearbeite Abschnitte und Kämpfe, um Statistiken zu sammeln.</p>
          </div>
        </div>
      </div>
    </section>
  <script src="apexcharts.min.js"></script>
  <script src="sections-data.js"></script>
  <script src="skill-hotkeys.js"></script>
  <script>
    const STORAGE_KEY = "shortcutRitter_v1";
    const COINS_PER_ACTION = 10;
    const COINS_PER_ACTION_AFTER_RESET = 5;
    const INITIAL_SECTION_UNLOCK = 10;
    const CONSTANTS_DEBUG = false;
    const RUNEN_AMULET_KEY = "runen_amulet";
    const LEBENS_RING_KEY = "lebens_ring";
    const GLUECKS_RING_KEY = "gluecks_ring";
    const STORM_SKILL_KEY = "sturm_hieb";
    const STORM_STRIKE_SVG = /* html */ `
      <svg class="storm-strike-svg" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <g class="storm-clouds">
          <ellipse class="storm-cloud cloud-1" cx="78" cy="56" rx="58" ry="24"></ellipse>
          <ellipse class="storm-cloud cloud-2" cx="120" cy="64" rx="64" ry="28"></ellipse>
          <ellipse class="storm-cloud cloud-3" cx="102" cy="80" rx="48" ry="20"></ellipse>
        </g>
        <g class="storm-rain">
          <line x1="70" y1="94" x2="60" y2="130" style="animation-delay:0.1s;"></line>
          <line x1="90" y1="100" x2="85" y2="136" style="animation-delay:0.15s;"></line>
          <line x1="110" y1="96" x2="105" y2="140" style="animation-delay:0.2s;"></line>
          <line x1="132" y1="102" x2="130" y2="142" style="animation-delay:0.22s;"></line>
        </g>
        <path class="storm-bolt-echo" d="M114 22 L90 96 L118 96 L94 168 L156 86 L126 86 L150 22 Z"></path>
        <path class="storm-bolt" d="M110 18 L88 92 L118 92 L92 166 L152 84 L122 84 L144 18 Z"></path>
        <circle class="storm-glow" cx="120" cy="140" r="36"></circle>
        <circle class="storm-glow-outline" cx="120" cy="140" r="52"></circle>
      </svg>
    `;
    const SHIELD_SKILL_KEY = "schutzwall";
    const SHIELD_WALL_MAX_CHARGES = 5;
    const FRENZY_SKILL_KEY = "kampfrausch";
    const SKILL_COOLDOWN_DEFAULT = 5;
    const SHIELD_WALL_SVG = /* html */ `
      <svg viewBox="0 -40 180 260" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path class="shield-wall-shape" d="M90 16 L160 60 V156 C160 190 118 214 90 226 C62 214 20 190 20 156 V60z"></path>
        <path class="shield-wall-rune rune-1" d="M54 86 Q90 56 126 86"></path>
        <path class="shield-wall-rune rune-2" d="M48 128 Q90 98 132 128"></path>
        <path class="shield-wall-rune rune-3" d="M62 162 Q90 142 118 162"></path>
        <circle class="shield-wall-spark" cx="60" cy="70" r="4"></circle>
        <circle class="shield-wall-spark spark-2" cx="122" cy="64" r="4.8"></circle>
        <circle class="shield-wall-spark spark-3" cx="90" cy="110" r="3.2"></circle>
      </svg>
    `;
    const FRENZY_AURA_SVG = /* html */ `
      <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <circle class="frenzy-surge" cx="100" cy="120" r="60"></circle>
        <circle class="frenzy-ring" cx="100" cy="100" r="70"></circle>
        <circle class="frenzy-ring ring-2" cx="100" cy="100" r="50"></circle>
        <circle class="frenzy-spark" cx="70" cy="120" r="6"></circle>
        <circle class="frenzy-spark spark-2" cx="130" cy="110" r="5"></circle>
        <circle class="frenzy-spark spark-3" cx="100" cy="70" r="4"></circle>
      </svg>
    `;
    const HEALING_SKILL_KEY = "lichtbrunnen";
    const HEALING_WAVE_SVG = /* html */ `
      <svg viewBox="0 0 220 220" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <circle class="healing-ring" cx="110" cy="110" r="70"></circle>
        <circle class="healing-ring ring-2" cx="110" cy="110" r="90"></circle>
        <circle class="healing-glow" cx="110" cy="110" r="50"></circle>
        <circle class="healing-spark" cx="80" cy="120" r="6"></circle>
        <circle class="healing-spark spark-2" cx="140" cy="100" r="5"></circle>
        <circle class="healing-spark spark-3" cx="110" cy="70" r="4"></circle>
      </svg>
    `;
    const RUNEN_AMULET_TIER_BONUS = Object.freeze({ 1: 5, 2: 10, 3: 15, 4: 20 });
    const RUNEN_AMULET_DYNAMIC_CAP = 55;
    const LEBENS_RING_HP_BY_TIER = Object.freeze({ 1: 20, 2: 40, 3: 60, 4: 80, 5: 120 });
    const GLUECKS_RING_CRIT_BY_TIER = Object.freeze({ 1: 1, 2: 3, 3: 5, 4: 8, 5: 12 });
    const BASE_ATK = 1;
    const BASE_DEF = 0;
    const BASE_HP = 12;
    const HP_PER_DEF = 6;
    const MAX_ITEM_TIER = 5;
    const MAX_SKILL_TIER = 6;
    const BATTLE_LEVEL_REWARDS = Object.freeze({
      1: 1,
      2: 1,
      3: 2,
      4: 2,
      5: 3,
      6: 4,
      7: 4,
      8: 4,
      9: 5,
      10: 5,
      11: 100
    });
    const DEFAULT_SKILL_INPUT_MODE = "hotkeys"; // set to "legacy" to fall back to 1-9 keys
    // Vollständiges Standardset zur Offline-Nutzung, falls das Laden aus skill-hotkeys.json fehlschlägt.
    const INLINE_SKILL_HOTKEYS = Array.isArray(window.SKILL_HOTKEY_BLUEPRINTS) ? window.SKILL_HOTKEY_BLUEPRINTS : [];
    const skillHotkeyPool = [];
    let skillHotkeyQueue = [];
    const activeSkillKeys = new Set();
    const activeSkillComboLatch = new Set();
    let battleSkillStates = [];
    let battleSkillUseCount = 0;
let shieldWallOverlayEl = null;
let shieldWallCounterEl = null;
let shieldWallRemoveTimer = null;
let frenzyAuraEl = null;
    const VALID_MODIFIER_KEYS = new Map([
      ["control", "CTRL"],
      ["ctrl", "CTRL"],
      ["alt", "ALT"],
      ["altgraph", "ALT"],
      ["shift", "SHIFT"],
      ["meta", "WIN"],
      ["win", "WIN"],
      ["escape", "ESC"],
      ["esc", "ESC"]
    ]);
    const SPECIAL_KEY_ALIASES = new Map([
      ["tab", "TAB"],
      ["enter", "ENTER"],
      ["return", "ENTER"],
      ["space", "SPACE"],
      ["spacebar", "SPACE"],
      ["home", "HOME"],
      ["end", "END"],
      ["pageup", "PAGEUP"],
      ["pagedown", "PAGEDOWN"],
      ["insert", "INS"],
      ["ins", "INS"],
      ["delete", "DEL"],
      ["del", "DEL"],
      ["backspace", "BACKSPACE"],
      ["f1", "F1"], ["f2", "F2"], ["f3", "F3"], ["f4", "F4"], ["f5", "F5"],
      ["f6", "F6"], ["f7", "F7"], ["f8", "F8"], ["f9", "F9"], ["f10", "F10"],
      ["f11", "F11"], ["f12", "F12"]
    ]);
    const SPECIAL_KEY_DISPLAY = {
      TAB: "Tab",
      ENTER: "Enter",
      SPACE: "Space",
      HOME: "Home",
      END: "Ende",
      PAGEUP: "Bild↑",
      PAGEDOWN: "Bild↓",
      INS: "Einfg",
      DEL: "Entf",
      BACKSPACE: "Backspace",
      F1: "F1",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      F10: "F10",
      F11: "F11",
      F12: "F12"
    };

    function normalizeHotkeyToken(token) {
      if (!token) return null;
      const trimmed = String(token).trim();
      if (!trimmed) return null;
      const lower = trimmed.toLowerCase();
      if (VALID_MODIFIER_KEYS.has(lower)) return VALID_MODIFIER_KEYS.get(lower);
      if (SPECIAL_KEY_ALIASES.has(lower)) return SPECIAL_KEY_ALIASES.get(lower);
      if (lower.length === 1 && /[a-z0-9]/.test(lower)) {
        return lower.toUpperCase();
      }
      return null;
    }

    function formatHotkeyForDisplay(sequence) {
      return sequence.map(part => {
        switch (part) {
          case "CTRL": return "Ctrl";
          case "ALT": return "Alt";
          case "SHIFT": return "Shift";
          case "WIN": return "Win";
          case "ESC": return "Esc";
          default:
            if (SPECIAL_KEY_DISPLAY[part]) return SPECIAL_KEY_DISPLAY[part];
            return part.toUpperCase();
        }
      }).join(" + ");
    }

    function applySkillHotkeyConfig(entries) {
      skillHotkeyPool.length = 0;
      if (!Array.isArray(entries)) return;
      entries.forEach(entry => {
        if (!entry || !Array.isArray(entry.keys)) return;
        const rawTokens = entry.keys;
        const normalizedTokens = [];
        rawTokens.forEach(token => {
          const normalized = normalizeHotkeyToken(token);
          if (normalized && !normalizedTokens.includes(normalized)) {
            normalizedTokens.push(normalized);
          }
        });
        if (!normalizedTokens.length) return;
        const hasModifier = normalizedTokens.some(token => token.length > 1 || ["CTRL", "ALT", "SHIFT", "WIN", "ESC"].includes(token));
        if (!hasModifier && normalizedTokens.length === 1) return;
        const comboId = [...normalizedTokens].sort().join("+");
        const label = typeof entry.label === "string" && entry.label.trim() ? entry.label.trim() : normalizedTokens.join(" + ");
        skillHotkeyPool.push({
          label,
          sequence: normalizedTokens,
          comboId,
          display: formatHotkeyForDisplay(normalizedTokens),
          comboSet: new Set(normalizedTokens)
        });
      });
      refillSkillHotkeyQueue();
    }

    function refillSkillHotkeyQueue() {
      if (!skillHotkeyPool.length) {
        skillHotkeyQueue = [];
        return;
      }
      skillHotkeyQueue = shuffleArray(skillHotkeyPool.slice());
    }

    function getRandomSkillCombo(bannedComboIds = null) {
      if (!skillHotkeyPool.length) return null;
      if (!skillHotkeyQueue.length) refillSkillHotkeyQueue();
      const attempts = Math.max(1, skillHotkeyQueue.length);
      for (let i = 0; i < attempts; i += 1) {
        const combo = skillHotkeyQueue.shift();
        if (!combo) break;
        const isBanned = bannedComboIds && bannedComboIds.has(combo.comboId);
        skillHotkeyQueue.push(combo);
        if (!isBanned) {
          return combo;
        }
      }
      const fallbackPool = bannedComboIds && bannedComboIds.size
        ? skillHotkeyPool.filter(combo => !bannedComboIds.has(combo.comboId))
        : skillHotkeyPool;
      if (!fallbackPool.length) return null;
      return fallbackPool[Math.floor(Math.random() * fallbackPool.length)];
    }

    function assignRandomCombo(entry, usedComboIds = null, previousComboId = null) {
      const banned = new Set();
      if (previousComboId) banned.add(previousComboId);
      if (usedComboIds && usedComboIds.size) {
        usedComboIds.forEach(id => banned.add(id));
      }
      const combo = getRandomSkillCombo(banned);
      if (!combo) {
        entry.mode = "legacy";
        entry.displayLabel = `${entry.skill.name} (Tier ${entry.skill.tier})`;
        entry.hotkeyDisplay = "?";
        entry.comboSet = new Set();
        entry.comboId = null;
        return;
      }
      entry.mode = "combo";
      entry.displayLabel = combo.label;
      entry.hotkeyDisplay = combo.display;
      entry.comboId = combo.comboId;
      entry.comboSet = new Set(combo.comboSet);
      entry.comboSequence = combo.sequence.slice();
    }

    function normalizeEventKey(key) {
      if (!key) return null;
      const lower = key.toLowerCase();
      if (VALID_MODIFIER_KEYS.has(lower)) return VALID_MODIFIER_KEYS.get(lower);
      if (SPECIAL_KEY_ALIASES.has(lower)) return SPECIAL_KEY_ALIASES.get(lower);
      if (lower.length === 1 && /[a-z0-9]/.test(lower)) {
        return lower.toUpperCase();
      }
      return null;
    }

    function resetSkillKeyTracking() {
      activeSkillKeys.clear();
      activeSkillComboLatch.clear();
    }

    function initSkillHotkeys() {
      applySkillHotkeyConfig(INLINE_SKILL_HOTKEYS);
      if (DEFAULT_SKILL_INPUT_MODE === "hotkeys" && skillHotkeyPool.length && battleSkillStates.length) {
        const used = new Set();
        battleSkillStates.forEach(entry => {
          if (entry && entry.skill) {
            assignRandomCombo(entry, used);
            if (entry.comboId) used.add(entry.comboId);
          }
        });
        resetSkillKeyTracking();
        renderBattleSkillBar();
      }
    }

    initSkillHotkeys();

    const DEFAULT_EQUIPMENT = Object.freeze({
      gloves: null,
      helm: null,
      necklace: null,
      boots: null,
      weapon: null,
      offhand: null,
      ring_left: null,
      ring_right: null
    });

    const state = {
      coins: 0,
      atk: BASE_ATK,
      def: BASE_DEF,
      hp: 0,
      critDamagePercent: 0,
      items: [],
      skills: [],
      equipment: { ...DEFAULT_EQUIPMENT },
      sectionClears: {},
      sectionResets: {},
      sectionReports: {},
      comboStats: {},
      sectionsUnlocked: INITIAL_SECTION_UNLOCK,
      gachaPreference: "weapon",
      battleUnlocked: 1,
      battleClears: {},
      lastShopPurchase: null
    };
    function normalizeStateShape() {
      if (!state.gachaPreference) state.gachaPreference = "weapon";
      if (!Array.isArray(state.items)) state.items = [];
      if (!Number.isFinite(state.critDamagePercent)) state.critDamagePercent = 0;
      if (!Array.isArray(state.skills)) state.skills = [];
      if (typeof state.equipment !== "object" || !state.equipment) {
        state.equipment = { ...DEFAULT_EQUIPMENT };
      } else {
        Object.keys(DEFAULT_EQUIPMENT).forEach(slot => {
          if (!(slot in state.equipment)) {
            state.equipment[slot] = null;
          }
        });
      }
      if (typeof state.sectionClears !== "object" || !state.sectionClears) state.sectionClears = {};
      if (typeof state.sectionResets !== "object" || !state.sectionResets) state.sectionResets = {};
      if (typeof state.sectionReports !== "object" || !state.sectionReports) state.sectionReports = {};
      if (typeof state.comboStats !== "object" || !state.comboStats) state.comboStats = {};
      if (typeof state.battleClears !== "object" || !state.battleClears) state.battleClears = {};
      if (typeof state.battleUnlocked !== "number" || !Number.isFinite(state.battleUnlocked)) {
        state.battleUnlocked = 1;
      } else {
        state.battleUnlocked = Math.max(1, Math.floor(state.battleUnlocked));
      }
      if (typeof state.lastShopPurchase !== "object" || state.lastShopPurchase === null) {
        state.lastShopPurchase = null;
      }
    }

    function loadState() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        try {
          const saved = JSON.parse(raw);
          Object.assign(state, saved);
        } catch (err) {
          console.warn("State konnte nicht geladen werden", err);
        }
      }
      normalizeStateShape();
    }

    loadState();

    function saveState() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function exportGameState() {
      try {
        normalizeStateShape();
        const payload = JSON.stringify(state, null, 2);
        const stamp = new Date().toISOString().replace(/[:.]/g, "-");
        const filename = `shortcut-ritter-save-${stamp}.json`;
        const blob = new Blob([payload], { type: "application/json" });
        const link = document.createElement("a");
        const downloadUrl = URL.createObjectURL(blob);
        link.href = downloadUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(downloadUrl);
      } catch (err) {
        console.error("Export fehlgeschlagen", err);
        alert("Export fehlgeschlagen. Siehe Konsole für Details.");
      }
    }

    function importGameState(nextState) {
      if (!nextState || typeof nextState !== "object") {
        throw new Error("Ungültiger Spielstand.");
      }
      Object.assign(state, nextState);
      normalizeStateShape();
      saveState();
      updateUI();
      updateOverallSummary();
      renderReport();
    }
    const coinTop = document.getElementById("coinTop");
    const atkDisplay = document.getElementById("atkDisplay");
    const defDisplay = document.getElementById("defDisplay");
    const itemsDisplay = document.getElementById("itemsDisplay");
    const shopLatest = document.getElementById("shopLatest");
    const shopLatestEmpty = document.getElementById("shopLatestEmpty");
    const heroAvatar = document.getElementById("heroAvatar");
    const heroAvatarImage = document.getElementById("heroAvatarImage");
    const hpDisplay = document.getElementById("hpDisplay");
    const autoEquipBtn = document.getElementById("autoEquipBtn");
    const unequipAllBtn = document.getElementById("unequipAllBtn");
    const equipmentSlots = document.querySelectorAll("[data-equip-slot]");
    const equipmentSlotMap = Object.create(null);
    equipmentSlots.forEach(slot => {
      if (!slot || !slot.dataset) return;
      equipmentSlotMap[slot.dataset.equipSlot] = slot;
    });
    const equipmentLayout = document.querySelector(".equipment-layout");
    const inventoryList = document.getElementById("inventoryList");
    const inventoryFilterEmpty = document.getElementById("inventoryFilterEmpty");
    const inventoryFilterButtons = document.querySelectorAll("[data-inventory-filter]");
    const DEFAULT_INVENTORY_FILTER = "weapon";
    let currentInventoryFilter = DEFAULT_INVENTORY_FILTER;
    let inventoryNeedsResort = true;
    let currentInventoryOrder = [];
    const skillList = document.getElementById("skillList");
    const skillEmpty = document.getElementById("skillEmpty");
    const sectionTabsHost = document.getElementById("sectionTabs");
    const learnSectionsHost = document.getElementById("learnSections");
    const overallSummary = document.getElementById("overallSummary");
    let allCheckables = [];
    let currentDragValue = "";
    const SECTION_BLUEPRINTS = Array.isArray(window.LEARN_SECTION_BLUEPRINTS) ? window.LEARN_SECTION_BLUEPRINTS : [];
    const PROMPT_META_MAP = buildPromptMetaMap();
    const fastPacedSections = [];
    let fastPacedInitIndex = 0;
    const memoryGameControllers = new Map();
    const inputHintRegistry = new Set();

    function normalizePromptKey(label) {
      if (typeof label !== "string") return "";
      return label
        .trim()
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z0-9+]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function registerPromptMeta(map, label, combo) {
      const key = normalizePromptKey(label);
      if (!key) return;
      if (!map[key]) {
        map[key] = {
          label: typeof label === "string" ? label.trim() : "",
          shortcut: ""
        };
      }
      const entry = map[key];
      const trimmedLabel = typeof label === "string" ? label.trim() : "";
      if (trimmedLabel && (!entry.label || trimmedLabel.length < entry.label.length)) {
        entry.label = trimmedLabel;
      }
      const trimmedCombo = typeof combo === "string" ? combo.trim() : "";
      if (trimmedCombo && !entry.shortcut) {
        entry.shortcut = trimmedCombo;
      }
    }

    function buildPromptMetaMap() {
      const map = Object.create(null);
      if (!Array.isArray(SECTION_BLUEPRINTS)) return map;
      SECTION_BLUEPRINTS.forEach(section => {
        if (!section) return;
        (section.tasks || []).forEach(task => {
          if (!task) return;
          registerPromptMeta(map, task.prompt, task.answer || task.hint);
          if (Array.isArray(task.targets)) {
            task.targets.forEach(target => {
              if (!target) return;
              registerPromptMeta(map, target.label, target.answer);
            });
          }
        });
        if (section.memoryGame && Array.isArray(section.memoryGame.pairs)) {
          section.memoryGame.pairs.forEach(pair => {
            if (!pair || !Array.isArray(pair.cards)) return;
            const [action, combo] = pair.cards;
            registerPromptMeta(map, action, combo);
          });
        }
        if (section.fastPaced && Array.isArray(section.fastPaced.combos)) {
          section.fastPaced.combos.forEach(entry => {
            if (!entry) return;
            registerPromptMeta(map, entry.label, entry.combo);
          });
        }
      });
      return map;
    }

    function getPromptMeta(prompt) {
      const key = normalizePromptKey(prompt);
      if (key && PROMPT_META_MAP[key]) return PROMPT_META_MAP[key];
      const fallback = typeof prompt === "string" ? prompt.trim() : "";
      return { label: fallback, shortcut: "" };
    }

    function getPromptShortcut(prompt) {
      return getPromptMeta(prompt).shortcut || "";
    }

    function formatPromptLabel(prompt) {
      const meta = getPromptMeta(prompt);
      const label = meta.label || (typeof prompt === "string" ? prompt : "");
      return meta.shortcut ? `${label} (${meta.shortcut})` : label;
    }

    function buildComboFallbackEntries(rows) {
      const map = Object.create(null);
      rows.forEach(row => {
        const normKey = normalizePromptKey(row.prompt);
        if (!normKey) return;
        const meta = getPromptMeta(row.prompt);
        if (!map[normKey]) {
          map[normKey] = {
            key: normKey,
            label: meta.label || row.prompt,
            shortcut: meta.shortcut || "",
            attempts: 0,
            misses: 0,
            history: []
          };
        }
        const entry = map[normKey];
        if (meta.label && (!entry.label || meta.label.length < entry.label.length)) {
          entry.label = meta.label;
        }
        if (meta.shortcut && !entry.shortcut) {
          entry.shortcut = meta.shortcut;
        }
        entry.attempts += row.attempts || 0;
        entry.misses += row.misses || 0;
        if (Array.isArray(row.history)) {
          row.history.forEach((hist, idx) => {
            entry.history.push({
              attempt: typeof hist.attempt === "number" ? hist.attempt : idx + 1,
              success: hist.success === false ? false : true,
              timestamp: typeof hist.timestamp === "number" ? hist.timestamp : 0
            });
          });
        }
      });
      return Object.values(map).map(entry => {
        if (entry.history.length) {
          entry.history = entry.history
            .slice()
            .sort((a, b) => (a.timestamp - b.timestamp) || (a.attempt - b.attempt))
            .map((item, idx) => ({
              attempt: idx + 1,
              success: item.success,
              timestamp: item.timestamp
            }));
        }
        return entry;
      });
    }

    function ensureComboStatsMap() {
      if (typeof state.comboStats !== "object" || !state.comboStats) {
        state.comboStats = {};
      }
      return state.comboStats;
    }

    function updateComboStats(prompt, sectionId, isCorrect, attemptTimestamp) {
      const key = normalizePromptKey(prompt);
      if (!key) return;
      const meta = getPromptMeta(prompt);
      const map = ensureComboStatsMap();
      if (!map[key]) {
        map[key] = {
          key,
          label: meta.label || prompt,
          shortcut: meta.shortcut || "",
          attempts: 0,
          misses: 0,
          history: []
        };
      }
      const entry = map[key];
      if (meta.label && (!entry.label || meta.label.length < entry.label.length)) {
        entry.label = meta.label;
      }
      if (meta.shortcut && !entry.shortcut) {
        entry.shortcut = meta.shortcut;
      }
      const attemptNumber = entry.attempts + 1;
      entry.attempts = attemptNumber;
      if (!isCorrect) {
        entry.misses += 1;
      }
      entry.history.push({
        attempt: attemptNumber,
        success: Boolean(isCorrect),
        sectionId: sectionId || null,
        timestamp: attemptTimestamp || Date.now()
      });
    }

    window.dumpComboStats = function dumpComboStats() {
      const map = ensureComboStatsMap();
      const list = Object.values(map).map(entry => ({
        key: entry.key,
        label: entry.label,
        shortcut: entry.shortcut,
        attempts: entry.attempts || 0,
        misses: entry.misses || 0,
        accuracy: entry.attempts ? Math.round(((entry.attempts - (entry.misses || 0)) / entry.attempts) * 100) : 0
      }));
      if (console && typeof console.table === "function") {
        console.table(list);
      } else if (console && typeof console.log === "function") {
        console.log(list);
      }
      return list;
    };

    function getUnlockedSectionLimit() {
      const total = SECTION_BLUEPRINTS.length;
      const minimum = Math.min(total, INITIAL_SECTION_UNLOCK);
      let unlocked = Number.isFinite(state.sectionsUnlocked) ? state.sectionsUnlocked : minimum;
      if (unlocked < minimum) unlocked = minimum;
      if (unlocked > total) unlocked = total;
      state.sectionsUnlocked = unlocked;
      return unlocked;
    }

    function updateLockedSectionsHint(hasLockedSections) {
      if (!learnSectionsHost) return;
      const existing = learnSectionsHost.querySelector(".locked-sections-hint");
      if (existing) existing.remove();
    }

    function resolveSectionId(section, fallbackIndex) {
      if (section && section.id !== undefined && section.id !== null && section.id !== "") {
        return String(section.id);
      }
      return String(fallbackIndex + 1);
    }

    function createSectionTab(section, sectionId, isActive) {
      const tab = document.createElement("button");
      tab.type = "button";
      tab.className = "section-tab";
      if (isActive) tab.classList.add("active");
      tab.dataset.goto = sectionId;
      tab.dataset.sectionId = sectionId;
      const baseLabel = section && section.tabLabel ? section.tabLabel : `Abschnitt ${sectionId}`;
      tab.dataset.baseLabel = baseLabel;
      const labelSpan = document.createElement("span");
      labelSpan.className = "section-tab-label";
      labelSpan.textContent = baseLabel;
      tab.appendChild(labelSpan);
      updateTabCompletionState(tab, sectionId);
      return tab;
    }

    function shuffleArray(source) {
      if (!Array.isArray(source)) return [];
      const array = source.slice();
      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
      }
      return array;
    }

    function createHourglassIcon() {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.setAttribute("class", "fast-paced-hourglass");
      const frame = document.createElementNS("http://www.w3.org/2000/svg", "path");
      frame.setAttribute("d", "M7 3h10M7 21h10M9 3v5l5 4-5 4v5M15 3v5l-5 4 5 4v5");
      frame.setAttribute("fill", "none");
      frame.setAttribute("stroke-linecap", "round");
      frame.setAttribute("stroke-linejoin", "round");
      const sandTop = document.createElementNS("http://www.w3.org/2000/svg", "path");
      sandTop.setAttribute("d", "M10 8h4l-2 2z");
      sandTop.setAttribute("class", "hourglass-sand");
      const sandBottom = document.createElementNS("http://www.w3.org/2000/svg", "path");
      sandBottom.setAttribute("d", "M12 16l-2-2h4z");
      sandBottom.setAttribute("class", "hourglass-sand");
      svg.appendChild(frame);
      svg.appendChild(sandTop);
      svg.appendChild(sandBottom);
      return svg;
    }

    function sectionCompleted(sectionId) {
      if (!sectionId) return false;
      const id = String(sectionId);
      return Boolean(state.sectionClears && state.sectionClears[id]);
    }

    function deriveCompletedLabel(baseLabel) {
      if (!baseLabel) return baseLabel;
      const match = baseLabel.match(/\d+/);
      return match ? match[0] : baseLabel;
    }

    function updateTabCompletionState(tab, sectionId) {
      if (!tab) return;
      const labelSpan = tab.querySelector(".section-tab-label");
      const baseLabel = tab.dataset.baseLabel || tab.textContent || "";
      const completed = sectionCompleted(sectionId);
      if (labelSpan) {
        labelSpan.textContent = completed ? deriveCompletedLabel(baseLabel) : baseLabel;
      }
      tab.classList.toggle("completed", completed);
    }

    function updateSectionCompletionClasses() {
      document.querySelectorAll(".section").forEach(section => {
        const sectionId = section.dataset.section;
        const header = section.querySelector(".card-header");
        if (header) {
          header.classList.toggle("completed", sectionCompleted(sectionId));
        }
      });
      document.querySelectorAll(".section-tab").forEach(tab => {
        updateTabCompletionState(tab, tab.dataset.goto || tab.dataset.sectionId);
      });
    }

    function reshuffleDndSection(section) {
      if (!section) return;
      const pools = section.querySelectorAll(".dnd-pool");
      pools.forEach(pool => {
        const tokens = Array.from(pool.querySelectorAll(".dnd-token"));
        shuffleArray(tokens).forEach(node => pool.appendChild(node));
      });
      const wraps = section.querySelectorAll(".dnd-targets");
      wraps.forEach(wrapper => {
        const targets = Array.from(wrapper.querySelectorAll(".dnd-target"));
        shuffleArray(targets).forEach(node => wrapper.appendChild(node));
      });
    }

    function buildSelectField(task) {
      const select = document.createElement("select");
      select.dataset.answer = task && task.answer ? task.answer : "";
      if (task && task.prompt) select.dataset.prompt = task.prompt;
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = task && task.placeholderOption ? task.placeholderOption : "-- wählen --";
      select.appendChild(placeholder);
      const options = Array.isArray(task && task.options) ? task.options : [];
      options.forEach(optionValue => {
        if (optionValue === null || optionValue === undefined) return;
        const optionEl = document.createElement("option");
        if (typeof optionValue === "string") {
          optionEl.value = optionValue;
          optionEl.textContent = optionValue;
        } else {
          const value = optionValue.value || optionValue.label || "";
          optionEl.value = value;
          optionEl.textContent = optionValue.label || optionValue.value || "";
        }
        select.appendChild(optionEl);
      });
      return select;
    }

    function buildInputField(task) {
      const wrapper = document.createElement("div");
      wrapper.className = "input-with-hint";
      const input = document.createElement("input");
      input.type = "text";
      input.dataset.answer = task && task.answer ? task.answer : "";
      if (task && task.prompt) input.dataset.prompt = task.prompt;
      input.autocomplete = "off";
      if (task && task.hint) {
        input.dataset.hint = task.hint;
      }
      wrapper.appendChild(input);
      if (task && task.hint) {
        const overlay = document.createElement("span");
        overlay.className = "input-hint-overlay";
        overlay.textContent = task.hint;
        const measure = document.createElement("span");
        measure.className = "input-hint-measure";
        wrapper.appendChild(overlay);
        wrapper.appendChild(measure);
      }
      return wrapper;
    }

    function buildTaskField(task) {
      if (!task) return null;
      const label = document.createElement("label");
      label.className = "task-field";
      const question = document.createElement("span");
      question.className = "question-text";
      question.textContent = task.prompt || "";
      label.appendChild(question);
      let control = null;
      if (task.type === "select") {
        control = buildSelectField(task);
      } else if (task.type === "input") {
        control = buildInputField(task);
      }
      if (control) {
        label.appendChild(control);
      }
      return label;
    }

    function appendDndBlock(container, task) {
      const pool = document.createElement("div");
      pool.className = "dnd-pool";
      const tokens = shuffleArray(task && task.tokens);
      tokens.forEach(entry => {
        if (!entry) return;
        const tokenMeta = typeof entry === "string" ? { label: entry, value: entry } : entry;
        const value = tokenMeta.value || tokenMeta.label || "";
        if (!value) return;
        const tokenEl = document.createElement("div");
        tokenEl.className = "dnd-token";
        tokenEl.setAttribute("draggable", "true");
        tokenEl.dataset.value = value;
        tokenEl.textContent = tokenMeta.label || value;
        pool.appendChild(tokenEl);
      });
      container.appendChild(pool);
      const targetsWrap = document.createElement("div");
      targetsWrap.className = "dnd-targets";
      const targets = shuffleArray(task && task.targets);
      targets.forEach(target => {
        if (!target) return;
        const targetEl = document.createElement("div");
        targetEl.className = "dnd-target";
        targetEl.dataset.answer = target.answer || "";
        if (target.label) targetEl.dataset.prompt = target.label;
        const label = document.createElement("span");
        label.className = "question-text";
        label.textContent = target.label || target.answer || "";
        const slot = document.createElement("div");
        slot.className = "drop-slot";
        targetEl.appendChild(label);
        targetEl.appendChild(slot);
        targetsWrap.appendChild(targetEl);
      });
      container.appendChild(targetsWrap);
    }

    function appendMemoryGameBlock(container, config, sectionId) {
      if (!config) return;
      const pairs = Array.isArray(config.pairs) ? config.pairs.filter(pair => pair && (pair.id || pair.cards)) : [];
      if (!pairs.length) return;
      const block = document.createElement("div");
      block.className = "memory-game";
      const status = document.createElement("p");
      status.className = "small memory-status";
      block.appendChild(status);
      const grid = document.createElement("div");
      grid.className = "memory-grid";
      block.appendChild(grid);
      const totalPairs = pairs.length;
      const progressInputs = new Map();
      const pairIdMap = new Map();
      const formatCardLabel = entry => {
        if (typeof entry === "string") return entry;
        if (entry && typeof entry === "object") {
          return entry.label || entry.text || entry.value || "";
        }
        return "";
      };
      const resolvePairDescriptor = pair => {
        if (!pair) return "";
        if (pair.label) return pair.label;
        const entries = Array.isArray(pair.cards) ? pair.cards : Array.isArray(pair.labels) ? pair.labels : [];
        const parts = entries.slice(0, 2).map(formatCardLabel).filter(Boolean);
        return parts.join(" ↔ ");
      };
      pairs.forEach(pair => {
        const pairId = String(pair.id || `pair-${Math.random().toString(36).slice(2)}`);
        pairIdMap.set(pair, pairId);
        const hidden = document.createElement("input");
        hidden.type = "hidden";
        hidden.dataset.answer = pairId;
        hidden.dataset.prompt = resolvePairDescriptor(pair) || pairId;
        hidden.className = "memory-progress";
        hidden.hidden = true;
        block.appendChild(hidden);
        progressInputs.set(pairId, hidden);
      });
      const cardData = [];
      pairs.forEach(pair => {
        const pairId = pairIdMap.get(pair);
        const entries = Array.isArray(pair.cards) ? pair.cards : Array.isArray(pair.labels) ? pair.labels : [];
        const normalized = entries.slice(0, 2).map(formatCardLabel).filter(Boolean);
        if (normalized.length < 2) return;
        normalized.forEach((label, index) => {
          cardData.push({
            id: `${pairId}-${index}`,
            label,
            pairId
          });
        });
      });
      const cards = [];
      shuffleArray(cardData).forEach(card => {
        if (!card.label) return;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "memory-card";
        btn.dataset.card = card.id;
        btn.dataset.pair = card.pairId;
        const inner = document.createElement("div");
        inner.className = "memory-card-inner";
        const back = document.createElement("div");
        back.className = "memory-card-face memory-card-back";
        const icon = document.createElement("img");
        icon.className = "memory-card-icon";
        icon.src = "assets/joker.svg";
        icon.alt = "Joker Karte";
        back.appendChild(icon);
        const front = document.createElement("div");
        front.className = "memory-card-face memory-card-front";
        front.textContent = card.label;
        inner.appendChild(back);
        inner.appendChild(front);
        btn.appendChild(inner);
        grid.appendChild(btn);
        cards.push(btn);
      });
      const state = { openCards: [], lock: false, matched: 0 };
      const updateStatus = () => {
        status.textContent = `${state.matched}/${totalPairs} Paare gefunden`;
      };
      updateStatus();

      function closeOpenCards(delay = 650) {
        const toHide = state.openCards.slice();
        state.lock = true;
        setTimeout(() => {
          toHide.forEach(card => card.classList.remove("revealed"));
          state.openCards = [];
          state.lock = false;
        }, delay);
      }

      function markPairMatched(pairId, first, second) {
        first.classList.add("matched");
        second.classList.add("matched");
        first.classList.remove("revealed");
        second.classList.remove("revealed");
        first.disabled = true;
        second.disabled = true;
        state.openCards = [];
        state.lock = false;
        state.matched += 1;
        updateStatus();
        const hidden = progressInputs.get(pairId);
        if (hidden) {
          hidden.value = pairId;
          hidden.dispatchEvent(new Event("input", { bubbles: true }));
        }
      }

      function handleCard(card) {
        if (!card || state.lock || card.classList.contains("revealed") || card.classList.contains("matched")) return;
        card.classList.add("revealed");
        state.openCards.push(card);
        if (state.openCards.length === 2) {
          state.lock = true;
          const [first, second] = state.openCards;
          if (first.dataset.pair === second.dataset.pair) {
            setTimeout(() => markPairMatched(first.dataset.pair, first, second), 220);
          } else {
            closeOpenCards();
          }
        }
      }

      cards.forEach(card => {
        card.addEventListener("click", () => handleCard(card));
      });

      function resetGame() {
        state.openCards = [];
        state.lock = false;
        state.matched = 0;
        updateStatus();
        progressInputs.forEach(input => {
          input.value = "";
          input.classList.remove("correct", "incorrect");
        });
        cards.forEach(card => {
          card.classList.remove("revealed", "matched", "incorrect", "correct");
          card.disabled = false;
        });
        const shuffledElements = shuffleArray(cards.slice());
        shuffledElements.forEach(card => grid.appendChild(card));
      }

      memoryGameControllers.set(String(sectionId), { reset: resetGame });
      container.appendChild(block);
    }

    function animateNarrativeOptionFly(source, target) {
      if (!source || !target || typeof document === "undefined") return;
      const sourceRect = source.getBoundingClientRect();
      const targetRect = target.getBoundingClientRect();
      const ghost = document.createElement("span");
      ghost.className = "narrative-fly";
      ghost.textContent = source.textContent;
      ghost.style.left = `${sourceRect.left + sourceRect.width / 2}px`;
      ghost.style.top = `${sourceRect.top + sourceRect.height / 2}px`;
      document.body.appendChild(ghost);
      requestAnimationFrame(() => {
        ghost.style.left = `${targetRect.left + targetRect.width / 2}px`;
        ghost.style.top = `${targetRect.top + targetRect.height / 2}px`;
        ghost.style.transform = "translate(-50%, -50%) scale(0.85)";
        ghost.style.opacity = "0.15";
      });
      ghost.addEventListener("transitionend", () => ghost.remove(), { once: true });
    }

    function appendFastPacedBlock(container, config, sectionId) {
      if (!config || !Array.isArray(config.combos) || !config.combos.length) return;
      const block = document.createElement("div");
      block.className = "fast-paced";
      block.dataset.sectionId = sectionId;

      const prompt = document.createElement("div");
      prompt.className = "fast-paced-prompt";
      prompt.textContent = "Bereit?";

      const header = document.createElement("div");
      header.className = "fast-paced-header";
      const timerWrap = document.createElement("div");
      timerWrap.className = "fast-paced-timer-wrap";
      const timer = document.createElement("span");
      timer.className = "fast-paced-timer";
      timer.textContent = `${config.timeLimitSeconds || 8}s`;
      const hourglassIcon = createHourglassIcon();
      timerWrap.appendChild(timer);
      timerWrap.appendChild(hourglassIcon);
      header.appendChild(prompt);
      header.appendChild(timerWrap);

      const options = document.createElement("div");
      options.className = "fast-paced-options";

      const footer = document.createElement("div");
      footer.className = "fast-paced-footer";
      const startBtn = document.createElement("button");
      startBtn.type = "button";
      startBtn.className = "fast-paced-start";
      startBtn.textContent = "Training starten";
      const progress = document.createElement("span");
      progress.className = "fast-paced-progress";
      progress.textContent = `0/${config.rounds || 8}`;
      const result = document.createElement("div");
      result.className = "fast-paced-result";
      result.textContent = "Klicke auf Start, um zu beginnen.";
      footer.appendChild(startBtn);
      footer.appendChild(progress);
      footer.appendChild(result);

      block.appendChild(header);
      block.appendChild(options);
      block.appendChild(footer);
      container.appendChild(block);

      fastPacedSections.push({
        sectionId,
        config,
        elements: {
          root: block,
          prompt,
          timer,
          options,
          startBtn,
          progress,
          result,
          hourglass: hourglassIcon
        }
      });
    }

    function updateInputHintOverlay(input) {
      if (!input || !input.dataset) return;
      const hint = input.dataset.hint || "";
      if (!hint) return;
      const wrapper = input.closest(".input-with-hint");
      if (!wrapper) return;
      const overlay = wrapper.querySelector(".input-hint-overlay");
      const measure = wrapper.querySelector(".input-hint-measure");
      if (!overlay || !measure) return;
      const computed = window.getComputedStyle(input);
      const paddingLeft = parseFloat(computed.paddingLeft) || 0;
      const paddingRight = parseFloat(computed.paddingRight) || 0;
      const availableWidth = input.clientWidth - paddingRight - paddingLeft;
      const value = input.value || "";
      if (!value) {
        overlay.textContent = hint;
        measure.textContent = "";
        overlay.style.setProperty("--input-hint-offset", `${paddingLeft}px`);
        overlay.classList.toggle("hidden", false);
        return;
      }
      overlay.textContent = "";
      overlay.classList.add("hidden");
    }

    function initInputHint(input) {
      if (!input || !input.dataset || !input.dataset.hint) return;
      if (inputHintRegistry.has(input)) {
        updateInputHintOverlay(input);
        return;
      }
      inputHintRegistry.add(input);
      const handler = () => updateInputHintOverlay(input);
      input.addEventListener("input", handler);
      input.addEventListener("focus", handler);
      input.addEventListener("blur", handler);
      updateInputHintOverlay(input);
    }

    function refreshAllInputHints() {
      inputHintRegistry.forEach(input => updateInputHintOverlay(input));
    }

    function pickRandomCombos(pool, count, excludeValue) {
      const filtered = pool.filter(entry => entry.combo !== excludeValue);
      return shuffleArray(filtered).slice(0, Math.max(0, count));
    }

    function setHourglassProgress(entryElements, fraction) {
      if (!entryElements || !entryElements.hourglass) return;
      const clamped = Math.max(0, Math.min(1, fraction || 0));
      const rotation = 360 * clamped;
      entryElements.hourglass.style.transform = `rotate(${rotation}deg)`;
    }

    function appendNarrativeBlock(container, story, sectionId) {
      if (!story) return;
      const entries = Array.isArray(story.entries) && story.entries.length ? story.entries : [story];
      entries.forEach(entry => {
        if (!entry || !Array.isArray(entry.options) || !Array.isArray(entry.answers)) return;
        const comboLabel = entry.comboLabel || (Array.isArray(entry.answers) ? entry.answers.join("+") : "");
        const fallbackLabel = entry.prompt || story.prompt || entry.scene || story.scene || "";
        const card = document.createElement("div");
        card.className = "narrative-card";
        const scene = document.createElement("p");
        scene.className = "narrative-scene narrative-prompt";
        scene.textContent = entry.scene || story.scene || "";
        const prompt = document.createElement("div");
        prompt.className = "narrative-prompt";
        const sentenceWrapper = document.createElement("div");
        sentenceWrapper.className = "narrative-blanks";
        const answers = Array.isArray(entry.answers) ? entry.answers : [];
        const slots = Math.max(1, entry.missingSlots || answers.length || 1);
        const blankNodes = [];
        let selectedBlank = null;
        let blankIndex = 0;
        function createBlank() {
          const span = document.createElement("span");
          span.className = "narrative-blank";
          span.dataset.index = blankIndex;
          span.dataset.answer = answers[blankIndex] || "";
          span.dataset.value = "";
          span.dataset.filled = "false";
           span.dataset.prompt = comboLabel || fallbackLabel || span.dataset.answer || "";
          span.addEventListener("click", () => {
            blankNodes.forEach(b => b.classList.remove("active"));
            if (span.dataset.filled === "true") {
              span.textContent = "";
              span.dataset.value = "";
              span.dataset.filled = "false";
            }
            span.classList.add("active");
            selectedBlank = span;
          });
          blankNodes.push(span);
          blankIndex += 1;
          return span;
        }
        const sentenceParts = String(entry.prompt || story.prompt || "").split(/(__+)/);
        sentenceParts.forEach(part => {
          if (/^__+$/.test(part)) {
            sentenceWrapper.appendChild(createBlank());
          } else if (part) {
            const textNode = document.createElement("span");
            textNode.textContent = part;
            sentenceWrapper.appendChild(textNode);
          }
        });
        while (blankNodes.length < slots) {
          sentenceWrapper.appendChild(createBlank());
        }
        prompt.appendChild(sentenceWrapper);
        const optionsRow = document.createElement("div");
        optionsRow.className = "narrative-options";
        shuffleArray(entry.options || []).forEach(option => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "narrative-option";
          btn.textContent = option.label || option.value || option;
          btn.dataset.value = option.value || option.label || option;
          btn.addEventListener("click", () => {
            const targetBlank = (selectedBlank && selectedBlank.dataset) ? selectedBlank : blankNodes.find(blank => blank.dataset.filled !== "true");
            if (!targetBlank) return;
            animateNarrativeOptionFly(btn, targetBlank);
            targetBlank.textContent = btn.textContent;
            targetBlank.dataset.value = btn.dataset.value;
            targetBlank.dataset.filled = "true";
            blankNodes.forEach(b => b.classList.remove("active"));
            selectedBlank = null;
          });
          optionsRow.appendChild(btn);
        });
        card.appendChild(scene);
        card.appendChild(prompt);
        card.appendChild(optionsRow);
        container.appendChild(card);
      });
    }

    function initFastPacedSections() {
      while (fastPacedInitIndex < fastPacedSections.length) {
        const entry = fastPacedSections[fastPacedInitIndex];
        if (entry) registerFastPacedController(entry);
        fastPacedInitIndex += 1;
      }
    }

    function registerFastPacedController(entry) {
      const { config, elements, sectionId } = entry;
      const normalizedCombos = (config.combos || []).map(combo => ({
        label: combo.label || combo.combo,
        combo: combo.combo || "",
        display: (combo.combo || "").toUpperCase()
      })).filter(item => item.combo);
      if (!normalizedCombos.length) return;
      const rounds = Math.max(1, config.rounds || 8);
      const timeLimit = Math.max(2, config.timeLimitSeconds || 8);
      const optionsPerRound = Math.max(2, Math.min(config.optionsPerRound || 4, normalizedCombos.length));
      const fastState = {
        active: false,
        currentRound: 0,
        correct: 0,
        timerId: null,
        remaining: timeLimit,
        awaitingInput: false,
        currentAnswer: null,
        usedCombos: new Set()
      };

      function resetOptions() {
        elements.options.innerHTML = "";
      }

      function updateHourglass(fraction) {
        setHourglassProgress(elements, fraction);
      }

      function updateTimerDisplay(value) {
        elements.timer.textContent = `${Math.max(0, value)}s`;
      }

      function updateProgress() {
        elements.progress.textContent = `${fastState.currentRound}/${rounds}`;
      }

      function showResult(message, isSuccess) {
        elements.result.textContent = message;
        if (isSuccess === true) {
          elements.result.style.color = "var(--good)";
        } else if (isSuccess === false) {
          elements.result.style.color = "var(--bad)";
        } else {
          elements.result.style.color = "var(--muted)";
        }
      }

      function stopTimer() {
        if (fastState.timerId) {
          clearInterval(fastState.timerId);
          fastState.timerId = null;
        }
      }

      function endRound(success) {
        if (success) fastState.correct += 1;
        fastState.awaitingInput = false;
        stopTimer();
        updateProgress();
        setTimeout(() => {
          if (fastState.currentRound >= rounds) {
            finishSession();
          } else {
            runNextRound();
          }
        }, 600);
      }

      function handleSelection(option, button) {
        if (!fastState.awaitingInput) return;
        fastState.awaitingInput = false;
        const success = option.combo === fastState.currentAnswer.combo;
        button.classList.add(success ? "correct" : "incorrect");
        if (!success) {
          elements.options.querySelectorAll("button").forEach(btn => {
            const expected = btn.dataset.combo;
            if (expected === fastState.currentAnswer.combo) {
              btn.classList.add("correct");
            }
            btn.disabled = true;
          });
          showResult(`Falsch – gesucht: ${fastState.currentAnswer.display}`, false);
        } else {
          elements.options.querySelectorAll("button").forEach(btn => btn.disabled = true);
          showResult("Richtig!", true);
        }
        updateHourglass(1);
        endRound(success);
      }

      function runNextRound() {
        fastState.currentRound += 1;
        fastState.remaining = timeLimit;
        fastState.awaitingInput = true;
        elements.options.innerHTML = "";
        let unused = normalizedCombos.filter(item => !fastState.usedCombos.has(item.combo));
        if (!unused.length) {
          fastState.usedCombos.clear();
          unused = normalizedCombos.slice();
        }
        const pool = shuffleArray(unused);
        const answer = pool[0];
        fastState.currentAnswer = answer;
        fastState.usedCombos.add(answer.combo);
        const promptLabel = answer.label || answer.display;
        elements.prompt.textContent = promptLabel;
        const distractors = pickRandomCombos(normalizedCombos, optionsPerRound - 1, answer.combo);
        const roundOptions = shuffleArray([answer, ...distractors]);
        roundOptions.forEach(option => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "fast-paced-option";
          btn.textContent = option.display;
          btn.dataset.combo = option.combo;
          btn.addEventListener("click", () => handleSelection(option, btn));
          elements.options.appendChild(btn);
        });
        updateProgress();
        updateTimerDisplay(fastState.remaining);
        updateHourglass(0);
        stopTimer();
        fastState.timerId = setInterval(() => {
          fastState.remaining -= 1;
          updateTimerDisplay(fastState.remaining);
          const elapsed = timeLimit - fastState.remaining;
          updateHourglass(Math.min(1, Math.max(0, elapsed / timeLimit)));
          if (fastState.remaining <= 0) {
            stopTimer();
            showResult(`Zu langsam – gesucht: ${fastState.currentAnswer.display}`, false);
            elements.options.querySelectorAll("button").forEach(btn => {
              const expected = btn.dataset.combo;
              if (expected === fastState.currentAnswer.combo) {
                btn.classList.add("correct");
              }
              btn.disabled = true;
            });
            updateHourglass(1);
            endRound(false);
          }
        }, 1000);
      }

      function finishSession() {
        fastState.active = false;
        elements.startBtn.disabled = false;
        elements.startBtn.textContent = "Erneut starten";
        elements.prompt.textContent = `Ergebnis: ${fastState.correct}/${rounds}`;
        updateTimerDisplay(timeLimit);
        resetOptions();
        elements.root.classList.remove("fast-paced-active");
        updateHourglass(1);
        const reward = fastState.correct * COINS_PER_ACTION;
        const completionPercent = Math.round((fastState.correct / rounds) * 100);
        if (reward > 0) {
          const bonusPercent = getRunenAmuletCoinBonusPercent();
          const finalReward = applyCoinBonus(reward);
          state.coins += finalReward;
          pendingCoinAnimation = { amount: finalReward, anchor: elements.startBtn, variant: "gain" };
          const bonusText = bonusPercent ? ` (Runenbonus +${bonusPercent}%)` : "";
          showResult(`Belohnung: +${finalReward} Coins${bonusText}`, true);
        } else {
          showResult("Keine Coins in dieser Runde.", false);
        }
        if (completionPercent >= 70) {
          const currentClears = state.sectionClears[sectionId] || 0;
          state.sectionClears[sectionId] = Math.max(currentClears, 1);
          updateSectionCompletionClasses();
          saveState();
        }
        updateUI();
        updateOverallSummary();
        recalcStats();
        saveState();
      }

      function resetSession() {
        stopTimer();
        fastState.active = false;
        fastState.currentRound = 0;
        fastState.correct = 0;
        fastState.awaitingInput = false;
        fastState.currentAnswer = null;
        fastState.usedCombos.clear();
        elements.prompt.textContent = "Bereit?";
        showResult("Klicke auf Start, um zu beginnen.", null);
        updateTimerDisplay(timeLimit);
        elements.startBtn.disabled = false;
        elements.startBtn.textContent = "Training starten";
        elements.progress.textContent = `0/${rounds}`;
        resetOptions();
        elements.root.classList.remove("fast-paced-active");
        updateHourglass(0);
      }

      function startSession() {
        if (fastState.active) return;
        fastState.active = true;
        fastState.currentRound = 0;
        fastState.correct = 0;
        elements.startBtn.disabled = true;
        showResult("Schnell reagieren!", null);
        elements.root.classList.add("fast-paced-active");
        runNextRound();
      }

      elements.startBtn.addEventListener("click", () => {
        resetSession();
        startSession();
      });

      resetSession();
    }

    function buildSectionElement(section, sectionId, isActive) {
      const wrapper = document.createElement("div");
      wrapper.className = "section";
      if (isActive) wrapper.classList.add("active");
      wrapper.dataset.section = sectionId;

      const contentCard = document.createElement("div");
      contentCard.className = "card card--section";
      if (section && section.memoryGame) contentCard.classList.add("memory-section-card");
      const cardBody = document.createElement("div");
      cardBody.className = "card-body";
      const hasDescription = Boolean(section && section.description);
      const sectionTitle = section && section.title ? section.title : `Abschnitt ${sectionId}`;
      if (sectionTitle || hasDescription) {
        const header = document.createElement("div");
        header.className = "card-header";
        const headerText = document.createElement("div");
        headerText.className = "card-header-text";
        const heading = document.createElement("h2");
        heading.textContent = sectionTitle;
        headerText.appendChild(heading);
        if (hasDescription) {
          const description = document.createElement("span");
          description.className = "small";
          description.textContent = section.description;
          headerText.appendChild(description);
        }
        header.appendChild(headerText);
        header.classList.toggle("completed", sectionCompleted(sectionId));
        contentCard.appendChild(header);
        contentCard.classList.add("has-card-header");
      }
      contentCard.appendChild(cardBody);
      const tasks = Array.isArray(section && section.tasks) ? section.tasks : [];
      tasks.forEach(task => {
        if (!task) return;
        if (task.type === "dnd") {
          appendDndBlock(cardBody, task);
        } else {
          const field = buildTaskField(task);
          if (field) cardBody.appendChild(field);
        }
      });
      if (section && section.memoryGame) {
        appendMemoryGameBlock(cardBody, section.memoryGame, sectionId);
      }
      if (section && section.fastPaced) {
        appendFastPacedBlock(cardBody, section.fastPaced, sectionId);
      }
      if (section && section.narrative) {
        appendNarrativeBlock(cardBody, section.narrative, sectionId);
      }
      if (section && section.comboBuilder) {
        appendComboBuilderBlock(cardBody, section.comboBuilder, sectionId);
      }
      wrapper.appendChild(contentCard);

      if (!section || section.hideActions !== true) {
        const actionCard = document.createElement("div");
        actionCard.className = "card action-card";
        const checkBtn = document.createElement("button");
        checkBtn.type = "button";
        checkBtn.className = "check-section";
        checkBtn.dataset.checkSection = sectionId;
        const checkLabel = section && section.checkLabel ? section.checkLabel : "Abschnitt prüfen";
        checkBtn.textContent = `✅ ${checkLabel}`;
        const resetBtn = document.createElement("button");
        resetBtn.type = "button";
        resetBtn.className = "reset-section";
        resetBtn.dataset.resetSection = sectionId;
        const resetLabel = section && section.resetLabel ? section.resetLabel : "Zurücksetzen";
        resetBtn.textContent = `🔄 ${resetLabel}`;
        const result = document.createElement("p");
        result.className = "small result-text";
        result.id = `result-${sectionId}`;
        actionCard.appendChild(checkBtn);
        actionCard.appendChild(resetBtn);
        actionCard.appendChild(result);
        wrapper.appendChild(actionCard);
      }
      return wrapper;
    }

    function renderLearnSections() {
      if (!sectionTabsHost || !learnSectionsHost) return;
      const existingTabs = sectionTabsHost.querySelectorAll(".section-tab").length;
      const existingHint = learnSectionsHost.querySelector(".locked-sections-hint");
      if (existingHint) existingHint.remove();
      if (existingTabs === 0) {
        sectionTabsHost.innerHTML = "";
        learnSectionsHost.innerHTML = "";
        memoryGameControllers.clear();
        fastPacedSections.length = 0;
        fastPacedInitIndex = 0;
      }
      if (!SECTION_BLUEPRINTS.length) {
        if (existingTabs === 0) {
          const fallback = document.createElement("p");
          fallback.className = "small";
          fallback.textContent = "Keine Trainingsabschnitte verfügbar.";
          learnSectionsHost.appendChild(fallback);
        }
        return;
      }
      const unlockedCount = getUnlockedSectionLimit();
      const targetCount = Math.min(unlockedCount, SECTION_BLUEPRINTS.length);
      let lastSectionEl = null;
      for (let index = existingTabs; index < targetCount; index++) {
        const section = SECTION_BLUEPRINTS[index];
        if (!section) continue;
        const sectionId = resolveSectionId(section, index);
        const tab = createSectionTab(section, sectionId, index === 0 && existingTabs === 0);
        const sectionEl = buildSectionElement(section, sectionId, index === 0 && existingTabs === 0);
        sectionTabsHost.appendChild(tab);
        learnSectionsHost.appendChild(sectionEl);
        lastSectionEl = sectionEl;
      }
      updateLockedSectionsHint(targetCount < SECTION_BLUEPRINTS.length);
      updateSectionCompletionClasses();
    }

    function unlockNextSection() {
      const total = SECTION_BLUEPRINTS.length;
      if (!total) return false;
      const current = getUnlockedSectionLimit();
      if (current >= total) return false;
      state.sectionsUnlocked = Math.min(total, current + 1);
      renderLearnSections();
      setupLearnSectionInteractions();
      refreshAllInputHints();
      initFastPacedSections();
      return true;
    }

    function showSectionById(id) {
      const sections = document.querySelectorAll(".section");
      const tabs = document.querySelectorAll(".section-tab");
      sections.forEach(sec => {
        sec.classList.toggle("active", sec.dataset.section === String(id));
      });
      tabs.forEach(tab => {
        tab.classList.toggle("active", tab.dataset.goto === String(id));
      });
    }

    function setupLearnSectionInteractions() {
      const sections = document.querySelectorAll(".section");
      const sectionTabs = document.querySelectorAll(".section-tab");
      const hasActive = Array.from(sections).some(sec => sec.classList.contains("active"));
      if (!hasActive && sectionTabs.length) {
        const defaultId = sectionTabs[0].dataset.goto || (sections[0] ? sections[0].dataset.section : "1");
        showSectionById(defaultId);
      }
      sectionTabs.forEach(tab => {
        if (tab.dataset.tabBound === "true") return;
        tab.dataset.tabBound = "true";
        tab.addEventListener("click", () => {
          showSectionById(tab.dataset.goto);
        });
      });
      allCheckables = Array.from(document.querySelectorAll("[data-answer], .dnd-target"));
      document.querySelectorAll("input[data-hint]").forEach(input => initInputHint(input));
      document.querySelectorAll(".dnd-token").forEach(token => {
        if (token.dataset.dndBound === "true") return;
        token.dataset.dndBound = "true";
        token.addEventListener("dragstart", event => {
          currentDragValue = token.dataset.value;
          if (event.dataTransfer) {
            event.dataTransfer.setData("text/plain", currentDragValue);
          }
        });
      });
      document.querySelectorAll(".dnd-target").forEach(target => {
        const slot = target.querySelector(".drop-slot");
        if (!slot || slot.dataset.dropBound === "true") return;
        slot.dataset.dropBound = "true";
        slot.addEventListener("dragover", event => {
          event.preventDefault();
          target.classList.add("over");
        });
        slot.addEventListener("dragleave", () => {
          target.classList.remove("over");
        });
        slot.addEventListener("drop", event => {
          event.preventDefault();
          target.classList.remove("over");
          const value = (event.dataTransfer && event.dataTransfer.getData("text/plain")) || currentDragValue;
          if (!value) return;
          slot.textContent = value;
          slot.dataset.value = value;
          slot.classList.remove("correct", "incorrect");
          target.classList.remove("correct", "incorrect");
          const wrap = target.closest(".task-field");
          if (wrap) wrap.classList.remove("correct", "incorrect");
          updateOverallSummary();
        });
      });
      allCheckables.forEach(el => {
        if (el.dataset.checkableBound === "true") return;
        el.dataset.checkableBound = "true";
        const wrap = el.closest(".task-field");
        const clear = () => {
          el.classList.remove("correct", "incorrect");
          if (wrap) wrap.classList.remove("correct", "incorrect");
          if (el.classList.contains("dnd-target")) {
            const slot = el.querySelector(".drop-slot");
            if (slot) slot.classList.remove("correct", "incorrect");
          }
          updateOverallSummary();
        };
        if (el.tagName === "SELECT") {
          el.addEventListener("change", clear);
        } else if (el.tagName === "INPUT") {
          el.addEventListener("input", clear);
        }
      });
      updateOverallSummary();
    }

    function bindSectionActionButtons() {
      if (!learnSectionsHost || learnSectionsHost.dataset.actionsBound === "true") return;
      learnSectionsHost.dataset.actionsBound = "true";
      learnSectionsHost.addEventListener("click", event => {
        const checkBtn = event.target.closest(".check-section");
        if (checkBtn) {
          gradeSection(checkBtn.dataset.checkSection, checkBtn);
          return;
        }
        const resetBtn = event.target.closest(".reset-section");
        if (resetBtn) {
          resetSection(resetBtn.dataset.resetSection);
        }
      });
    }

    function normalizeComboOption(entry) {
      if (!entry) return null;
      if (typeof entry === "string") {
        return { value: entry, label: entry };
      }
      if (typeof entry === "object") {
        const value = entry.value || entry.label || "";
        if (!value) return null;
        return { value, label: entry.label || entry.value };
      }
      return null;
    }

    function buildComboOptionList(source, answers) {
      const list = [];
      const seen = new Set();
      const push = meta => {
        if (!meta || !meta.value || seen.has(meta.value)) return;
        seen.add(meta.value);
        list.push(meta);
      };
      (Array.isArray(source) ? source : []).forEach(entry => push(normalizeComboOption(entry)));
      (Array.isArray(answers) ? answers : []).forEach(entry => push(normalizeComboOption(entry)));
      return list;
    }

    function appendComboBuilderBlock(container, config, sectionId) {
      if (!config) return;
      const combos = Array.isArray(config.combos) ? config.combos : [];
      if (!combos.length) return;
      const block = document.createElement("div");
      block.className = "combo-builder";
      const heading = document.createElement("h3");
      heading.textContent = config.title || "Combo Builder";
      block.appendChild(heading);
      if (config.instructions) {
        const info = document.createElement("p");
        info.className = "small";
        info.textContent = config.instructions;
        block.appendChild(info);
      }
      const rows = document.createElement("div");
      rows.className = "combo-rows";
      combos.forEach((combo, comboIndex) => {
        if (!combo) return;
        const row = document.createElement("div");
        row.className = "combo-row";
        const promptWrap = document.createElement("div");
        promptWrap.className = "combo-prompt";
        if (combo.title) {
          const comboTitle = document.createElement("div");
          comboTitle.className = "combo-title";
          comboTitle.textContent = combo.title;
          promptWrap.appendChild(comboTitle);
        }
        if (combo.prompt) {
          const comboText = document.createElement("p");
          comboText.className = "combo-text";
          comboText.textContent = combo.prompt;
          promptWrap.appendChild(comboText);
        }
        const slotsWrap = document.createElement("div");
        slotsWrap.className = "combo-slots";
        const answers = Array.isArray(combo.answers) ? combo.answers : [];
        const optionPool = buildComboOptionList(
          Array.isArray(combo.options) && combo.options.length ? combo.options :
          (Array.isArray(config.defaultOptions) ? config.defaultOptions : []),
          answers
        );
        answers.forEach((answer, slotIndex) => {
          if (slotIndex > 0) {
            const plus = document.createElement("span");
            plus.className = "combo-plus";
            plus.textContent = "+";
            slotsWrap.appendChild(plus);
          }
          const slot = document.createElement("div");
          slot.className = "combo-slot";
          const select = document.createElement("select");
          const answerMeta = normalizeComboOption(answer);
          select.dataset.answer = answerMeta ? answerMeta.value : (typeof answer === "string" ? answer : "");
          select.dataset.comboSlot = `${sectionId}-${comboIndex}-${slotIndex}`;
          const placeholder = document.createElement("option");
          placeholder.value = "";
          placeholder.textContent = "auswählen";
          placeholder.selected = true;
          select.appendChild(placeholder);
          optionPool.forEach(optionMeta => {
            const opt = document.createElement("option");
            opt.value = optionMeta.value;
            opt.textContent = optionMeta.label;
            select.appendChild(opt);
          });
          slot.appendChild(select);
          slotsWrap.appendChild(slot);
        });
        row.appendChild(promptWrap);
        row.appendChild(slotsWrap);
        rows.appendChild(row);
      });
      block.appendChild(rows);
      container.appendChild(block);
    }

    function initLearnSections() {
      renderLearnSections();
      setupLearnSectionInteractions();
      bindSectionActionButtons();
      refreshAllInputHints();
      initFastPacedSections();
    }

    initLearnSections();
    window.addEventListener("resize", () => {
      refreshAllInputHints();
    });
    const coinAnimationLayer = document.getElementById("coinAnimationLayer");
    const gachaBtn = document.getElementById("gachaBtn");
    const baseGachaLabel = gachaBtn ? (gachaBtn.getAttribute("aria-label") || gachaBtn.textContent.trim() || "Item kaufen") : "";
    const setGachaStatus = message => {
      if (!gachaBtn) return;
      const status = message ? String(message) : "";
      if (baseGachaLabel) {
        gachaBtn.setAttribute("aria-label", status ? `${baseGachaLabel} (${status})` : baseGachaLabel);
      } else if (status) {
        gachaBtn.setAttribute("aria-label", status);
      } else {
        gachaBtn.removeAttribute("aria-label");
      }
      gachaBtn.title = status;
    };
    const gachaTypeInputs = document.querySelectorAll("input[name='gachaType']");
    const gachaRemainingLabels = document.querySelectorAll("[data-remaining-category]");
    const battleLog = document.getElementById("battleLog");
    const battleSimulation = document.getElementById("battleSimulation");
    const battleTitle = document.getElementById("battleTitle");
    const battleArena = document.getElementById("battleArena");
    const battleSkillBar = document.getElementById("battleSkillBar");
    const battleKnight = document.getElementById("battleKnight");
    const battleEnemy = document.getElementById("battleEnemy");
    const battleWeaponSlot1 = document.getElementById("battleWeaponSlot1");
    const battleWeaponSlot2 = document.getElementById("battleWeaponSlot2");
    const battleEnemySprite = document.getElementById("battleEnemySprite");
    const battleEnemyName = document.getElementById("battleEnemyName");
    const battleHeroAtkStat = document.getElementById("battleHeroAtkStat");
    const battleHeroDefStat = document.getElementById("battleHeroDefStat");
    const battleHeroHpStat = document.getElementById("battleHeroHpStat");
    const battleEnemyPreviewIcon = document.getElementById("battleEnemyPreviewIcon");
    const battleEnemyPreviewName = document.getElementById("battleEnemyPreviewName");
    const battleEnemyPreviewLevel = document.getElementById("battleEnemyPreviewLevel");
    const battleEnemyAtkStat = document.getElementById("battleEnemyAtkStat");
    const battleEnemyDefStat = document.getElementById("battleEnemyDefStat");
    const battleEnemyHpStat = document.getElementById("battleEnemyHpStat");
    const battleEnemyTrait = document.getElementById("battleEnemyTrait");
    const battleHeroGearList = document.getElementById("battleHeroGearList");
    const modalHeroCard = document.getElementById("modalHeroCard");
    const modalEnemyCard = document.getElementById("modalEnemyCard");
    const modalHeroName = document.getElementById("modalHeroName");
    const modalHeroAtk = document.getElementById("modalHeroAtk");
    const modalHeroDef = document.getElementById("modalHeroDef");
    const modalHeroVarBadge = document.getElementById("modalHeroVarBadge");
    const modalHeroCritBadge = document.getElementById("modalHeroCritBadge");
    const modalEnemyName = document.getElementById("modalEnemyName");
    const modalEnemyTrait = document.getElementById("modalEnemyTrait");
    const modalEnemyAtk = document.getElementById("modalEnemyAtk");
    const modalEnemyDef = document.getElementById("modalEnemyDef");
    const modalEnemyMeta = document.getElementById("modalEnemyMeta");
    const modalEnemyVarBadge = document.getElementById("modalEnemyVarBadge");
    const modalEnemyCritBadge = document.getElementById("modalEnemyCritBadge");
    const modalEnemyIcon = document.getElementById("modalEnemyIcon");
    const heroCardElements = Array.from(document.querySelectorAll(".battle-side.hero, .modal-battle-card.hero"));
    const enemyCardElements = Array.from(document.querySelectorAll(".battle-side.enemy, .modal-battle-card.enemy"));
    const heroHpFill = document.getElementById("heroHpFill");
    const enemyHpFill = document.getElementById("enemyHpFill");
    const heroHpValue = document.getElementById("heroHpValue");
    const enemyHpValue = document.getElementById("enemyHpValue");
    const battleResult = document.getElementById("battleResult");
    const battleReward = document.getElementById("battleReward");
    const battleRewardText = document.getElementById("battleRewardText");
    const battleRewardBreakdown = document.getElementById("battleRewardBreakdown");
    const battleRewardChest = document.getElementById("battleRewardChest");
    const battleNextBtn = document.getElementById("battleNextBtn");
    const testAnimationBtn = document.getElementById("testAnimationBtn");
    const battleButtonContainer = document.getElementById("battleButtons");
    let battleButtons = [];
    let currentBattleContext = null;
    let canRenderBattlePreview = false;
    function handleUpgradeClick(container, selector, upgradeFn, readyAttr = "itemUpgradeReady") {
      if (!container) return;
      container.addEventListener("click", event => {
        const target = event.target.closest(selector);
        if (!target) return;
        const isReady = target.dataset[readyAttr] === "true";
        if (!isReady) return;
        const key = target.dataset.itemKey || target.dataset.skillKey;
        if (!key) return;
        upgradeFn(key);
      });
      container.addEventListener("keydown", event => {
        if (event.key !== "Enter" && event.key !== " ") return;
        const target = event.target.closest(selector);
        if (!target) return;
        event.preventDefault();
        const isReady = target.dataset[readyAttr] === "true";
        if (!isReady) return;
        const key = target.dataset.itemKey || target.dataset.skillKey;
        if (!key) return;
        upgradeFn(key);
      });
    }
    handleUpgradeClick(inventoryList, "[data-item-upgrade]", triggerItemUpgrade, "itemUpgradeReady");
    handleUpgradeClick(skillList, ".item-upgrade", triggerSkillUpgrade, "skillUpgradeReady");
    const handleSkillBonusActivation = target => {
      if (!target) return;
      if (target.dataset.skillBonusReady !== "true") return;
      const key = target.dataset.skillBonusKey;
      if (!key) return;
      triggerSkillBonusUpgrade(key);
    };
    const handleSkillUpgradeActivation = target => {
      if (!target) return;
      if (target.dataset.skillUpgradeReady !== "true") return;
      const key = target.dataset.skillUpgradeKey;
      if (!key) return;
      triggerSkillUpgrade(key);
    };
    if (skillList) {
      skillList.addEventListener("click", event => {
        const indicator = event.target.closest("[data-skill-bonus-key],[data-skill-upgrade-key]");
        if (!indicator) return;
        if (indicator.dataset.skillBonusKey) {
          handleSkillBonusActivation(indicator);
        } else if (indicator.dataset.skillUpgradeKey) {
          handleSkillUpgradeActivation(indicator);
        }
      });
      skillList.addEventListener("keydown", event => {
        if (event.key !== "Enter" && event.key !== " ") return;
        const indicator = event.target.closest("[data-skill-bonus-key],[data-skill-upgrade-key]");
        if (!indicator) return;
        event.preventDefault();
        if (indicator.dataset.skillBonusKey) {
          handleSkillBonusActivation(indicator);
        } else if (indicator.dataset.skillUpgradeKey) {
          handleSkillUpgradeActivation(indicator);
        }
      });
    }
    if (inventoryFilterButtons.length) {
      inventoryFilterButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const rawValue = btn.dataset.inventoryFilter || DEFAULT_INVENTORY_FILTER;
          const normalizedValue = rawValue === "all" ? "all" : normalizeItemCategory(rawValue);
          if (normalizedValue === currentInventoryFilter) return;
          currentInventoryFilter = normalizedValue;
          inventoryNeedsResort = true;
          inventoryFilterButtons.forEach(ctrl => {
            const isActive = ctrl === btn;
            ctrl.classList.toggle("active", isActive);
            ctrl.setAttribute("aria-pressed", String(isActive));
          });
          renderInventory();
        });
      });
    }

    if (inventoryList) {
      inventoryList.addEventListener("click", event => {
        const equipBtn = event.target.closest(".item-equip");
        if (!equipBtn) return;
        const itemKey = equipBtn.dataset.itemKey;
        const slotKey = equipBtn.dataset.slotKey;
        if (!itemKey || !slotKey) return;
        const normalizedSlot = normalizeItemSlot(slotKey);
        const equippedKey = normalizedSlot && state.equipment ? state.equipment[normalizedSlot] : null;
        if (equippedKey && equippedKey === itemKey) {
          return;
        }
        equipItem(slotKey, itemKey);
      });
    }
    if (equipmentLayout) {
      equipmentLayout.addEventListener("click", event => {
        const clearBtn = event.target.closest(".slot-unequip");
        if (!clearBtn || clearBtn.hidden) return;
        const slotKey = clearBtn.dataset.slot;
        unequipSlot(slotKey);
      });
    }
    if (autoEquipBtn) {
      autoEquipBtn.addEventListener("click", autoEquipBest);
    }
    if (unequipAllBtn) {
      unequipAllBtn.addEventListener("click", unequipAllSlots);
    }

    const learnView = document.getElementById("learnView");
    const inventoryView = document.getElementById("inventoryView");
    const skillsView = document.getElementById("skillsView");
    const shopView = document.getElementById("shopView");
    const battleView = document.getElementById("battleView");
    const reportView = document.getElementById("reportView");
    const reportContent = document.getElementById("reportContent");
    const reportTimestamp = document.getElementById("reportTimestamp");
    const reportGenerateBtn = document.getElementById("reportGenerateBtn");
    const reportExportBtn = document.getElementById("reportExportBtn");
    const reportImportBtn = document.getElementById("reportImportBtn");
    const reportResetBtn = document.getElementById("reportResetBtn");
    const reportImportInput = document.getElementById("reportImportInput");
    const reportTabs = document.querySelectorAll(".report-tab");
    let activeReportTab = "overview";
    const activeReportCharts = [];
    const viewRegistry = {
      learn: learnView,
      inventory: inventoryView,
      skills: skillsView,
      shop: shopView,
      battle: battleView,
      report: reportView
    };
    const navToggles = document.querySelectorAll(".nav-toggle");
    const topNav = document.querySelector(".top-nav");
    const mobileNavToggle = document.getElementById("mobileNavToggle");

    function closeMobileNav() {
      if (!mobileNavToggle || !topNav) return;
      topNav.classList.remove("open");
      mobileNavToggle.setAttribute("aria-expanded", "false");
    }

    if (mobileNavToggle && topNav) {
      mobileNavToggle.addEventListener("click", () => {
        const expanded = mobileNavToggle.getAttribute("aria-expanded") === "true";
        const next = !expanded;
        mobileNavToggle.setAttribute("aria-expanded", String(next));
        topNav.classList.toggle("open", next);
      });
      window.addEventListener("resize", () => {
        if (window.innerWidth > 720) {
          closeMobileNav();
        }
      });
    }

    function setActiveView(viewKey) {
      Object.values(viewRegistry).forEach(section => {
        if (section) section.classList.remove("active");
      });
      const targetSection = viewRegistry[viewKey] || learnView;
      if (targetSection) targetSection.classList.add("active");
    }
    function setActiveNav(viewKey) {
      navToggles.forEach(btn => {
        const matches = btn.dataset.view === viewKey;
        btn.classList.toggle("active", matches);
      });
    }
    function activateView(viewKey) {
      if (viewKey === "report") {
        renderReport();
      }
      setActiveNav(viewKey);
      setActiveView(viewKey);
    }
    if (reportGenerateBtn) {
      reportGenerateBtn.addEventListener("click", () => {
        renderReport();
      });
    }
    if (reportExportBtn) {
      reportExportBtn.addEventListener("click", () => {
        exportGameState();
      });
    }
    if (reportImportBtn && reportImportInput) {
      reportImportBtn.addEventListener("click", () => {
        reportImportInput.click();
      });
      reportImportInput.addEventListener("change", event => {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        const confirmed = window.confirm("Spielstand wirklich überschreiben? Der aktuelle Fortschritt wird ersetzt.");
        if (!confirmed) {
          reportImportInput.value = "";
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const parsed = JSON.parse(reader.result || "{}");
            importGameState(parsed);
            alert("Spielstand importiert.");
          } catch (err) {
            console.error("Import fehlgeschlagen", err);
            alert("Import fehlgeschlagen. Bitte gültige JSON-Datei wählen.");
          } finally {
            reportImportInput.value = "";
          }
        };
        reader.onerror = () => {
          console.error("Import fehlgeschlagen", reader.error);
          alert("Import fehlgeschlagen. Datei konnte nicht gelesen werden.");
          reportImportInput.value = "";
        };
        reader.readAsText(file);
      });
    }
    if (reportResetBtn) {
      reportResetBtn.addEventListener("click", () => {
        clearLocalProgress();
      });
    }
    if (reportTabs && reportTabs.length) {
      reportTabs.forEach(tab => {
        tab.addEventListener("click", () => {
          const view = tab.dataset.reportTab;
          if (!view || view === activeReportTab) return;
          activeReportTab = view;
          reportTabs.forEach(btn => btn.classList.toggle("active", btn === tab));
          renderReport();
        });
      });
    }

    navToggles.forEach(btn => {
      btn.addEventListener("click", () => {
        const view = btn.dataset.view;
        if (view === "report") {
          renderReport();
        }
        activateView(view);
        if (typeof window !== "undefined" && window.innerWidth <= 720) {
          closeMobileNav();
        }
      });
    });
    const defaultNav = Array.from(navToggles).find(btn => btn.classList.contains("active"));
    if (defaultNav) {
      setActiveView(defaultNav.dataset.view);
    } else {
      activateView("learn");
    }

    if (gachaTypeInputs && gachaTypeInputs.length) {
      gachaTypeInputs.forEach(input => {
        input.addEventListener("change", () => {
          if (!input.checked) return;
          state.gachaPreference = input.value;
          updateGachaOptionStyles();
          saveState();
        });
      });
    }

    applyGachaPreference(state.gachaPreference);

    const KNIGHT_POOL = [
      { key: "bronze_sword", name: "Bronzeklinge", atk: 2, def: 0, icon: "sword_bronze", slot: "weapon", description: "", theme: "knight", category: "weapon" },

      { key: "feuer_klinge", name: "Feuerklinge", atk: 4, def: 0, icon: "sword_fire", slot: "weapon", description: "", theme: "knight", category: "weapon" },

      { key: "stahl_sword", name: "Stahlklinge", atk: 3, def: 0, icon: "sword_steel", slot: "weapon", description: "", theme: "knight", category: "weapon" },
      { key: "turm_schild", name: "Turmschild", atk: 0, def: 3, icon: "shield", slot: "offhand", description: "", theme: "knight", category: "armor" },
      { key: "taktik_helm", name: "Taktikhelm", atk: 1, def: 1, icon: "helm", slot: "helm", description: "", theme: "knight", category: "armor" },
      { key: "panzerhandschuhe", name: "Panzerhandschuhe", atk: 0, def: 1, icon: "panzerhandschuhe", slot: "gloves", description: "Robuste Handschuhe für sicheren Griff.", theme: "knight", category: "armor" },
      { key: "runen_amulet", name: "Runen-Amulett", atk: 0, def: 0, icon: "talisman", slot: "necklace", description: "Verleiht Bonus-Münzen je nach Tier.", theme: "knight", category: "accessory" },
      { key: "lebens_ring", name: "Lebensring", atk: 0, def: 0, hp: 20, icon: "lebensring", slot: "ring_left", description: "Speichert ein wenig Lebenskraft.", theme: "knight", category: "accessory" },
      { key: "gluecks_ring", name: "Glücksring", atk: 0, def: 0, icon: "gluecksring", slot: "ring_right", description: "Erhöht kritischen Schaden.", theme: "knight", category: "accessory" },
      { key: "stahl_stiefel", name: "Stahl-Stiefel", atk: 0, def: 2, icon: "stahl-stiefel", slot: "boots", description: "", theme: "knight", category: "armor" },
    ];
    const KNIGHT_BY_KEY = Object.create(null);
    const KNIGHT_BY_NAME = Object.create(null);
    KNIGHT_POOL.forEach(entry => {
      KNIGHT_BY_KEY[entry.key] = entry;
      KNIGHT_BY_NAME[entry.name] = entry;
    });
    const SKILL_POOL = [
      { key: "sturm_hieb", name: "Himmelszorn", icon: "skill_tempest", description: "Beschwört Sturmwolken: Blitzschaden und 5-Runden-Abklingzeit.", effect: "damage", basePower: 6, powerPerTier: 4 },
      { key: "schutzwall", name: "Schutzwall", icon: "skill_barrier", description: "Beschwört eine magische Wand, die DEF für 5 Angriffe erhöht.", effect: "shield_wall", basePower: 4, powerPerTier: 2 },
      { key: "kampfrausch", name: "Kampfrausch", icon: "skill_frenzy", description: "Entfesselt Kampfrausch: +ATK für 5 Runden, danach Abklingzeit.", effect: "buff_atk", basePower: 2, powerPerTier: 0 },
      { key: "lichtbrunnen", name: "Aurawoge", icon: "skill_renew", description: "Heilt den Ritter sofort und legt eine 5-Runden-Abklingzeit fest.", effect: "heal", basePower: 12, powerPerTier: 6 }
    ];
    const SKILL_BY_KEY = Object.create(null);
    SKILL_POOL.forEach(entry => {
      SKILL_BY_KEY[entry.key] = entry;
    });
    const GACHA_CATEGORY_LABELS = {
      weapon: "Waffe",
      armor: "Ausrüstung",
      accessory: "Accessoire",
      any: "Zufall",
      skill: "Skill"
    };
    const INVENTORY_CATEGORY_ORDER = {
      weapon: 0,
      armor: 1,
      accessory: 2
    };
    const EQUIPMENT_SLOT_DEFS = {
      gloves: {
        label: "Handschuhe",
        hint: "Bereit für Handschuhe oder leichte Rüstung.",
        empty: "Noch keine Handschuhe.",
        accepts: [],
        allowedKeys: ["panzerhandschuhe"]
      },
      helm: {
        label: "Helm",
        hint: "Nur Helme passen hier.",
        empty: "Kein Helm aktiv.",
        accepts: ["helm", "helmet"]
      },
      necklace: {
        label: "Halskette",
        hint: "Runen, Amulette oder Halsketten.",
        empty: "Keine Halskette aktiv.",
        accepts: [],
        allowedKeys: ["runen_amulet"]
      },
      boots: {
        label: "Stiefel",
        hint: "Stiefel, Beinschienen oder leichte Panzerung.",
        empty: "Keine Stiefel aktiv.",
        accepts: ["boots", "boot", "stiefel", "greaves", "legs"]
      },
      weapon: {
        label: "Schwert",
        hint: "Lege Schwerter über das Inventar an.",
        empty: "Kein Schwert ausgerüstet.",
        accepts: ["weapon", "sword", "blade"]
      },
      offhand: {
        label: "Schwert 2 / Schild",
        hint: "Nur Schilde und Nebenhand-Gear.",
        empty: "Kein Schild oder Zweitwaffe aktiv.",
        accepts: ["offhand", "shield", "weapon", "sword", "blade"]
      },
      ring_left: {
        label: "Ring / Amulett 1",
        hint: "Erster Ring- oder Amulett-Slot.",
        empty: "Kein Schmuck ausgerüstet.",
        accepts: [],
        allowedKeys: ["lebens_ring", "gluecks_ring"]
      },
      ring_right: {
        label: "Ring / Amulett 2",
        hint: "Zweiter Ring- oder Amulett-Slot.",
        empty: "Kein Schmuck ausgerüstet.",
        accepts: [],
        allowedKeys: ["lebens_ring", "gluecks_ring"]
      }
    };
    const EQUIPMENT_SLOT_KEYS = Object.keys(EQUIPMENT_SLOT_DEFS);
    const AUTO_EQUIP_SLOT_ORDER = ["weapon", "offhand", "helm", "gloves", "necklace", "boots", "ring_left", "ring_right"];
    const ITEM_ART = {
      sword: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g transform="translate(0 3)"><rect x="14" y="4" width="4" height="18" rx="2" fill="#e2e8f0" stroke="#94a3b8" stroke-width="1.5"></rect><rect x="10" y="16" width="12" height="3" rx="1.5" fill="#fcd34d"></rect><rect x="11.5" y="19" width="9" height="4" rx="2" fill="#b45309"></rect><circle cx="16" cy="21" r="1.4" fill="#1f2937"></circle></g></svg>',
      shield: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M16 3 L26 7 v10 c0 9-10 13-10 13S6 26 6 17V7z" fill="rgba(14,165,233,0.25)" stroke="#38bdf8" stroke-width="1.8"></path><path d="M16 6 L23 9 v8 c0 6-7 9-7 9s-7-3-7-9V9z" fill="rgba(14,116,144,0.45)"></path></svg>',
      helm: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g transform="translate(0 2)"><path d="M8 22v-6c0-6.6 3.6-12 8-12s8 5.4 8 12v6z" fill="#94a3b8" stroke="#1e293b" stroke-width="1.6" stroke-linejoin="round"></path><rect x="11" y="16" width="10" height="4" rx="1.5" fill="#0f172a"></rect><path d="M16 11v7" stroke="#e2e8f0" stroke-width="2" stroke-linecap="round"></path></g></svg>',
      gloves: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g stroke="#1e293b" stroke-width="1.4" fill="rgba(248,250,252,0.85)"><path d="M9 7 q0-3 2.5-3t2.5 3v12q0 2-2.5 2T9 19z"></path><path d="M17 7 q0-3 2.5-3t2.5 3v12q0 2-2.5 2T17 19z"></path><path d="M7 13h18v6q0 5-6 7H13 q-6-2-6-7z" fill="rgba(148,163,184,0.4)"></path></g></svg>',
      boots: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M8 7 h8 v12 l6 3 v5H8z" fill="rgba(148,163,184,0.5)" stroke="#475569" stroke-width="1.3" stroke-linejoin="round"></path><path d="M18 7 h6 v10 l-2 8h-4z" fill="rgba(59,130,246,0.35)" stroke="#1d4ed8" stroke-width="1.2" stroke-linejoin="round"></path><path d="M8 24h10M19 26h6" stroke="#0f172a" stroke-width="1.4" stroke-linecap="round"></path></svg>',
      cape: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M10 4 q6 4 12 0 l2 20 q-8 4-16 0z" fill="rgba(59,130,246,0.45)" stroke="#2563eb" stroke-width="1.4"></path><circle cx="16" cy="6" r="2.4" fill="#1d4ed8"></circle></svg>',
      talisman: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="9" fill="rgba(254,243,199,0.9)" stroke="#fbbf24" stroke-width="1.6"></circle><path d="M16 8 L18 14 L24 16 L18 18 L16 24 L14 18 L8 16 L14 14 Z" fill="rgba(250,204,21,0.8)" stroke="#92400e" stroke-width="0.8" stroke-linejoin="round"></path><circle cx="16" cy="16" r="2.4" fill="#f97316"></circle></svg>',
      panzerhandschuhe: '<img src="assets/panzerhandschuhe.svg" alt="Panzerhandschuhe" loading="lazy">',
      gluecksring: '<img src="assets/gluecksring.svg" alt="Glücksring" loading="lazy">',
      lebensring: '<img src="assets/lebensring.svg" alt="Lebensring" loading="lazy">',
      "stahl-stiefel": '<img src="assets/stahl-stiefel.svg" alt="Stahl-Stiefel" loading="lazy">',
      skill_power: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="13" fill="rgba(239,68,68,0.18)" stroke="#f87171" stroke-width="1.8"></circle><path d="M16 6 L10 18 h6 l-2 8 8-12h-6z" fill="#facc15" stroke="#f59e0b" stroke-width="1.5" stroke-linejoin="round"></path></svg>',
      skill_tempest: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="14" fill="rgba(30,64,175,0.22)" stroke="#60a5fa" stroke-width="1.5"></circle><g fill="#cbd5f5"><ellipse cx="12" cy="9" rx="6.5" ry="3.5"></ellipse><ellipse cx="19" cy="10.5" rx="7" ry="4"></ellipse><ellipse cx="16" cy="7.5" rx="5" ry="3"></ellipse></g><path d="M17 12 L13 22 h3.6 L14 28 L21 16 h-3.2z" fill="#38bdf8" stroke="#fef9c3" stroke-width="0.9" stroke-linejoin="round" style="filter: drop-shadow(0 0 5px rgba(250,204,21,0.85));"></path></svg>',
      skill_barrier: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="shieldGlow" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f0f9ff" stop-opacity="0.95"></stop><stop offset="80%" stop-color="#bae6fd" stop-opacity="0.65"></stop><stop offset="100%" stop-color="#7dd3fc" stop-opacity="0.55"></stop></linearGradient></defs><circle cx="16" cy="16" r="13.5" fill="rgba(14,165,233,0.18)" stroke="#7dd3fc" stroke-width="1.4"></circle><path d="M16 6 L24 10 v7.5c0 6-5.2 9.5-8 11c-2.8-1.5-8-5-8-11V10z" fill="url(#shieldGlow)" stroke="#e0f2fe" stroke-width="1.2"></path><path d="M16 8.5 V23" stroke="#bae6fd" stroke-width="1" stroke-linecap="round"></path><path d="M11 12 h10" stroke="rgba(191,219,254,0.8)" stroke-width="1" stroke-linecap="round"></path><path d="M12 17 h8" stroke="rgba(14,165,233,0.7)" stroke-width="0.9" stroke-linecap="round"></path></svg>',
      skill_guard: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M16 4 L26 9 v11 c0 9-10 13-10 13S6 29 6 20V9z" fill="rgba(59,130,246,0.18)" stroke="#60a5fa" stroke-width="1.8"></path><path d="M16 8 L23 11 v8 c0 6-7 9-7 9s-7-3-7-9v-8z" fill="rgba(96,165,250,0.28)"></path><path d="M16 12 v10" stroke="#e2e8f0" stroke-width="1.6"></path></svg>',
      skill_frenzy: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="12.5" fill="rgba(127,29,29,0.15)" stroke="#f87171" stroke-width="1.4"></circle><path d="M16 6l3 6l6 1l-4 4l1 6l-6-3l-6 3l1-6l-4-4l6-1z" fill="rgba(248,113,113,0.3)" stroke="#fca5a5" stroke-width="1.2" stroke-linejoin="round"></path><path d="M16 8v4M16 20v4M8 16h4M20 16h4" stroke="#f43f5e" stroke-width="1.3" stroke-linecap="round"></path><circle cx="16" cy="16" r="2.2" fill="#fff1f2"></circle></svg>',
      skill_renew: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="renewGlow" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fef3c7"></stop><stop offset="100%" stop-color="#fbbf24"></stop></linearGradient><linearGradient id="renewCore" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#a7f3d0"></stop><stop offset="100%" stop-color="#34d399"></stop></linearGradient></defs><circle cx="16" cy="16" r="13" fill="rgba(15,118,110,0.1)" stroke="#34d399" stroke-width="1.4"></circle><path d="M16 6 c5 0 9 4.5 9 9.5s-4 9.5-9 9.5s-9-4.5-9-9.5S11 6 16 6z" fill="url(#renewCore)" stroke="#14b8a6" stroke-width="1.2"></path><path d="M16 8.5v6l3.2 1.5" fill="none" stroke="url(#renewGlow)" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"></path><path d="M10 18.5q2.5 3.5 6 3.5t6-3.5" fill="none" stroke="rgba(255,255,255,0.8)" stroke-width="1.1" stroke-linecap="round"></path><circle cx="16" cy="16" r="2.8" fill="#fef9c3" stroke="#fde68a" stroke-width="0.8"></circle><path d="M6 12 l2 1.2M26 12 l-2 1.2M7 22 l1.6-1.4M25 22 l-1.6-1.4" stroke="#fde68a" stroke-width="1" stroke-linecap="round"></path></svg>',
      default: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="6" width="14" height="18" rx="3" fill="#475569" stroke="#94a3b8" stroke-width="1.4"></rect><circle cx="16" cy="12" r="3" fill="#e2e8f0"></circle><path d="M12 22 h8" stroke="#e2e8f0" stroke-width="2" stroke-linecap="round"></path></svg>'
    };
    function normalizeItemSlot(slot) {
      if (!slot) return null;
      const key = String(slot).toLowerCase();
      if (key === "trinket") return "necklace";
      if (key === "ring") return "ring_left";
      if (key === "stiefel" || key === "boots" || key === "boot" || key === "greaves" || key === "legs") return "boots";
      return EQUIPMENT_SLOT_DEFS[key] ? key : null;
    }
    function inferItemSlot(item) {
      if (!item) return null;
      const icon = String(item.icon || "").toLowerCase();
      if (icon === "sword") return "weapon";
      if (icon === "shield") return "offhand";
      if (icon === "helm") return "helm";
      if (icon === "gloves" || icon === "cape") return "gloves";
      if (icon === "boots" || icon === "greaves") return "boots";
      if (icon === "talisman") return "necklace";
      if (icon === "ring") return "ring_left";
      const category = String(item.category || "").toLowerCase();
      if (category === "weapon") return "weapon";
      if (category === "boots" || category === "legs") return "boots";
      if (category === "armor") return "offhand";
      if (category === "accessory") return "necklace";
      return null;
    }
    function normalizeItemCategory(category) {
      if (!category) return "misc";
      const normalized = String(category).trim().toLowerCase();
      return normalized || "misc";
    }
    function getItemSlot(item) {
      if (!item) return null;
      return normalizeItemSlot(item.slot) || inferItemSlot(item);
    }
    function getSlotButtonLabel(slotKey) {
      if (!slotKey) return "";
      if (slotKey === "weapon") return "Waffenslot1";
      if (slotKey === "offhand") return "Waffenslot2";
      const meta = EQUIPMENT_SLOT_DEFS[slotKey];
      return meta ? meta.label : slotKey;
    }
    function getEquipSlotsForItem(item) {
      if (!item) return [];
      const slots = [];
      const seen = new Set();
      const pushSlot = slot => {
        if (!slot || seen.has(slot) || !EQUIPMENT_SLOT_DEFS[slot]) return;
        slots.push(slot);
        seen.add(slot);
      };
      const primarySlot = getItemSlot(item);
      const isWeapon = primarySlot === "weapon" || normalizeItemCategory(item.category) === "weapon";
      if (isWeapon) {
        if (itemMatchesSlot(item, "weapon")) pushSlot("weapon");
        if (itemMatchesSlot(item, "offhand")) pushSlot("offhand");
      } else {
        pushSlot(primarySlot);
      }
      return slots;
    }
    ensureEquipmentState();
    function cloneItem(template) {
      const now = Date.now();
      return {
        id: `${template.key}-${now}-${Math.random().toString(16).slice(2, 6)}`,
        key: template.key,
        name: template.name,
        baseAtk: template.atk,
        baseDef: template.def,
        baseHp: Number(template.hp ?? template.baseHp ?? 0),
        atk: template.atk,
        def: template.def,
        hp: Number(template.hp ?? template.baseHp ?? 0),
        critDamagePercent: Number(template.critDamagePercent ?? 0),
        icon: template.icon,
        slot: getItemSlot(template),
        description: template.description,
        theme: template.theme || "knight",
        category: template.category || "accessory",
        tier: 1,
        totalCopies: 1,
        createdAt: now,
        lastObtainedAt: now
      };
    }
    function copiesRequiredForTier(tier) {
      if (tier <= 1) return 1;
      return Math.pow(2, tier - 1);
    }
    function getMaxCopiesForItem(template) {
      const targetTier = Math.max(1, Math.min(MAX_ITEM_TIER, Math.floor(template && template.maxTier ? template.maxTier : MAX_ITEM_TIER)));
      return copiesRequiredForTier(targetTier);
    }
    function getOwnedItemCopies(itemKey) {
      if (!itemKey || !Array.isArray(state.items)) return 0;
      const entry = state.items.find(candidate => candidate.key === itemKey);
      if (!entry) return 0;
      return Math.max(1, Math.floor(entry.totalCopies || 1));
    }
    function getRemainingShopCopies(template) {
      if (!template || !template.key) return 0;
      const maxCopies = getMaxCopiesForItem(template);
      const ownedCopies = getOwnedItemCopies(template.key);
      return Math.max(0, maxCopies - ownedCopies);
    }
    function isItemEligibleForShop(template) {
      return getRemainingShopCopies(template) > 0;
    }
    function getMaxCopiesForSkill(template) {
      if (template && Number.isFinite(template.maxTier)) {
        const targetTier = Math.max(1, Math.min(MAX_SKILL_TIER, Math.floor(template.maxTier)));
        return copiesRequiredForTier(targetTier);
      }
      return Infinity;
    }
    function maxTierFromCopies(copies, tierCap = MAX_ITEM_TIER) {
      const safeCopies = Math.max(1, Math.floor(copies || 1));
      const cap = Math.max(1, Math.floor(tierCap || MAX_ITEM_TIER));
      return Math.min(cap, Math.floor(Math.log2(safeCopies)) + 1);
    }
    function getSkillOvercapInfo(skill) {
      const totalCopies = Math.max(0, Math.floor(skill && skill.totalCopies ? skill.totalCopies : 0));
      const capCopies = copiesRequiredForTier(MAX_SKILL_TIER);
      const overcapCopies = Math.max(0, totalCopies - capCopies);
      const copiesPerPercent = 10;
      const naturalMaxPercent = Math.floor(overcapCopies / copiesPerPercent);
      const storedBonus = Math.max(0, Math.floor(skill && skill.overcapBonusPercent ? skill.overcapBonusPercent : 0));
      const bonusPercent = Math.min(storedBonus, naturalMaxPercent);
      const spentCopies = bonusPercent * copiesPerPercent;
      const availableCopies = Math.max(0, overcapCopies - spentCopies);
      const availablePercent = Math.floor(availableCopies / copiesPerPercent);
      const progressTowardNextPercent = availableCopies % copiesPerPercent;
      const remainingToNextPercent = availablePercent > 0
        ? 0
        : (progressTowardNextPercent === 0 ? copiesPerPercent : copiesPerPercent - progressTowardNextPercent);
      return {
        totalCopies,
        capCopies,
        overcapCopies,
        bonusPercent,
        copiesPerPercent,
        availablePercent,
        availableCopies,
        progressTowardNextPercent,
        remainingToNextPercent
      };
    }
    function getSkillBaseEffect(skill) {
      if (!skill) return 0;
      const tier = Math.max(1, Math.floor(skill.tier || 1));
      if (skill.key === "kampfrausch") {
        const frenzyTable = { 1: 2, 2: 5, 3: 10, 4: 15, 5: 25, 6: 25 };
        return frenzyTable[tier] || frenzyTable[5];
      }
      const basePower = Number(skill.basePower || 0);
      const perTier = Number(skill.powerPerTier || 0);
      return basePower + perTier * (tier - 1);
    }
    function getSkillEffectivePower(skill) {
      const base = getSkillBaseEffect(skill);
      const bonusPercent = Number(skill && skill.overcapBonusPercent ? skill.overcapBonusPercent : 0);
      if (!bonusPercent) return base;
      return Math.max(1, Math.round(base * (1 + bonusPercent / 100)));
    }
    function updateItemDerivedStats(item) {
      if (!item) return item;
      const safeTier = Math.max(1, Math.min(MAX_ITEM_TIER, Math.floor(item.tier || 1)));
      const safeCopies = Math.max(1, Math.floor(item.totalCopies || 1));
      const baseAtk = Number(item.baseAtk ?? item.atk ?? 0);
      const baseDef = Number(item.baseDef ?? item.def ?? 0);
      const template = item.key ? KNIGHT_BY_KEY[item.key] : null;
      const templateHp = template && (template.hp ?? template.baseHp);
      const resolvedBaseHp = item.baseHp ?? templateHp;
      const baseHp = Number(resolvedBaseHp ?? item.hp ?? 0) || 0;
      const maxTier = maxTierFromCopies(safeCopies, MAX_ITEM_TIER);
      const tier = Math.min(safeTier, maxTier);
      item.tier = tier;
      item.totalCopies = safeCopies;
      item.baseAtk = baseAtk;
      item.baseDef = baseDef;
      item.baseHp = baseHp;
      item.atk = baseAtk * tier;
      item.def = baseDef * tier;
      let hpBonus = baseHp > 0 ? baseHp * tier : 0;
      let critDamagePercent = Number(item.critDamagePercent ?? 0) || 0;
      if (item.key === LEBENS_RING_KEY) {
        hpBonus = LEBENS_RING_HP_BY_TIER[tier] ?? LEBENS_RING_HP_BY_TIER[MAX_ITEM_TIER] ?? baseHp;
      } else if (item.key === GLUECKS_RING_KEY) {
        critDamagePercent = GLUECKS_RING_CRIT_BY_TIER[tier] ?? 0;
        item.baseAtk = 0;
        item.atk = 0;
      }
      item.hp = Math.max(0, Math.round(hpBonus));
      item.critDamagePercent = Math.max(0, Math.round(critDamagePercent));
      item.slot = getItemSlot(item);
      if (!item.createdAt) item.createdAt = Date.now();
      if (!item.lastObtainedAt) item.lastObtainedAt = item.createdAt;
      return item;
    }
    function getNextTierRequirement(item, tierCap = MAX_ITEM_TIER) {
      if (!item) return Infinity;
      const cap = Math.max(1, Math.floor(tierCap || MAX_ITEM_TIER));
      const currentTier = Math.max(1, Math.floor(item.tier || 1));
      if (currentTier >= cap) return Infinity;
      const nextTier = Math.min(cap, currentTier + 1);
      return copiesRequiredForTier(nextTier);
    }
    function canUpgradeItem(item, tierCap = MAX_ITEM_TIER) {
      if (!item) return false;
      const cap = Math.max(1, Math.floor(tierCap || MAX_ITEM_TIER));
      if (item.tier >= cap) return false;
      const requirement = getNextTierRequirement(item, cap);
      return item.totalCopies >= requirement;
    }
    function upgradeLegacyItem(item, index) {
      const now = Date.now();
      if (!item || typeof item !== "object") {
        return cloneItem(KNIGHT_POOL[index % KNIGHT_POOL.length]);
      }
      const template = item.key ? KNIGHT_BY_KEY[item.key] : (KNIGHT_BY_NAME[item.name] || null);
      const key = (template && template.key) || item.key || `legacy-${index}`;
      const baseAtk = Number(item.baseAtk ?? item.atk ?? (template ? template.atk : 0) ?? 0);
      const baseDef = Number(item.baseDef ?? item.def ?? (template ? template.def : 0) ?? 0);
      const templateHp = Number((template && (template.hp ?? template.baseHp)) ?? 0);
      let baseHp = Number(item.baseHp);
      if (!Number.isFinite(baseHp)) {
        baseHp = templateHp > 0 ? templateHp : Number(item.hp ?? 0);
      }
      if (!Number.isFinite(baseHp)) baseHp = 0;
      const critDamagePercent = Number(item.critDamagePercent ?? (template ? template.critDamagePercent : 0) ?? 0);
      const tier = Math.max(1, Math.min(MAX_ITEM_TIER, Number(item.tier || 1)));
      const copiesSource = Number(item.totalCopies || item.copies || 0);
      const totalCopies = copiesSource > 0 ? copiesSource : 1;
      const createdAt = Number(item.createdAt || item.obtainedAt || now);
      const lastObtainedAt = Number(item.lastObtainedAt || item.updatedAt || createdAt);
      const name = item.name || (template ? template.name : `Relikt ${index + 1}`);
      const description = item.description || (template ? template.description : "Umgeschmiedet aus früheren Belohnungen.");
      const category = item.category || (template ? template.category : "weapon");
      const icon = item.icon || (template ? template.icon : (category === "armor" ? "shield" : category === "accessory" ? "talisman" : "sword"));
      const slot = normalizeItemSlot(item.slot) || (template ? normalizeItemSlot(template.slot) : null) || inferItemSlot({ icon, category });
      const theme = item.theme || (template ? template.theme : "knight");
      const normalized = {
        id: item.id || `${key}-${createdAt}-${Math.random().toString(16).slice(2, 6)}`,
        key,
        name,
        baseAtk,
        baseDef,
        baseHp,
        atk: baseAtk * tier,
        def: baseDef * tier,
        hp: baseHp,
        critDamagePercent,
        icon,
        slot,
        description,
        theme,
        category,
        tier,
        totalCopies,
        createdAt,
        lastObtainedAt
      };
      return normalized;
    }
    function cloneSkill(template) {
      const now = Date.now();
      return {
        id: `${template.key}-${now}-${Math.random().toString(16).slice(2, 6)}`,
        key: template.key,
        name: template.name,
        icon: template.icon || "skill_power",
        description: template.description || "Aktivierbarer Kampf-Skill.",
        effect: template.effect || "damage",
        basePower: Number(template.basePower || 4),
        powerPerTier: Number(template.powerPerTier || 2),
        tier: 1,
        totalCopies: 1,
        createdAt: now,
        lastObtainedAt: now
      };
    }
    function updateSkillDerivedStats(skill) {
      if (!skill) return skill;
      if (skill.key === "schattenschritt") {
        skill.key = HEALING_SKILL_KEY;
      }
      const template = skill.key ? SKILL_BY_KEY[skill.key] : null;
      if (template) {
        skill.name = template.name || skill.name;
        skill.icon = template.icon || skill.icon;
        skill.description = template.description || skill.description;
        skill.effect = template.effect || skill.effect;
        skill.basePower = Number(template.basePower ?? skill.basePower ?? 0);
        skill.powerPerTier = Number(template.powerPerTier ?? skill.powerPerTier ?? 0);
      }
      const safeTier = Math.max(1, Math.min(MAX_SKILL_TIER, Math.floor(skill.tier || 1)));
      const safeCopies = Math.max(1, Math.floor(skill.totalCopies || 1));
      const maxTier = maxTierFromCopies(safeCopies, MAX_SKILL_TIER);
      const tier = Math.min(safeTier, maxTier);
      skill.tier = tier;
      skill.totalCopies = safeCopies;
      skill.basePower = Number(skill.basePower || 0);
      skill.powerPerTier = Number(skill.powerPerTier || 0);
      const capCopies = copiesRequiredForTier(MAX_SKILL_TIER);
      const overcapCopies = Math.max(0, safeCopies - capCopies);
      const copiesPerPercent = 10;
      const naturalMaxPercent = Math.floor(overcapCopies / copiesPerPercent);
      if (!Number.isFinite(skill.overcapBonusPercent)) {
        skill.overcapBonusPercent = naturalMaxPercent;
      }
      skill.overcapBonusPercent = Math.max(0, Math.min(naturalMaxPercent, Math.floor(skill.overcapBonusPercent)));
      const magicInfo = getSkillOvercapInfo(skill);
      skill.overcapCopies = magicInfo.overcapCopies;
      skill.overcapBonusPercent = magicInfo.bonusPercent;
      skill.overcapProgress = magicInfo.progressTowardNextPercent;
      skill.copiesPerOvercapPercent = magicInfo.copiesPerPercent;
      skill.overcapAvailablePercent = magicInfo.availablePercent;
      if (!skill.createdAt) skill.createdAt = Date.now();
      if (!skill.lastObtainedAt) skill.lastObtainedAt = skill.createdAt;
      return skill;
    }
    function upgradeLegacySkill(skill, index) {
      const now = Date.now();
      if (!skill || typeof skill !== "object") {
        return cloneSkill(SKILL_POOL[index % SKILL_POOL.length]);
      }
      const template = skill.key ? SKILL_BY_KEY[skill.key] : null;
      const key = (template && template.key) || skill.key || `legacy-skill-${index}`;
      const basePower = Number(skill.basePower ?? (template ? template.basePower : 4) ?? 4);
      const powerPerTier = Number(skill.powerPerTier ?? (template ? template.powerPerTier : 2) ?? 2);
      const effect = skill.effect || (template ? template.effect : "damage");
      const tier = Math.max(1, Math.min(MAX_SKILL_TIER, Number(skill.tier || 1)));
      const copiesSource = Number(skill.totalCopies || skill.copies || 0);
      const totalCopies = copiesSource > 0 ? copiesSource : 1;
      const createdAt = Number(skill.createdAt || skill.obtainedAt || now);
      const lastObtainedAt = Number(skill.lastObtainedAt || skill.updatedAt || createdAt);
      const name = skill.name || (template ? template.name : `Skill ${index + 1}`);
      const description = skill.description || (template ? template.description : "Aktivierter Kampfspruch.");
      const icon = skill.icon || (template ? template.icon : "skill_power");
      const normalized = {
        id: skill.id || `${key}-${createdAt}-${Math.random().toString(16).slice(2, 6)}`,
        key,
        name,
        icon,
        description,
        effect,
        basePower,
        powerPerTier,
        tier,
        totalCopies,
        createdAt,
        lastObtainedAt
      };
      return updateSkillDerivedStats(normalized);
    }
    function ensureSkillInventory() {
      if (!Array.isArray(state.skills)) {
        state.skills = [];
        return;
      }
      const upgraded = state.skills.map((skill, index) => upgradeLegacySkill(skill, index));
      const merged = new Map();
      upgraded.forEach(skill => {
        if (!skill) return;
        const key = skill.key || skill.name || skill.id;
        if (!merged.has(key)) {
          merged.set(key, { ...skill });
        } else {
          const existing = merged.get(key);
          const existingCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
          const incomingCopies = Math.max(1, Math.floor(skill.totalCopies || 1));
          existing.totalCopies = existingCopies + incomingCopies;
          existing.lastObtainedAt = Math.max(
            Number(existing.lastObtainedAt || existing.createdAt || 0),
            Number(skill.lastObtainedAt || skill.createdAt || Date.now())
          );
          existing.createdAt = Math.min(
            Number(existing.createdAt || existing.lastObtainedAt || Date.now()),
            Number(skill.createdAt || skill.lastObtainedAt || Date.now())
          );
          existing.tier = Math.max(Number(existing.tier || 1), Number(skill.tier || 1));
        }
      });
      state.skills = Array.from(merged.values()).map(updateSkillDerivedStats);
      sortSkillsByNewest();
    }
    function ensureKnightInventory() {
      if (!Array.isArray(state.items)) {
        state.items = [];
        return;
      }
      const upgraded = state.items.map((item, index) => upgradeLegacyItem(item, index));
      const merged = new Map();
      upgraded.forEach(item => {
        if (!item) return;
        const key = item.key || item.name || item.id;
        if (!merged.has(key)) {
          merged.set(key, { ...item });
        } else {
          const existing = merged.get(key);
          const existingCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
          const incomingCopies = Math.max(1, Math.floor(item.totalCopies || 1));
          existing.totalCopies = existingCopies + incomingCopies;
          existing.lastObtainedAt = Math.max(
            Number(existing.lastObtainedAt || existing.createdAt || 0),
            Number(item.lastObtainedAt || item.createdAt || Date.now())
          );
          existing.createdAt = Math.min(
            Number(existing.createdAt || existing.lastObtainedAt || Date.now()),
            Number(item.createdAt || item.lastObtainedAt || Date.now())
          );
          existing.tier = Math.max(Number(existing.tier || 1), Number(item.tier || 1));
        }
      });
      state.items = Array.from(merged.values()).map(updateItemDerivedStats);
      sortInventoryByNewest();
      ensureEquipmentState();
    }
    function ensureEquipmentState() {
      if (typeof state.equipment !== "object" || !state.equipment) {
        state.equipment = {};
      }
      if ("trinket" in state.equipment) {
        const legacy = state.equipment.trinket;
        if (legacy && !state.equipment.necklace) {
          state.equipment.necklace = legacy;
        }
        delete state.equipment.trinket;
      }
      EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
        if (!Object.prototype.hasOwnProperty.call(state.equipment, slotKey)) {
          state.equipment[slotKey] = null;
        }
        const equippedKey = state.equipment[slotKey];
        if (!equippedKey) {
          state.equipment[slotKey] = null;
          return;
        }
        const itemExists = state.items.some(entry => entry && (entry.key || entry.name) === equippedKey);
        if (!itemExists) {
          state.equipment[slotKey] = null;
        }
      });
      Object.keys(state.equipment).forEach(slotKey => {
        if (!EQUIPMENT_SLOT_DEFS[slotKey]) {
          delete state.equipment[slotKey];
        }
      });
    }
    function clearItemFromOtherSlots(itemKey, keepSlot = null) {
      if (!itemKey) return;
      ensureEquipmentState();
      EQUIPMENT_SLOT_KEYS.forEach(slot => {
        if (slot === keepSlot) return;
        if (state.equipment[slot] === itemKey) {
          state.equipment[slot] = null;
        }
      });
    }
    function evaluateItemPower(item) {
      if (!item) return -Infinity;
      updateItemDerivedStats(item);
      const atk = Number(item.atk) || 0;
      const def = Number(item.def) || 0;
      const hp = Number(item.hp || item.maxHp || 0);
      return atk * 10000 + def * 100 + hp;
    }
    function autoEquipBest() {
      if (!state.items.length) {
        updateUI();
        return;
      }
      ensureEquipmentState();
      const pool = state.items
        .map(item => ({ item, power: evaluateItemPower(item) }))
        .sort((a, b) => b.power - a.power);
      const used = new Set();
      const updatedEquipment = {};
      EQUIPMENT_SLOT_KEYS.forEach(slot => {
        updatedEquipment[slot] = null;
      });
      const slotOrder = [];
      AUTO_EQUIP_SLOT_ORDER.forEach(slot => {
        if (EQUIPMENT_SLOT_DEFS[slot]) slotOrder.push(slot);
      });
      EQUIPMENT_SLOT_KEYS.forEach(slot => {
        if (!slotOrder.includes(slot)) slotOrder.push(slot);
      });
      slotOrder.forEach(slotKey => {
        const bestEntry = pool.find(entry => {
          const key = entry.item.key || entry.item.name;
          if (used.has(key)) return false;
          return itemMatchesSlot(entry.item, slotKey);
        });
        if (bestEntry) {
          const key = bestEntry.item.key || bestEntry.item.name;
          updatedEquipment[slotKey] = key;
          used.add(key);
        }
      });
      state.equipment = updatedEquipment;
      recalcStats();
      saveState();
      updateUI();
    }

    function unequipAllSlots() {
      ensureEquipmentState();
      let changed = false;
      EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
        if (state.equipment[slotKey]) {
          state.equipment[slotKey] = null;
          changed = true;
        }
      });
      if (!changed) return;
      recalcStats();
      saveState();
      updateUI();
    }
    function getItemByKey(key) {
      if (!key) return null;
      return state.items.find(entry => entry && (entry.key || entry.name) === key) || null;
    }
    function itemMatchesSlot(item, slotKey) {
      if (!item || !slotKey) return false;
      const normalizedSlot = normalizeItemSlot(slotKey);
      if (!normalizedSlot) return false;
      const meta = EQUIPMENT_SLOT_DEFS[normalizedSlot];
      const itemKey = item.key || item.name;
      if (meta && Array.isArray(meta.allowedKeys) && meta.allowedKeys.length) {
        return Boolean(itemKey && meta.allowedKeys.includes(itemKey));
      }
      const tokenPool = [
        normalizeItemSlot(item.slot),
        (item.category || "").toLowerCase(),
        (item.icon || "").toLowerCase()
      ].filter(Boolean);
      if (tokenPool.includes(normalizedSlot)) return true;
      if (!meta || !meta.accepts) return false;
      return tokenPool.some(token => meta.accepts.includes(token));
    }
    function getEquippedItems() {
      ensureEquipmentState();
      const items = [];
      EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
        const eqKey = state.equipment[slotKey];
        if (!eqKey) return;
        const item = getItemByKey(eqKey);
        if (item) items.push(item);
      });
      return items;
    }
    function getEquippedItemForSlot(slotKey) {
      if (!slotKey) return null;
      ensureEquipmentState();
      const eqKey = state.equipment[slotKey];
      if (!eqKey) return null;
      return getItemByKey(eqKey);
    }
    function getCompletedSectionCount() {
      if (!state || typeof state.sectionClears !== "object") return 0;
      let count = 0;
      Object.keys(state.sectionClears).forEach(sectionId => {
        if (state.sectionClears[sectionId] > 0) count += 1;
      });
      return count;
    }
    function getRunenAmuletCoinBonusPercent() {
      const equippedRunen = getEquippedItems().find(item => item && item.key === RUNEN_AMULET_KEY);
      if (!equippedRunen) return 0;
      const tier = Math.max(1, Math.floor(equippedRunen.tier || 1));
      if (tier >= 5) {
        const completed = getCompletedSectionCount();
        return Math.min(RUNEN_AMULET_DYNAMIC_CAP, completed);
      }
      return RUNEN_AMULET_TIER_BONUS[tier] || RUNEN_AMULET_TIER_BONUS[4];
    }
    function applyCoinBonus(baseAmount) {
      const amount = Number(baseAmount) || 0;
      if (amount <= 0) return amount;
      const bonusPercent = getRunenAmuletCoinBonusPercent();
      if (!bonusPercent) return amount;
      return Math.max(0, Math.round(amount * (1 + bonusPercent / 100)));
    }
    function recalcStats() {
      let atk = BASE_ATK;
      let def = BASE_DEF;
      let hp = 0;
      let critDamageBonus = 0;
      getEquippedItems().forEach(item => {
        updateItemDerivedStats(item);
        atk += Number(item.atk || 0);
        def += Number(item.def || 0);
        hp += Number(item.hp || item.maxHp || 0);
        critDamageBonus += Number(item.critDamagePercent || 0);
      });
      state.atk = atk;
      state.def = def;
      state.hp = hp;
      state.critDamagePercent = Math.max(0, critDamageBonus);
    }
    function getHeroMaxHp() {
      const gearHp = Math.max(0, Math.round(state.hp || 0));
      const defenseBonus = Math.max(0, state.def) * HP_PER_DEF;
      return Math.max(1, BASE_HP + gearHp + defenseBonus);
    }
    function getItemIcon(iconKey, itemKey) {
      // Prefer explicit iconKey. If missing or legacy 'sword', try resolving via the item key / template.
      let ik = iconKey;
      if ((!ik || String(ik).toLowerCase() === "sword") && itemKey && typeof KNIGHT_BY_KEY === 'object') {
        const byKey = KNIGHT_BY_KEY[itemKey];
        if (byKey && byKey.icon) ik = byKey.icon;
      }
      if (!ik) return ITEM_ART.default;
      const key = String(ik);
      // If icon references an external sword asset like "sword_fire", use the file in assets/
      if (key.startsWith("sword_")) {
        // sanitize to avoid unexpected chars
        const safe = key.replace(/[^a-z0-9_\-]/gi, "");
        return `<img src="assets/${safe}.svg" alt="${safe}" loading="lazy">`;
      }
      return ITEM_ART[ik] || ITEM_ART.default;
    }
    function buildItemTierIndicator(item, overrides = {}) {
      if (!item) return null;
      const indicator = document.createElement("div");
      indicator.className = "skill-bonus-indicator";
      const tierClassValue = overrides.tierClass ?? item.tier;
      const indicatorTier = Math.max(1, Math.min(MAX_ITEM_TIER, Math.floor(tierClassValue || 1)));
      indicator.classList.add(`tier-${indicatorTier}`);
      indicator.dataset.skillBonusReady = "false";
      indicator.setAttribute("aria-hidden", overrides.readOnly ? "true" : "false");
      const headerRow = document.createElement("div");
      headerRow.className = "skill-bonus-header";
      const title = document.createElement("div");
      title.className = "skill-bonus-title";
      const progressLabel = document.createElement("span");
      progressLabel.className = "skill-bonus-progress-label";
      headerRow.appendChild(title);
      headerRow.appendChild(progressLabel);
      const bar = document.createElement("div");
      bar.className = "skill-bonus-progress";
      const fill = document.createElement("div");
      fill.className = "skill-bonus-progress-fill";
      bar.appendChild(fill);
      const metaRow = document.createElement("div");
      metaRow.className = "skill-bonus-meta";
      const status = document.createElement("span");
      const requirement = getNextTierRequirement(item);
      const displayTier = overrides.displayTier ?? item.tier;
      const nextTierDisplay = overrides.nextTier ?? (
        displayTier >= MAX_ITEM_TIER ? displayTier : Math.min(displayTier + 1, MAX_ITEM_TIER)
      );
      title.textContent = displayTier >= MAX_ITEM_TIER
        ? `Tier ${displayTier} (MAX)`
        : `Tier ${displayTier} ➜ Tier ${nextTierDisplay}`;
      let progressCap = overrides.progressMax;
      let infiniteCap = false;
      if (progressCap === Infinity) {
        infiniteCap = true;
      } else if (!Number.isFinite(progressCap) || progressCap <= 0) {
        const baseRequirement = requirement === Infinity ? item.totalCopies || 1 : requirement;
        if (baseRequirement === Infinity) {
          infiniteCap = true;
        } else {
          progressCap = Math.max(1, baseRequirement);
        }
      }
      let progressValue;
      if (Number.isFinite(overrides.progressValue)) {
        progressValue = Math.max(0, overrides.progressValue);
      } else if (infiniteCap) {
        progressValue = item.totalCopies || 0;
      } else {
        progressValue = Math.min(item.totalCopies, progressCap || 1);
      }
      const progressRatio = infiniteCap
        ? 1
        : (progressCap ? Math.min(1, Math.max(0, progressValue / (progressCap || 1))) : 0);
      fill.style.width = `${progressRatio * 100}%`;
      const progressLabelText = overrides.progressLabel
        ? overrides.progressLabel
        : (infiniteCap ? `${progressValue}/∞` : `${progressValue}/${progressCap}`);
      progressLabel.textContent = progressLabelText;
      if (overrides.statusText !== undefined) {
        status.textContent = overrides.statusText;
        if (overrides.statusClass) status.className = overrides.statusClass;
      } else if (canUpgradeItem(item) && item.tier < MAX_ITEM_TIER) {
        status.className = "skill-bonus-ready";
        status.textContent = "Upgrade bereit";
      } else if (item.tier >= MAX_ITEM_TIER) {
        status.textContent = "Maximum erreicht";
      } else {
        status.textContent = "";
      }
      metaRow.appendChild(status);
      indicator.appendChild(headerRow);
      indicator.appendChild(bar);
      indicator.appendChild(metaRow);
      return indicator;
    }
    function createInventoryRow(item, options = {}) {
      const { showUpgrade = true, showProgressIndicator = true, progressIndicatorOverrides = null } = options;
      if (!item) return null;
      updateItemDerivedStats(item);
      const normalizedKey = item.key || item.name;
      const normalizedCategory = normalizeItemCategory(item.category);
      const row = document.createElement("div");
      row.className = `inventory-item tier-${item.tier}`;
      row.dataset.itemKey = normalizedKey;
      row.dataset.category = normalizedCategory;
        const equipSlots = getEquipSlotsForItem(item);

      const left = document.createElement("div");
      left.className = "item-left";
      const icon = document.createElement("div");
      icon.className = "item-icon";
  icon.innerHTML = getItemIcon(item.icon, item.key);
      const text = document.createElement("div");
      text.className = "item-text";
      const nameEl = document.createElement("strong");
      nameEl.textContent = item.name;
      text.appendChild(nameEl);
      const categoryLabel = GACHA_CATEGORY_LABELS[item.category] || item.category || "";
      const descText = item.description ? item.description : (categoryLabel ? `Kategorie: ${categoryLabel}` : "");
      if (descText) {
        const desc = document.createElement("span");
        desc.textContent = descText;
        text.appendChild(desc);
      }
      left.appendChild(icon);
      left.appendChild(text);
      row.appendChild(left);

      const controls = document.createElement("div");
      controls.className = "item-controls";
      const stats = document.createElement("div");
      stats.className = "item-stats";
      const statBadges = collectItemStats(item);
      statBadges.forEach(({ label, value, className }) => {
        const badge = document.createElement("span");
        badge.className = `badge ${className || "atk"}`;
        badge.textContent = `${label} +${value}`;
        stats.appendChild(badge);
      });
      controls.appendChild(stats);
    if (equipSlots && equipSlots.length) {
      const alreadyEquipped = equipSlots.some(slot => state.equipment && state.equipment[slot] === normalizedKey);
      if (!alreadyEquipped) {
        equipSlots.forEach(targetSlot => {
          const equipBtn = document.createElement("button");
          equipBtn.className = "item-equip";
          equipBtn.dataset.itemKey = normalizedKey;
          equipBtn.dataset.slotKey = targetSlot;
          const slotLabel = getSlotButtonLabel(targetSlot);
          const normalizedCategory = normalizeItemCategory(item.category);
          const isAccessory = normalizedCategory === "accessory";
          const label = isAccessory ? "Anziehen" : `Anziehen (${slotLabel})`;
          equipBtn.textContent = label;
          equipBtn.disabled = false;
          controls.appendChild(equipBtn);
        });
      }
    }
      if (showProgressIndicator) {
        const indicator = buildItemTierIndicator(item, progressIndicatorOverrides || {});
        if (indicator) {
          const canUpgrade = canUpgradeItem(item) && item.tier < MAX_ITEM_TIER;
          indicator.dataset.itemUpgrade = "true";
          indicator.dataset.itemKey = item.key || item.name;
          indicator.dataset.itemUpgradeReady = String(canUpgrade);
          indicator.tabIndex = canUpgrade ? 0 : -1;
          indicator.setAttribute("role", canUpgrade ? "button" : "img");
          indicator.setAttribute("aria-disabled", String(!canUpgrade));
          controls.appendChild(indicator);
        }
      }
      row.appendChild(controls);
      return row;
    }
    function createSkillRow(skill, options = {}) {
      const {
        showUpgrade = true,
        allowBonusActivation = true,
        progressIndicatorOverrides = null
      } = options;
      if (!skill) return null;
      updateSkillDerivedStats(skill);
      const row = document.createElement("div");
      row.className = `inventory-item tier-${skill.tier}`;
      row.dataset.skillKey = skill.key || skill.name;
      const left = document.createElement("div");
      left.className = "item-left";
      const icon = document.createElement("div");
      icon.className = "item-icon";
  icon.innerHTML = getItemIcon(skill.icon, skill.key);
      const text = document.createElement("div");
      text.className = "item-text";
      const nameEl = document.createElement("strong");
      nameEl.textContent = skill.name;
      text.appendChild(nameEl);
      if (skill.description) {
        const desc = document.createElement("span");
        desc.textContent = skill.description;
        text.appendChild(desc);
      }
      const requirement = getNextTierRequirement(skill, MAX_SKILL_TIER);
      const isMagicRed = (progressIndicatorOverrides && progressIndicatorOverrides.forceMagicRed) || skill.tier >= MAX_SKILL_TIER;
      const bonusPercent = Number(skill.overcapBonusPercent || 0);
      const bonusLabel = bonusPercent > 0 ? ` +${bonusPercent}%` : "";
      const magicInfo = getSkillOvercapInfo(skill);
      const readyCount = Math.max(0, magicInfo.availablePercent);
      const isReady = readyCount > 0;
      const progressDisplayValue = isReady && magicInfo.progressTowardNextPercent === 0
        ? magicInfo.copiesPerPercent
        : magicInfo.progressTowardNextPercent;
      left.appendChild(icon);
      left.appendChild(text);
      row.appendChild(left);
      const controls = document.createElement("div");
      controls.className = "item-controls";
      const stats = document.createElement("div");
      stats.className = "item-stats";
      const badge = document.createElement("span");
      badge.className = "badge atk";
      const effectValue = getSkillEffectivePower(skill);
      const bonusText = bonusPercent ? ` (+${bonusPercent}%)` : "";
      switch (skill.effect) {
        case "damage":
          badge.textContent = `Schaden +${effectValue}${bonusText}`;
          break;
        case "heal":
          badge.className = "badge def";
          badge.textContent = `Heilung +${effectValue}${bonusText}`;
          break;
        case "buff_atk":
          badge.textContent = `ATK Buff +${effectValue}${bonusText}`;
          break;
        case "debuff_enemy":
          badge.className = "badge def";
          badge.textContent = `Enemy ATK -${effectValue}${bonusText}`;
          break;
        case "shield_wall":
          badge.className = "badge def";
          badge.textContent = `+DEF ${effectValue} (${SHIELD_WALL_MAX_CHARGES}x)${bonusText}`;
          break;
        default:
          badge.textContent = `Tier ${skill.tier}`;
      }
      stats.appendChild(badge);
      controls.appendChild(stats);
      const canUpgradeSkill = canUpgradeItem(skill, MAX_SKILL_TIER);
      const bonusIndicator = document.createElement("div");
      bonusIndicator.className = "skill-bonus-indicator";
      const indicatorOverrides = progressIndicatorOverrides || {};
      const indicatorTierClass = Math.max(1, Math.min(MAX_SKILL_TIER, Math.floor(indicatorOverrides.tierClass ?? Math.min(skill.tier, MAX_SKILL_TIER))));
      bonusIndicator.classList.add(`tier-${indicatorTierClass}`);
      bonusIndicator.setAttribute("aria-hidden", indicatorOverrides.readOnly ? "true" : "false");
      const title = document.createElement("div");
      title.className = "skill-bonus-title";
      const headerRow = document.createElement("div");
      headerRow.className = "skill-bonus-header";
      const progressLabel = document.createElement("span");
      progressLabel.className = "skill-bonus-progress-label";
      headerRow.appendChild(title);
      headerRow.appendChild(progressLabel);
      const bar = document.createElement("div");
      bar.className = "skill-bonus-progress";
      const fill = document.createElement("div");
      fill.className = "skill-bonus-progress-fill";
      bar.appendChild(fill);
      const metaRow = document.createElement("div");
      metaRow.className = "skill-bonus-meta";
      const status = document.createElement("span");
      if (isMagicRed) {
        if (allowBonusActivation) {
          bonusIndicator.dataset.skillBonus = "true";
          bonusIndicator.dataset.skillBonusKey = skill.key || skill.name;
          bonusIndicator.dataset.skillBonusReady = String(isReady);
          bonusIndicator.setAttribute("role", "button");
          bonusIndicator.setAttribute("aria-disabled", String(!isReady));
          bonusIndicator.tabIndex = isReady ? 0 : -1;
        } else {
          bonusIndicator.dataset.skillBonusReady = "false";
          bonusIndicator.setAttribute("aria-hidden", "true");
        }
        const bonusStageValue = Math.max(0, Number(indicatorOverrides.bonusStage ?? bonusPercent) || 0);
        title.textContent = indicatorOverrides.titleText || `Tier-6 (Bonusstufe ${bonusStageValue})`;
        const progressCap = indicatorOverrides.progressMax ?? magicInfo.copiesPerPercent;
        const progressValueCustom = indicatorOverrides.progressValue ?? progressDisplayValue;
        const forceFull = indicatorOverrides.forceFullProgress ?? true;
        const showFullProgress = forceFull && readyCount > 0 && Number.isFinite(progressCap) && progressCap > 0;
        const effectiveValue = showFullProgress ? progressCap : progressValueCustom;
        const ratio = progressCap === Infinity
          ? 1
          : (progressCap ? Math.min(1, Math.max(0, effectiveValue / progressCap)) : 0);
        fill.style.width = `${ratio * 100}%`;
        const progressLabelText = indicatorOverrides.progressLabel
          ? indicatorOverrides.progressLabel
          : (progressCap === Infinity ? `${effectiveValue}/∞` : `${effectiveValue}/${progressCap}`);
        progressLabel.textContent = progressLabelText;
        if (indicatorOverrides.statusText !== undefined) {
          status.textContent = indicatorOverrides.statusText;
          if (indicatorOverrides.statusClass) status.className = indicatorOverrides.statusClass;
        } else if (isReady) {
          status.className = "skill-bonus-ready";
          status.textContent = readyCount > 1 ? `${readyCount}x Upgrade bereit` : "Upgrade bereit";
        } else {
          status.textContent = "";
        }
        if (indicatorOverrides.ariaLabel) {
          bonusIndicator.setAttribute("aria-label", indicatorOverrides.ariaLabel);
        } else {
          const ariaBits = [`Tier-6 Bonus Fortschritt ${progressLabelText}`];
          ariaBits.push(isReady ? "Upgrade bereit." : "Noch nicht bereit.");
          bonusIndicator.setAttribute("aria-label", ariaBits.join(" "));
        }
      } else {
        const displayTierOverride = indicatorOverrides.displayTier ?? skill.tier;
        const nextTierOverride = indicatorOverrides.nextTier ?? Math.min(MAX_SKILL_TIER, skill.tier + 1);
        if (indicatorOverrides.titleText) {
          title.textContent = indicatorOverrides.titleText;
        } else {
          title.textContent = displayTierOverride >= MAX_SKILL_TIER
            ? `Tier ${displayTierOverride} (MAX)`
            : `Tier ${displayTierOverride} ➜ Tier ${nextTierOverride}`;
        }
        let progressCap = indicatorOverrides.progressMax;
        let infiniteCap = false;
        if (progressCap === Infinity) {
          infiniteCap = true;
        } else if (!Number.isFinite(progressCap) || progressCap <= 0) {
          if (requirement === Infinity) {
            infiniteCap = true;
          } else {
            progressCap = Math.max(1, requirement);
          }
        }
        let progressValue;
        if (Number.isFinite(indicatorOverrides.progressValue)) {
          progressValue = Math.max(0, indicatorOverrides.progressValue);
        } else if (infiniteCap) {
          progressValue = Math.min(skill.totalCopies, requirement === Infinity ? skill.totalCopies : Number.MAX_SAFE_INTEGER);
        } else {
          progressValue = Math.min(skill.totalCopies, progressCap || 1);
        }
        const progressRatio = infiniteCap
          ? 1
          : (progressCap ? Math.min(1, Math.max(0, progressValue / progressCap)) : 0);
        fill.style.width = `${progressRatio * 100}%`;
        const progressLabelText = indicatorOverrides.progressLabel
          ? indicatorOverrides.progressLabel
          : (infiniteCap ? `${progressValue}/∞` : `${progressValue}/${progressCap}`);
        progressLabel.textContent = progressLabelText;
        if (indicatorOverrides.statusText !== undefined) {
          status.textContent = indicatorOverrides.statusText;
          if (indicatorOverrides.statusClass) status.className = indicatorOverrides.statusClass;
        } else if (canUpgradeSkill) {
          status.className = "skill-bonus-ready";
          status.textContent = "Upgrade bereit";
        } else if (Number.isFinite(requirement)) {
          status.textContent = "";
        } else {
          status.textContent = "Maximum erreicht";
        }
        if (allowBonusActivation) {
          bonusIndicator.dataset.skillUpgrade = "true";
          bonusIndicator.dataset.skillUpgradeKey = skill.key || skill.name;
          const upgradeReady = canUpgradeSkill && skill.tier < MAX_SKILL_TIER;
          bonusIndicator.dataset.skillUpgradeReady = String(upgradeReady);
          bonusIndicator.setAttribute("role", "button");
          bonusIndicator.setAttribute("aria-disabled", String(!upgradeReady));
          bonusIndicator.tabIndex = upgradeReady ? 0 : -1;
        } else {
          bonusIndicator.dataset.skillUpgradeReady = "false";
          bonusIndicator.setAttribute("aria-hidden", "true");
        }
        const ariaLabel = indicatorOverrides.ariaLabel
          ? indicatorOverrides.ariaLabel
          : `Tier ${displayTierOverride} Fortschritt ${progressLabelText}`;
        bonusIndicator.setAttribute("aria-label", ariaLabel);
      }
      metaRow.appendChild(status);
      bonusIndicator.appendChild(headerRow);
      bonusIndicator.appendChild(bar);
      bonusIndicator.appendChild(metaRow);
      controls.appendChild(bonusIndicator);
      row.appendChild(controls);
      return row;
    }
    function renderInventory() {
      if (!inventoryList) return;
      ensureEquipmentState();
      inventoryList.innerHTML = "";
      const hasItems = Boolean(state.items.length);
      const emptyNotice = document.getElementById("inventoryEmpty");
      if (emptyNotice) emptyNotice.style.display = hasItems ? "none" : "block";
      if (inventoryFilterEmpty) {
        inventoryFilterEmpty.hidden = true;
        inventoryFilterEmpty.style.display = "none";
      }
      if (!hasItems) return;
      const filterValue = currentInventoryFilter || DEFAULT_INVENTORY_FILTER;
      const itemTimestamp = entry => Number(entry.lastObtainedAt || entry.createdAt || 0);
      const equippedKeys = new Set(
        Object.values(state.equipment || {}).filter(Boolean)
      );
      const getCategoryRank = item => {
        const normalizedCategory = normalizeItemCategory(item.category);
        return Object.prototype.hasOwnProperty.call(INVENTORY_CATEGORY_ORDER, normalizedCategory)
          ? INVENTORY_CATEGORY_ORDER[normalizedCategory]
          : 999;
      };
      const matchesFilter = item => {
        const category = normalizeItemCategory(item.category);
        return filterValue === "all" || category === filterValue;
      };
      const getItemKeyValue = item => (item && (item.key || item.name)) || null;
      const sortCurrentFilter = () => {
        const sorted = state.items
          .filter(matchesFilter)
          .sort((a, b) => {
            if (filterValue === "all") {
              const categoryDiff = getCategoryRank(a) - getCategoryRank(b);
              if (categoryDiff !== 0) return categoryDiff;
            }
            const equipRank = (equippedKeys.has(getItemKeyValue(a)) ? 0 : 1) - (equippedKeys.has(getItemKeyValue(b)) ? 0 : 1);
            if (equipRank !== 0) return equipRank;
            return itemTimestamp(b) - itemTimestamp(a);
          });
        currentInventoryOrder = sorted.map(getItemKeyValue).filter(Boolean);
        inventoryNeedsResort = false;
        return sorted;
      };
      const itemMap = new Map();
      state.items.forEach(item => {
        const key = getItemKeyValue(item);
        if (!key) return;
        itemMap.set(key, item);
      });
      const ensureOrderValidity = () => {
        const availableKeys = new Set(itemMap.keys());
        currentInventoryOrder = currentInventoryOrder.filter(key => availableKeys.has(key));
      };
      let orderedItems = [];
      if (inventoryNeedsResort) {
        orderedItems = sortCurrentFilter();
      } else {
        ensureOrderValidity();
        const orderSet = new Set(currentInventoryOrder);
        currentInventoryOrder.forEach(key => {
          const item = itemMap.get(key);
          if (!item || !matchesFilter(item)) return;
          orderedItems.push(item);
        });
        itemMap.forEach((item, key) => {
          if (orderSet.has(key)) return;
          currentInventoryOrder.push(key);
          orderSet.add(key);
          if (matchesFilter(item)) orderedItems.push(item);
        });
      }
      let visibleCount = 0;
      orderedItems.forEach(item => {
        const category = normalizeItemCategory(item.category);
        const row = createInventoryRow(item, { showUpgrade: true });
        if (row) {
          row.dataset.category = category;
          row.dataset.equipped = String(equippedKeys.has(getItemKeyValue(item)));
          inventoryList.appendChild(row);
          visibleCount += 1;
        }
      });
      if (inventoryFilterEmpty) {
        if (visibleCount === 0) {
          inventoryFilterEmpty.hidden = false;
          inventoryFilterEmpty.style.display = "block";
        } else {
          inventoryFilterEmpty.hidden = true;
          inventoryFilterEmpty.style.display = "none";
        }
      }
    }
    function equipItem(preferredSlot, itemKey) {
      ensureEquipmentState();
      const item = getItemByKey(itemKey);
      if (!item) return;
      const resolvedSlot = normalizeItemSlot(preferredSlot) || getItemSlot(item);
      if (!resolvedSlot || !EQUIPMENT_SLOT_DEFS[resolvedSlot]) return;
      if (!itemMatchesSlot(item, resolvedSlot)) return;
      const targetKey = item.key || item.name;
      clearItemFromOtherSlots(targetKey, resolvedSlot);
      if (state.equipment[resolvedSlot] === targetKey) return;
      state.equipment[resolvedSlot] = targetKey;
      recalcStats();
      saveState();
      updateUI();
    }
    function unequipSlot(slotKey) {
      const normalized = normalizeItemSlot(slotKey);
      if (!normalized) return;
      ensureEquipmentState();
      if (!state.equipment[normalized]) return;
      state.equipment[normalized] = null;
      recalcStats();
      saveState();
      updateUI();
    }
    function collectItemStats(item) {
      if (!item) return [];
      const stats = [];
      const push = (label, value, className) => {
        if (value === undefined || value === null) return;
        const numeric = Number(value);
        if (!Number.isNaN(numeric)) {
          if (numeric === 0) return;
          stats.push({ label, value: numeric, className });
          return;
        }
        if (String(value).trim()) stats.push({ label, value: String(value), className });
      };
      push("ATK", item.atk, "atk");
      if (item.key === RUNEN_AMULET_KEY) {
        const bonus = `${getRunenAmuletCoinBonusPercent()}%`;
        stats.push({ label: "Münzen", value: bonus, className: "atk" });
      } else {
        push("DEF", item.def, "def");
      }
      const hpValue = Number(item.hp || item.maxHp || 0);
      if (hpValue > 0) {
        stats.push({ label: "HP", value: hpValue, className: "def" });
      }
      const critBonus = Number(item.critDamagePercent || 0);
      if (critBonus > 0) {
        stats.push({ label: "Krit-Schaden", value: `${critBonus}%`, className: "atk" });
      }
      return stats;
    }
    function renderEquipmentSlots() {
      ensureEquipmentState();
      EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
        const slotEl = equipmentSlotMap[slotKey];
        if (!slotEl) return;
        const meta = EQUIPMENT_SLOT_DEFS[slotKey] || {};
        const iconEl = slotEl.querySelector(".slot-icon");
        const nameEl = slotEl.querySelector(".slot-name");
        const metaEl = slotEl.querySelector(".slot-meta");
        const statsEl = slotEl.querySelector(".slot-stats");
        const clearBtn = slotEl.querySelector(".slot-unequip");
        const headerLabel = slotEl.querySelector(".slot-header span");
        let progressHost = slotEl.querySelector(".slot-progress");
        if (!progressHost) {
          const infoWrapper = slotEl.querySelector(".slot-info");
          if (infoWrapper) {
            progressHost = document.createElement("div");
            progressHost.className = "slot-progress";
            infoWrapper.appendChild(progressHost);
          }
        }
        const equippedKey = state.equipment[slotKey];
        const item = getItemByKey(equippedKey);
        for (let tier = 1; tier <= MAX_ITEM_TIER; tier += 1) {
          slotEl.classList.remove(`tier-${tier}`);
        }
        if (!item) {
          slotEl.classList.remove("equipped");
          if (headerLabel) headerLabel.textContent = meta.label || slotKey.toUpperCase();
          if (nameEl) nameEl.textContent = "Leer";
          if (metaEl) metaEl.textContent = meta.empty || "Slot frei";
          if (statsEl) statsEl.innerHTML = "";
          if (iconEl) iconEl.innerHTML = '<span class="slot-placeholder">?</span>';
          if (clearBtn) clearBtn.hidden = true;
          if (progressHost) {
            progressHost.innerHTML = "";
            progressHost.style.display = "none";
          }
          return;
        }
        slotEl.classList.add("equipped");
        const tierClass = `tier-${Math.min(MAX_ITEM_TIER, Math.max(1, Number(item.tier) || 1))}`;
        slotEl.classList.add(tierClass);
        if (headerLabel) headerLabel.textContent = item.name || meta.label || slotKey;
        if (nameEl) nameEl.textContent = item.name;
        if (metaEl) {
          metaEl.textContent = meta.label || slotKey;
        }
        const statBadges = collectItemStats(item);
        if (statsEl) {
          statsEl.innerHTML = "";
          statBadges.forEach(({ label, value, className }) => {
            const chip = document.createElement("span");
            chip.className = `badge ${className} inventory-stat-badge`;
            chip.textContent = `${label} +${value}`;
            statsEl.appendChild(chip);
          });
        }
        if (iconEl) {
          iconEl.innerHTML = getItemIcon(item.icon, item.key);
        }
        if (progressHost) {
          progressHost.innerHTML = "";
          progressHost.style.display = "none";
        }
        if (clearBtn) {
          clearBtn.hidden = false;
          clearBtn.dataset.slot = slotKey;
        }
      });
    }
    function renderSkills() {
      if (!skillList) return;
      skillList.innerHTML = "";
      const uniqueSkills = state.skills.length;
      const totalCopies = state.skills.reduce((sum, skill) => {
        return sum + Math.max(1, Math.floor(skill.totalCopies || 1));
      }, 0);
      if (!uniqueSkills) {
        if (skillEmpty) skillEmpty.style.display = "block";
        return;
      }
      if (skillEmpty) skillEmpty.style.display = "none";
      const sorted = [...state.skills].sort((a, b) => {
        const left = b.lastObtainedAt || b.createdAt || 0;
        const right = a.lastObtainedAt || a.createdAt || 0;
        return left - right;
      });
      sorted.forEach(skill => {
        const row = createSkillRow(skill, { showUpgrade: true });
        if (row) skillList.appendChild(row);
      });
    }
    function renderShopLatest() {
      if (!shopLatest) return;
      shopLatest.querySelectorAll(".inventory-item").forEach(el => el.remove());
      let record = state.lastShopPurchase;
      if (!record) {
        let latestItem = null;
        if (state.items.length) {
          latestItem = [...state.items].sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0))[0];
        }
        let latestSkill = null;
        if (state.skills.length) {
          latestSkill = [...state.skills].sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0))[0];
        }
        if (latestItem || latestSkill) {
          if (latestItem && latestSkill) {
            const itemTime = latestItem.lastObtainedAt || latestItem.createdAt || 0;
            const skillTime = latestSkill.lastObtainedAt || latestSkill.createdAt || 0;
            record = itemTime >= skillTime ? { type: "item", key: latestItem.key } : { type: "skill", key: latestSkill.key };
          } else if (latestItem) {
            record = { type: "item", key: latestItem.key };
          } else if (latestSkill) {
            record = { type: "skill", key: latestSkill.key };
          }
        }
      }
      if (!record) {
        if (shopLatestEmpty) shopLatestEmpty.style.display = "block";
        return;
      }
      let row = null;
      if (record.type === "item") {
        const item = state.items.find(entry => entry.key === record.key);
        if (item) {
          row = createInventoryRow(item, {
            showUpgrade: false,
            showProgressIndicator: true,
            progressIndicatorOverrides: {
              tierClass: 1,
              readOnly: true
            }
          });
        }
      } else if (record.type === "skill") {
        const skill = state.skills.find(entry => entry.key === record.key);
        if (skill) {
          row = createSkillRow(skill, {
            showUpgrade: false,
            allowBonusActivation: false,
            progressIndicatorOverrides: {
              tierClass: 1,
              readOnly: true
            }
          });
        }
      }
      if (!row) {
        if (shopLatestEmpty) shopLatestEmpty.style.display = "block";
        return;
      }
      if (shopLatestEmpty) shopLatestEmpty.style.display = "none";
      shopLatest.appendChild(row);
    }
    function sortInventoryByNewest() {
      state.items.sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0));
    }
    function sortSkillsByNewest() {
      state.skills.sort((a, b) => (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0));
    }
    function triggerItemUpgrade(key) {
      const item = state.items.find(entry => (entry.key || entry.name) === key);
      if (!item || !canUpgradeItem(item)) return;
      item.tier = Math.min(MAX_ITEM_TIER, item.tier + 1);
      item.lastUpgradeAt = Date.now();
      updateItemDerivedStats(item);
      recalcStats();
      saveState();
      sortInventoryByNewest();
      updateUI();
    }
    function triggerSkillUpgrade(key) {
      const skill = state.skills.find(entry => (entry.key || entry.name) === key);
      if (!skill || !canUpgradeItem(skill, MAX_SKILL_TIER)) return;
      skill.tier = Math.min(MAX_SKILL_TIER, skill.tier + 1);
      skill.lastUpgradeAt = Date.now();
      updateSkillDerivedStats(skill);
      saveState();
      sortSkillsByNewest();
      updateUI();
    }
    function triggerSkillBonusUpgrade(key) {
      const skill = state.skills.find(entry => (entry.key || entry.name) === key);
      if (!skill) return;
      updateSkillDerivedStats(skill);
      const magicInfo = getSkillOvercapInfo(skill);
      if (!magicInfo.availablePercent) return;
      const maxBonus = Math.floor(magicInfo.overcapCopies / magicInfo.copiesPerPercent);
      const currentBonus = Math.max(0, Math.floor(skill.overcapBonusPercent || 0));
      if (currentBonus >= maxBonus) return;
      skill.overcapBonusPercent = Math.min(maxBonus, currentBonus + 1);
      skill.lastUpgradeAt = Date.now();
      updateSkillDerivedStats(skill);
      saveState();
      sortSkillsByNewest();
      updateUI();
    }
    function addItemToInventory(template) {
      const now = Date.now();
      const key = template.key;
      const existing = state.items.find(entry => entry.key === key);
      const maxCopies = getMaxCopiesForItem(existing || template || {});
      if (existing) {
        const currentCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
        if (currentCopies >= maxCopies) {
          updateItemDerivedStats(existing);
          sortInventoryByNewest();
          return { item: existing, isNew: false };
        }
        existing.totalCopies = currentCopies + 1;
        existing.lastObtainedAt = now;
        updateItemDerivedStats(existing);
        sortInventoryByNewest();
        return { item: existing, isNew: false };
      }
      const fresh = cloneItem(template);
      fresh.createdAt = now;
      fresh.lastObtainedAt = now;
      state.items.push(fresh);
      sortInventoryByNewest();
      return { item: fresh, isNew: true };
    }
    function addSkillToCollection(template) {
      const now = Date.now();
      const key = template.key;
      const existing = state.skills.find(entry => entry.key === key);
      const maxCopies = getMaxCopiesForSkill(existing || template || {});
      if (existing) {
        const currentCopies = Math.max(1, Math.floor(existing.totalCopies || 1));
        if (Number.isFinite(maxCopies) && currentCopies >= maxCopies) {
          updateSkillDerivedStats(existing);
          sortSkillsByNewest();
          return { skill: existing, isNew: false };
        }
        existing.totalCopies = currentCopies + 1;
        existing.lastObtainedAt = now;
        updateSkillDerivedStats(existing);
        sortSkillsByNewest();
        return { skill: existing, isNew: false };
      }
      const fresh = cloneSkill(template);
      fresh.createdAt = now;
      fresh.lastObtainedAt = now;
      state.skills.push(fresh);
      sortSkillsByNewest();
      return { skill: fresh, isNew: true };
    }
    function updateGachaOptionStyles() {
      if (!gachaTypeInputs) return;
      gachaTypeInputs.forEach(input => {
        const wrapper = input.closest(".gacha-option");
        if (wrapper) wrapper.classList.toggle("active", input.checked);
      });
    }
    function applyGachaPreference(pref) {
      if (!gachaTypeInputs || !gachaTypeInputs.length) return;
      const target = pref || state.gachaPreference || "weapon";
      let found = false;
      gachaTypeInputs.forEach((input, idx) => {
        const match = input.value === target;
        input.checked = match;
        if (match) found = true;
        if (!found && idx === gachaTypeInputs.length - 1 && !match) {
          input.checked = false;
        }
      });
      if (!found) {
        gachaTypeInputs[0].checked = true;
        state.gachaPreference = gachaTypeInputs[0].value;
      } else {
        state.gachaPreference = target;
      }
      updateGachaOptionStyles();
    }
    function getSelectedGachaType() {
      if (!gachaTypeInputs || !gachaTypeInputs.length) {
        return state.gachaPreference || "weapon";
      }
      const selected = Array.from(gachaTypeInputs).find(input => input.checked);
      return selected ? selected.value : state.gachaPreference || "weapon";
    }
    function getShopPoolForCategory(category) {
      let pool = KNIGHT_POOL;
      if (category && category !== "any" && category !== "skill") {
        const filtered = KNIGHT_POOL.filter(item => item.category === category);
        if (filtered.length) pool = filtered;
      }
      return pool.filter(isItemEligibleForShop);
    }
    function pickBlueprintFromPool(pool, remainingFn = getRemainingShopCopies) {
      if (!pool || !pool.length) return null;
      const weighted = [];
      pool.forEach(item => {
        const remaining = Math.max(0, (remainingFn ? remainingFn(item) : getRemainingShopCopies(item)));
        for (let i = 0; i < remaining; i += 1) {
          weighted.push(item);
        }
      });
      if (!weighted.length) return null;
      const index = Math.floor(Math.random() * weighted.length);
      return weighted[index];
    }
    function describeGachaCategory(category) {
      if (category && GACHA_CATEGORY_LABELS[category]) return GACHA_CATEGORY_LABELS[category];
      if (!category || category === "any") return GACHA_CATEGORY_LABELS.any || "Items";
      return category.charAt(0).toUpperCase() + category.slice(1);
    }
    function getShopAvailabilitySummary(category) {
      if (category === "skill") {
        const total = SKILL_POOL.length || Infinity;
        return {
          uniqueAvailable: Infinity,
          remainingCopies: Infinity,
          totalTemplates: total
        };
      }
      const pool = (!category || category === "any")
        ? KNIGHT_POOL
        : KNIGHT_POOL.filter(item => item.category === category);
      if (!pool.length) {
        return { uniqueAvailable: 0, remainingCopies: 0, totalTemplates: 0 };
      }
      let uniqueAvailable = 0;
      let remainingCopies = 0;
      pool.forEach(template => {
        const remaining = Math.max(0, getRemainingShopCopies(template));
        if (remaining > 0) {
          uniqueAvailable += 1;
          remainingCopies += remaining;
        }
      });
      return {
        uniqueAvailable,
        remainingCopies,
        totalTemplates: pool.length
      };
    }
    function formatRemainingAvailability(category, summary) {
      if (!summary) return "Ausverkauft";
      if (category === "skill" || !Number.isFinite(summary.remainingCopies)) {
        return "∞ übrig";
      }
      if (summary.remainingCopies <= 0) return "Ausverkauft";
      return `${summary.remainingCopies}x übrig`;
    }
    const SHOP_DEBUG_CATEGORIES = ["weapon", "armor", "accessory", "skill"];
    const SHOP_DEBUG_STATE = {
      availability: new Map(),
      inventory: new Map()
    };
    function debugLogShopAvailability() {
      if (!CONSTANTS_DEBUG || typeof console === "undefined" || !console.log) return;
      const labelFor = cat => (GACHA_CATEGORY_LABELS[cat] || cat || "").toUpperCase();
      const availabilityLines = [];
      const inventoryLines = [];
      SHOP_DEBUG_CATEGORIES.forEach(cat => {
        const summary = getShopAvailabilitySummary(cat);
        const availabilityKey = summary
          ? `${summary.remainingCopies ?? "inf"}|${summary.uniqueAvailable ?? "inf"}|${summary.totalTemplates ?? "inf"}`
          : "none";
        const prevAvailability = SHOP_DEBUG_STATE.availability.get(cat);
        if (availabilityKey !== prevAvailability) {
          const availableText = summary && Number.isFinite(summary.remainingCopies)
            ? `${summary.remainingCopies}x`
            : "∞x";
          const uniqueText = summary
            ? `${summary.uniqueAvailable}/${summary.totalTemplates}`
            : "0/0";
          availabilityLines.push(`${availableText} ${labelFor(cat)} AVAILABLE (unique ${uniqueText})`);
          SHOP_DEBUG_STATE.availability.set(cat, availabilityKey);
        }
        let ownedCount = 0;
        if (cat === "skill") {
          ownedCount = state.skills.reduce((sum, skill) => {
            if (!skill) return sum;
            const copies = Number(skill.totalCopies || 1);
            return sum + Math.max(1, copies);
          }, 0);
        } else {
          ownedCount = state.items.reduce((sum, item) => {
            if (!item) return sum;
            if (normalizeItemCategory(item.category) !== cat) return sum;
            const copies = Number(item.totalCopies || 1);
            return sum + Math.max(1, copies);
          }, 0);
        }
        const inventoryKey = `${ownedCount}`;
        const prevInventory = SHOP_DEBUG_STATE.inventory.get(cat);
        if (inventoryKey !== prevInventory) {
          inventoryLines.push(`${ownedCount} ${labelFor(cat)}`);
          SHOP_DEBUG_STATE.inventory.set(cat, inventoryKey);
        }
      });
      if (availabilityLines.length) {
        console.log("Shop availability update:");
        availabilityLines.forEach(line => console.log(line));
      }
      if (inventoryLines.length) {
        console.log("Inventory update:");
        inventoryLines.forEach(line => console.log(line));
      }
    }
    function updateGachaRemainingDisplays() {
      if (!gachaRemainingLabels || !gachaRemainingLabels.length) return;
      gachaRemainingLabels.forEach(label => {
        const category = label.getAttribute("data-remaining-category");
        const summary = getShopAvailabilitySummary(category);
        label.textContent = formatRemainingAvailability(category, summary);
        label.dataset.uniqueAvailable = String(summary.uniqueAvailable);
        label.dataset.remainingCopies = String(summary.remainingCopies);
        label.dataset.totalTemplates = String(summary.totalTemplates);
      });
      debugLogShopAvailability();
    }
    let displayedCoins = state.coins;
    let pendingCoinAnimation = null;
    let coinAnimationSuppressOnce = false;

    function spawnCoinAnimation(amount, anchor, variant = "gain") {
      const anchorEl = anchor || coinTop;
      if (!coinAnimationLayer || !anchorEl) return;
      const isLoss = variant === "loss" || amount < 0;
      const displayAmount = Math.abs(Math.round(amount));
      const rect = anchorEl.getBoundingClientRect();
      const celebration = document.createElement("div");
      celebration.className = `coin-celebration ${isLoss ? "loss" : "gain"}`;
      celebration.style.left = `${rect.left + rect.width / 2}px`;
      celebration.style.top = `${rect.top + rect.height / 2}px`;
      celebration.innerHTML = `
        <div class="coin-main">
          <div class="coin-symbol">${isLoss ? "💸" : "💰"}</div>
        </div>
        <div class="coin-amount">${isLoss ? "-" : "+"}${displayAmount} Coins</div>
      `;
      const sparkCount = isLoss ? 8 : 12;
      for (let i = 0; i < sparkCount; i++) {
        const spark = document.createElement("span");
        spark.className = "coin-spark";
        const angle = (Math.PI * 2 * (i / sparkCount)) + (Math.random() * 0.6 - 0.3);
        const radius = 140 + Math.random() * 45;
        const targetX = Math.cos(angle) * radius;
        const targetY = Math.sin(angle) * radius - 40;
        spark.style.setProperty("--targetX", `${targetX}px`);
        spark.style.setProperty("--targetY", `${targetY}px`);
        spark.style.animationDelay = `${0.12 * i}s`;
        celebration.appendChild(spark);
      }
      coinAnimationLayer.appendChild(celebration);
      setTimeout(() => celebration.remove(), 4000);
      const badgeClass = isLoss ? "coin-badge-loss" : "coin-badge-boost";
      coinTop.classList.add(badgeClass);
      coinTop.addEventListener("animationend", () => {
        coinTop.classList.remove(badgeClass);
      }, { once: true });
    }
    function updateHeroAvatar() {
      if (!heroAvatar) return;
      const atkBonus = Math.max(0, state.atk - BASE_ATK);
      const defBonus = Math.max(0, state.def - BASE_DEF);
      const atkTier = atkBonus >= 5 ? 3 : atkBonus >= 2 ? 2 : 1;
      const defTier = defBonus >= 5 ? 3 : defBonus >= 2 ? 2 : 1;
      const hasInventory = Array.isArray(state.items) && state.items.length > 0;
      heroAvatar.setAttribute("data-atk-tier", String(atkTier));
      heroAvatar.setAttribute("data-def-tier", String(defTier));
      heroAvatar.classList.toggle("no-gear", !hasInventory);
      heroAvatar.classList.toggle("has-gear", hasInventory);
      if (heroAvatarImage) {
        const blueprintSrc = "assets/blueprint_clean.svg";
        const knightSrc = "assets/knight_idle_fin.svg";
        heroAvatarImage.src = hasInventory ? knightSrc : blueprintSrc;
        heroAvatarImage.alt = hasInventory ? "Ritter bereit für den Kampf" : "Blueprint deines Helden";
        heroAvatarImage.classList.toggle("is-blueprint", !hasInventory);
        heroAvatarImage.classList.toggle("is-knight", hasInventory);
      }
    }
    function describeHeroTrait(atk, def) {
      if (atk - def >= 2) return "Aggressiv";
      if (def - atk >= 2) return "Defensiv";
      return "Ausbalanciert";
    }
    function describeEnemyTrait(enemy) {
      if (!enemy) return "Unbekannt";
      const label = ENEMY_VARIANT_LABELS[enemy.variant];
      if (label) return label;
      if (enemy.atk >= enemy.def + 2) return "Berserker";
      if (enemy.def >= enemy.atk + 2) return "Tank";
      return "Unberechenbar";
    }
    function getBattleTheme(level) {
      if (level >= 9) return "celestial";
      if (level >= 5) return "mountain";
      return "forest";
    }
    function setActiveBattleSide(isHeroActive) {
      heroCardElements.forEach(el => el.classList.toggle("attacking", Boolean(isHeroActive)));
      enemyCardElements.forEach(el => el.classList.toggle("attacking", !isHeroActive));
    }
    function pulseBattleSide(isHero) {
      const targets = isHero ? heroCardElements : enemyCardElements;
      targets.forEach(sideEl => {
        sideEl.classList.remove("hit");
        void sideEl.offsetWidth;
        sideEl.classList.add("hit");
        setTimeout(() => sideEl.classList.remove("hit"), 360);
      });
    }
    function clearBattleSideState() {
      heroCardElements.forEach(el => el.classList.remove("attacking", "hit"));
      enemyCardElements.forEach(el => el.classList.remove("attacking", "hit"));
    }
    function getEnemyIconKey(enemy) {
      if (enemy && enemy.icon && ENEMY_ICON_PATHS[enemy.icon]) return enemy.icon;
      if (enemy && enemy.variant && ENEMY_ICON_PATHS[enemy.variant]) return enemy.variant;
      return DEFAULT_ENEMY_ICON_KEY;
    }
    function getEnemyIconPath(enemy) {
      const key = getEnemyIconKey(enemy);
      return { key, path: ENEMY_ICON_PATHS[key] };
    }
    function updateEnemyPreviewArt(enemy) {
      if (!battleEnemyPreviewIcon) return;
      const { path } = getEnemyIconPath(enemy);
      battleEnemyPreviewIcon.src = path;
      battleEnemyPreviewIcon.alt = enemy && enemy.name ? enemy.name : "Gegner";
    }
    function updateActiveEnemyArt(enemy) {
      const { path } = getEnemyIconPath(enemy);
      const altText = enemy && enemy.name ? enemy.name : "Gegner";
      if (modalEnemyIcon) {
        modalEnemyIcon.src = path;
        modalEnemyIcon.alt = altText;
      }
      if (battleEnemySprite) {
        battleEnemySprite.src = path;
        battleEnemySprite.alt = altText;
      }
    }
    function updateBattlePreview() {
      if (!canRenderBattlePreview) return;
      const heroAtk = Math.max(0, state.atk || 0);
      const heroDef = Math.max(0, state.def || 0);
      const heroHpMax = getHeroMaxHp();
      if (battleHeroAtkStat) battleHeroAtkStat.textContent = String(heroAtk);
      if (battleHeroDefStat) battleHeroDefStat.textContent = String(heroDef);
      if (battleHeroHpStat) battleHeroHpStat.textContent = String(heroHpMax);
      if (battleHeroGearList) {
        battleHeroGearList.innerHTML = "";
        const gearEntries = [];
        EQUIPMENT_SLOT_KEYS.forEach(slotKey => {
          const eqKey = state.equipment && state.equipment[slotKey];
          if (!eqKey) return;
          const item = getItemByKey(eqKey);
          if (!item) return;
          const meta = EQUIPMENT_SLOT_DEFS[slotKey] || {};
          gearEntries.push({
            slot: meta.label || slotKey,
            name: item.name || eqKey,
            icon: getItemIcon(item.icon, item.key),
            stats: collectItemStats(item)
          });
        });
        if (!gearEntries.length) {
          const empty = document.createElement("li");
          empty.className = "battle-gear-empty";
          empty.textContent = "Keine Ausrüstung";
          battleHeroGearList.appendChild(empty);
        } else {
          gearEntries.forEach(entry => {
            const li = document.createElement("li");
            li.className = "battle-gear-card";
            const iconWrap = document.createElement("div");
            iconWrap.className = "gear-icon";
            iconWrap.innerHTML = entry.icon;
            const textWrap = document.createElement("div");
            textWrap.className = "gear-text";
            const slotLabel = document.createElement("strong");
            slotLabel.textContent = entry.slot;
            const nameLabel = document.createElement("span");
            nameLabel.textContent = entry.name;
            textWrap.appendChild(slotLabel);
            textWrap.appendChild(nameLabel);
            const statsRow = document.createElement("div");
            statsRow.className = "gear-stats";
            entry.stats.forEach(stat => {
              const badge = document.createElement("span");
              badge.className = `badge ${stat.className}`;
              badge.textContent = `${stat.label} +${stat.value}`;
              statsRow.appendChild(badge);
            });
            if (entry.stats.length) {
              textWrap.appendChild(statsRow);
            }
            li.appendChild(iconWrap);
            li.appendChild(textWrap);
            battleHeroGearList.appendChild(li);
          });
        }
      }
      const previewLevel = Math.min(Math.max(1, state.battleUnlocked || 1), ENEMY_DATA.length);
      const enemy = ENEMIES[previewLevel] || ENEMY_DATA[0];
      if (battleEnemyPreviewName) battleEnemyPreviewName.textContent = enemy ? enemy.name : "Unbekannt";
      if (battleEnemyPreviewLevel) battleEnemyPreviewLevel.textContent = enemy ? `Rang ${enemy.level || previewLevel}` : "Rang ?";
      if (battleEnemyAtkStat) battleEnemyAtkStat.textContent = enemy ? String(enemy.atk) : "-";
      if (battleEnemyDefStat) battleEnemyDefStat.textContent = enemy ? String(enemy.def) : "-";
      if (battleEnemyHpStat) battleEnemyHpStat.textContent = enemy ? String(enemy.hp) : "-";
      if (battleEnemyTrait) battleEnemyTrait.textContent = describeEnemyTrait(enemy);
      updateEnemyPreviewArt(enemy);
    }
    function pushBattleLog(message, variant = "system") {
      if (!battleLog) return;
      const entry = document.createElement("div");
      entry.className = `battle-entry battle-entry-${variant}`;
      entry.textContent = message;
      battleLog.appendChild(entry);
      battleLog.scrollTop = battleLog.scrollHeight;
    }
    function resetBattleLog(message) {
      if (!battleLog) return;
      battleLog.innerHTML = "";
      if (message) pushBattleLog(message, "system");
    }
    function updateUI() {
      const diff = state.coins - displayedCoins;
      if (pendingCoinAnimation) {
        const info = pendingCoinAnimation;
        spawnCoinAnimation(info.amount, info.anchor, info.variant || (info.amount < 0 ? "loss" : "gain"));
        pendingCoinAnimation = null;
      } else if (diff !== 0) {
        if (!coinAnimationSuppressOnce) {
          spawnCoinAnimation(diff, null, diff < 0 ? "loss" : "gain");
        }
      }
      coinAnimationSuppressOnce = false;
      displayedCoins = state.coins;
      if (coinTop) coinTop.textContent = "Coins: " + state.coins;
      if (atkDisplay) atkDisplay.textContent = "ATK " + state.atk;
      if (defDisplay) defDisplay.textContent = "DEF " + state.def;
      const equippedCount = getEquippedItems().length;
      if (hpDisplay) hpDisplay.textContent = "HP " + getHeroMaxHp();
      if (itemsDisplay) itemsDisplay.textContent = "Gear: " + equippedCount + "/" + EQUIPMENT_SLOT_KEYS.length;
      updateHeroAvatar();
      renderEquipmentSlots();
      renderInventory();
      renderSkills();
      renderShopLatest();
      updateGachaRemainingDisplays();
      renderBattleSkillBar();
      renderBattleWeaponSlots();
      if (canRenderBattlePreview) updateBattlePreview();
      updateSectionCompletionClasses();
    }
    function updateOverallSummary() {
      if (!overallSummary) return;
      const total = allCheckables.length;
      let correctCount = 0;
      allCheckables.forEach(el => {
        if (el.classList.contains("correct")) {
          correctCount += 1;
        }
      });
      const percent = total === 0 ? 0 : Math.round((correctCount / total) * 100);
      overallSummary.textContent = `${correctCount}/${total} Aufgaben aktuell richtig (${percent}%)`;
    }
    function ensureSectionReport(sectionId) {
      if (!sectionId) return null;
      if (!state.sectionReports || typeof state.sectionReports !== "object") {
        state.sectionReports = {};
      }
      if (!state.sectionReports[sectionId]) {
        state.sectionReports[sectionId] = {
          checks: 0,
          successes: 0,
          bestScore: 0,
          lastScore: 0,
          lastRunAt: 0,
          promptStats: Object.create(null)
        };
      }
      return state.sectionReports[sectionId];
    }

    function recordPromptResult(sectionId, prompt, isCorrect) {
      if (!prompt) return;
      const report = ensureSectionReport(sectionId);
      if (!report) return;
      const key = prompt.trim();
      if (!key) return;
      if (!report.promptStats[key]) {
        report.promptStats[key] = { attempts: 0, misses: 0, history: [] };
      }
      const stats = report.promptStats[key];
      if (!Array.isArray(stats.history)) {
        stats.history = [];
      }
      const attemptNumber = stats.history.length + 1;
      const attemptTimestamp = Date.now();
      stats.history.push({
        attempt: attemptNumber,
        success: Boolean(isCorrect),
        timestamp: attemptTimestamp
      });
      stats.attempts += 1;
      if (!isCorrect) {
        stats.misses += 1;
      }
      updateComboStats(key, sectionId, isCorrect, attemptTimestamp);
    }

    function recordSectionSummary(sectionId, total, correctCount) {
      const report = ensureSectionReport(sectionId);
      if (!report) return;
      report.checks += 1;
      if (correctCount === total && total > 0) {
        report.successes = (report.successes || 0) + 1;
      }
      const score = total === 0 ? 0 : Math.round((correctCount / total) * 100);
      report.lastScore = score;
      report.bestScore = Math.max(report.bestScore || 0, score);
      report.lastRunAt = Date.now();
    }

    function getSectionMeta(sectionId) {
      if (!sectionId || !Array.isArray(SECTION_BLUEPRINTS)) return null;
      return SECTION_BLUEPRINTS.find((entry, idx) => {
        const resolved = String(entry.id !== undefined ? entry.id : idx + 1);
        return resolved === String(sectionId);
      }) || null;
    }

    function gradeSection(sectionId, triggerBtn) {
      const section = document.querySelector(`.section[data-section="${sectionId}"]`);
      if (!section) return;
      const fields = section.querySelectorAll("[data-answer], .dnd-target");
      let correctCount = 0;
      const total = fields.length;
      fields.forEach(field => {
        const wrap = field.closest(".task-field");
        field.classList.remove("correct", "incorrect");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        let slotRef = null;
        const solution = (field.getAttribute("data-answer") || "").trim();
        let userValue = "";
        if (field.classList.contains("dnd-target")) {
          slotRef = field.querySelector(".drop-slot");
          if (slotRef) slotRef.classList.remove("correct", "incorrect");
          userValue = slotRef ? (slotRef.dataset.value || slotRef.textContent || "").trim() : "";
        } else if (field.classList.contains("narrative-blank")) {
          userValue = (field.dataset.value || field.textContent || "").trim();
        } else if (field.tagName === "SELECT") {
          userValue = field.value.trim();
        } else if (field.tagName === "INPUT") {
          userValue = field.value.trim();
        }
        let isCorrect = false;
        if (field.tagName === "INPUT") {
          isCorrect = userValue.toUpperCase() === solution.toUpperCase();
        } else {
          isCorrect = userValue === solution;
        }
        const promptSource = (field.dataset.prompt || "").trim();
        let promptText = promptSource;
        if (!promptText && wrap) {
          const questionNode = wrap.querySelector(".question-text");
          if (questionNode) promptText = questionNode.textContent.trim();
        }
        if (!promptText && field.classList.contains("dnd-target")) {
          const labelEl = field.querySelector(".question-text");
          if (labelEl) promptText = labelEl.textContent.trim();
        }
        if (isCorrect) {
          correctCount += 1;
          field.classList.add("correct");
          if (wrap) wrap.classList.add("correct");
          if (slotRef) slotRef.classList.add("correct");
        } else {
          field.classList.add("incorrect");
          if (wrap) wrap.classList.add("incorrect");
          if (slotRef) slotRef.classList.add("incorrect");
        }
        recordPromptResult(sectionId, promptText || solution || field.tagName, isCorrect);
      });
      const percent = total === 0 ? 0 : Math.round((correctCount / total) * 100);
      let resultMsg = `${correctCount}/${total} richtig (${percent}%)`;
      if (correctCount === total) {
        const clears = state.sectionClears[sectionId] || 0;
        const isFirstClear = clears === 0;
        const resets = state.sectionResets[sectionId] || 0;
        const actions = total;
        let reward = 0;
        if (clears === 0) {
          reward = actions * COINS_PER_ACTION;
        } else if (resets > 0) {
          reward = actions * COINS_PER_ACTION_AFTER_RESET;
          const remainingResets = Math.max(0, resets - 1);
          state.sectionResets[sectionId] = remainingResets;
        }
        state.sectionClears[sectionId] = clears + 1;
        if (reward > 0) {
          const bonusPercent = getRunenAmuletCoinBonusPercent();
          const finalReward = applyCoinBonus(reward);
          state.coins += finalReward;
          pendingCoinAnimation = { amount: finalReward, anchor: triggerBtn || null, variant: "gain" };
          const bonusText = bonusPercent ? ` (Runenbonus +${bonusPercent}%)` : "";
          resultMsg += ` | +${finalReward} Coins${bonusText}`;
        } else if (clears > 0) {
          resultMsg += " | für mehr Coins erst zurücksetzen.";
        }
        if (isFirstClear && unlockNextSection()) {
          resultMsg += " | Neuer Abschnitt freigeschaltet.";
        }
      } else {
        resultMsg += " | versuche es erneut.";
      }
      const resultEl = document.getElementById(`result-${sectionId}`);
      if (resultEl) resultEl.textContent = resultMsg;
      recordSectionSummary(sectionId, total, correctCount);
      updateUI();
      updateOverallSummary();
      recalcStats();
      saveState();
    }
    function resetSection(sectionId) {
      const section = document.querySelector(`.section[data-section="${sectionId}"]`);
      if (!section) return;
      const fields = section.querySelectorAll("[data-answer], .dnd-target");
      fields.forEach(field => {
        const wrap = field.closest(".task-field");
        field.classList.remove("correct", "incorrect");
        if (wrap) wrap.classList.remove("correct", "incorrect");
        if (field.tagName === "SELECT") {
          field.value = "";
        } else if (field.tagName === "INPUT") {
          field.value = "";
          if (field.dataset && field.dataset.hint) {
            updateInputHintOverlay(field);
          }
        } else if (field.classList.contains("dnd-target")) {
          const slot = field.querySelector(".drop-slot");
          if (slot) {
            slot.textContent = "";
            delete slot.dataset.value;
            slot.classList.remove("correct", "incorrect");
          }
        } else if (field.classList.contains("narrative-blank")) {
          field.textContent = "";
          field.dataset.value = "";
          field.dataset.filled = "false";
          field.classList.remove("active");
        }
      });
      reshuffleDndSection(section);
      const memoryController = memoryGameControllers.get(String(sectionId));
      if (memoryController && typeof memoryController.reset === "function") {
        memoryController.reset();
      }
      const resultEl = document.getElementById(`result-${sectionId}`);
      if (resultEl) resultEl.textContent = "Abschnitt wurde zurückgesetzt.";
      state.sectionResets[sectionId] = (state.sectionResets[sectionId] || 0) + 1;
      updateUI();
      updateOverallSummary();
      saveState();
    }
    function clearLocalProgress() {
      const typed = prompt("Spielfortschritt wirklich löschen?\nTippe LÖSCHEN in GROSSBUCHSTABEN, um zu bestätigen.");
      if (typed === null) return;
      const normalized = typed.trim();
      const accepted = normalized === "LÖSCHEN";
      if (!accepted) {
        alert("Aktion abgebrochen. Bitte exakt LÖSCHEN eingeben, um zu löschen.");
        return;
      }
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    }

    gachaBtn.addEventListener("click", () => {
      const cost = 25;
      if (state.coins < cost) {
        setGachaStatus("Nicht genug Coins (25 nötig).");
        return;
      }
      const type = getSelectedGachaType();
      state.gachaPreference = type;
      if (type === "skill") {
        state.coins -= cost;
        pendingCoinAnimation = { amount: -cost, anchor: gachaBtn, variant: "loss" };
        const { skill } = addSkillToCollection(SKILL_POOL[Math.floor(Math.random() * SKILL_POOL.length)]);
        state.lastShopPurchase = { type: "skill", key: skill.key, timestamp: Date.now() };
        updateUI();
      } else {
        const availablePool = getShopPoolForCategory(type);
        if (!availablePool.length) {
          const label = describeGachaCategory(type);
          setGachaStatus(label + "-Kategorie ausverkauft: Alle Items bereits Tier " + MAX_ITEM_TIER + ".");
          return;
        }
        const blueprint = pickBlueprintFromPool(availablePool);
        if (!blueprint) {
          const label = describeGachaCategory(type);
          setGachaStatus(label + "-Kategorie ausverkauft: Alle Items bereits Tier " + MAX_ITEM_TIER + ".");
          return;
        }
        state.coins -= cost;
        pendingCoinAnimation = { amount: -cost, anchor: gachaBtn, variant: "loss" };
        const { item } = addItemToInventory(blueprint);
        state.lastShopPurchase = { type: "item", key: item.key, timestamp: Date.now() };
        recalcStats();
        updateUI();
      }
      setGachaStatus("");
      saveState();
      updateGachaOptionStyles();
    });

    const ENEMY_VARIANTS = ["goblin", "goblin-army", "goblin-king"];
    const ENEMY_VARIANT_LABELS = {
      goblin: "Schneller Nahkämpfer",
      "goblin-army": "Goblin Scherge",
      "goblin-king": "Königliche Elite"
    };
    const DEFAULT_ENEMY_ICON_KEY = "kobold";
    const ENEMY_ICON_PATHS = {
      kobold: "assets/enemy-kobold.png",
      "gruener-goblin": "assets/enemy-gruener-goblin.png",
      hobgoblin: "assets/enemy-hobgoblin.png",
      waldgoblin: "assets/enemy-waldgoblin.png",
      hoehlengoblin: "assets/enemy-hoehlengoblin.png",
      bergtroll: "assets/enemy-bergtroll.png",
      dunkelgoblin: "assets/enemy-dunkelgoblin.png",
      kriegsgoblin: "assets/enemy-kriegsgoblin.png",
      schattengoblin: "assets/enemy-schattengoblin.png",
      daemonengoblin: "assets/enemy-daemonengoblin.png",
      goblinkoenig: "assets/enemy-goblinkoenig.png",
      goblin: "assets/enemy-kobold.png",
      "goblin-army": "assets/enemy-kriegsgoblin.png",
      "goblin-king": "assets/enemy-goblinkoenig.png"
    };
    const ENEMY_DATA = [
      { name: "Kobold", icon: "kobold", hp: 60, atk: 6, def: 0, variance: 1, crit: 0.05, variant: "goblin" },
      { name: "Grüner Goblin", icon: "gruener-goblin", hp: 80, atk: 8, def: 1, variance: 1, crit: 0.06, variant: "goblin" },
      { name: "Hobgoblin", icon: "hobgoblin", hp: 110, atk: 10, def: 2, variance: 1, crit: 0.07, variant: "goblin" },
      { name: "Waldgoblin", icon: "waldgoblin", hp: 140, atk: 12, def: 3, variance: 1, crit: 0.08, variant: "goblin" },
      { name: "Höhlengoblin", icon: "hoehlengoblin", hp: 170, atk: 15, def: 5, variance: 1, crit: 0.09, variant: "goblin" },
      { name: "Bergtroll", icon: "bergtroll", hp: 222, atk: 18, def: 7, variance: 2, crit: 0.11, variant: "goblin-army" },
      { name: "Dunkelgoblin", icon: "dunkelgoblin", hp: 333, atk: 22, def: 10, variance: 2, crit: 0.12, variant: "goblin-army" },
      { name: "Kriegsgoblin", icon: "kriegsgoblin", hp: 444, atk: 26, def: 12, variance: 3, crit: 0.13, variant: "goblin-army" },
      { name: "Schattengoblin", icon: "schattengoblin", hp: 666, atk: 32, def: 14, variance: 3, crit: 0.14, variant: "goblin-army" },
      { name: "Dämonengoblin", icon: "daemonengoblin", hp: 777, atk: 38, def: 17, variance: 6, crit: 0.16, variant: "goblin-army" },
      { name: "Goblinkönig", icon: "goblinkoenig", hp: 999, atk: 42, def: 18, variance: 8, crit: 0.19, variant: "goblin-king" }
    ];
    const ENEMIES = {};
    ENEMY_DATA.forEach((enemy, index) => {
      const level = index + 1;
      ENEMIES[level] = { ...enemy, level };
    });
    canRenderBattlePreview = true;
    updateBattlePreview();
    state.battleUnlocked = Math.min(ENEMY_DATA.length, Math.max(1, Math.floor(state.battleUnlocked || 1)));
    Object.keys(state.battleClears || {}).forEach(key => {
      const level = Number(key);
      if (!level || level > ENEMY_DATA.length) {
        delete state.battleClears[key];
      }
    });
    let battleInProgress = false;
    let battleSimHideTimer = null;
    function renderBattleButtons() {
      if (!battleButtonContainer) return;
      battleButtonContainer.innerHTML = "";
      battleButtons = [];
      ENEMY_DATA.forEach((enemy, index) => {
        const level = index + 1;
        const btn = document.createElement("button");
        btn.className = "battle-btn";
        btn.dataset.enemy = String(level);
        const label = `Rang ${level} ${enemy.name}`;
        btn.dataset.label = label;
        btn.textContent = label;
        btn.addEventListener("click", () => {
          startBattle(level);
        });
        battleButtonContainer.appendChild(btn);
        battleButtons.push(btn);
      });
      updateBattleButtons();
    }

    function renderReport() {
      if (!reportContent) return;
      const reports = state.sectionReports || {};
      const entries = Object.entries(reports);
      if (!entries.length) {
        reportContent.innerHTML = "<p class=\"small\">Noch keine Daten vorhanden. Bearbeite weitere Abschnitte.</p>";
        if (reportTimestamp) reportTimestamp.textContent = "Noch kein Report erstellt.";
        return;
      }
      const now = new Date();
      if (reportTimestamp) {
        reportTimestamp.textContent = "Report erstellt: " + now.toLocaleString("de-DE");
      }
      const sectionRows = [];
      const promptRows = [];
      entries.forEach(([sectionId, data]) => {
        if (!data) return;
        const meta = getSectionMeta(sectionId);
        const rawTitle = meta && meta.title ? meta.title : "";
        const normalizedTitle = rawTitle ? rawTitle.replace(/^\d+(?:[.)]\s*)?/, "").trim() : "";
        const sectionName = normalizedTitle
          ? `Abschnitt ${sectionId} ${normalizedTitle}`
          : `Abschnitt ${sectionId}`;
        const promptStats = data.promptStats || {};
        const totalAttempts = Object.values(promptStats).reduce((sum, stat) => sum + Math.max(0, stat.attempts || 0), 0);
        const totalMisses = Object.values(promptStats).reduce((sum, stat) => sum + Math.max(0, stat.misses || 0), 0);
        sectionRows.push({
          sectionId,
          name: sectionName,
          checks: data.checks || 0,
          successes: data.successes || 0,
          bestScore: data.bestScore || 0,
          lastScore: data.lastScore || 0,
          misses: totalMisses,
          attempts: totalAttempts,
          correct: Math.max(0, totalAttempts - totalMisses),
          lastRunAt: data.lastRunAt || 0
        });
        Object.entries(promptStats).forEach(([prompt, stats]) => {
          const rawHistory = Array.isArray(stats.history) ? stats.history : [];
          const history = rawHistory.map((entry, idx) => ({
            attempt: typeof entry.attempt === "number" ? entry.attempt : idx + 1,
            success: entry.success === false ? false : true,
            timestamp: typeof entry.timestamp === "number" ? entry.timestamp : 0
          }));
          promptRows.push({
            sectionId,
            sectionName,
            prompt,
            attempts: stats.attempts || 0,
            misses: stats.misses || 0,
            history
          });
        });
      });
      const toughestPrompts = promptRows
        .filter(row => row.misses > 0)
        .sort((a, b) => (b.misses - a.misses) || (b.attempts - a.attempts))
        .slice(0, 5);
      const solidPrompts = promptRows
        .filter(row => row.attempts > 0 && row.misses === 0)
        .sort((a, b) => b.attempts - a.attempts)
        .slice(0, 5);
      const sectionChallenge = sectionRows
        .filter(row => row.checks > 0)
        .sort((a, b) => (b.misses - a.misses) || (a.successes - b.successes))
        .slice(0, 5);
      const sectionSuccess = sectionRows
        .filter(row => row.successes > 0)
        .sort((a, b) => (b.successes - a.successes) || (b.bestScore - a.bestScore))
        .slice(0, 5);
      const totalChecks = sectionRows.reduce((sum, row) => sum + (row.checks || 0), 0);
      const totalPerfect = sectionRows.reduce((sum, row) => sum + (row.successes || 0), 0);
      const comboFallbackEntries = buildComboFallbackEntries(promptRows);
      const comboFallbackByKey = Object.create(null);
      comboFallbackEntries.forEach(entry => {
        comboFallbackByKey[entry.key] = entry;
      });

      const errorChartData = toughestPrompts.map(row => ({
        label: row.prompt,
        displayLabel: formatPromptLabel(row.prompt),
        section: row.sectionName,
        value: row.misses
      }));
      const sectionScoreData = sectionRows
        .filter(row => row.bestScore > 0)
        .sort((a, b) => b.bestScore - a.bestScore)
        .slice(0, 5)
        .map(row => ({
          label: row.name,
          value: row.bestScore,
          variant: "good"
        }));
      const practiceData = sectionRows
        .filter(row => row.checks > 0)
        .sort((a, b) => b.checks - a.checks)
        .slice(0, 5)
        .map(row => ({
          label: row.name,
          value: row.checks
        }));
      const comboStatsEntries = state.comboStats && typeof state.comboStats === "object"
        ? Object.values(state.comboStats)
        : [];
      let comboRatioData = [];
      let comboAttemptData = [];
      if (comboStatsEntries.length) {
        const statsKeySet = new Set();
        comboRatioData = comboStatsEntries
          .filter(entry => entry && entry.attempts > 0)
          .map(entry => {
            statsKeySet.add(entry.key);
            const correct = Math.max(0, entry.attempts - (entry.misses || 0));
            const correctPct = entry.attempts ? Math.round((correct / entry.attempts) * 100) : 0;
            const displayLabel = entry.shortcut ? `${entry.label} (${entry.shortcut})` : entry.label;
            return {
              label: entry.label,
              shortcut: entry.shortcut || "",
              displayLabel,
              attempts: entry.attempts,
              correctPct,
              wrongPct: Math.max(0, 100 - correctPct)
            };
          })
          .sort((a, b) => (a.correctPct - b.correctPct) || (b.attempts - a.attempts));
        comboFallbackEntries.forEach(entry => {
          if (statsKeySet.has(entry.key) || entry.attempts <= 0) return;
          const correct = Math.max(0, entry.attempts - (entry.misses || 0));
          const correctPct = entry.attempts ? Math.round((correct / entry.attempts) * 100) : 0;
          const displayLabel = entry.shortcut ? `${entry.label} (${entry.shortcut})` : entry.label;
          comboRatioData.push({
            label: entry.label,
            shortcut: entry.shortcut || "",
            displayLabel,
            attempts: entry.attempts,
            correctPct,
            wrongPct: Math.max(0, 100 - correctPct)
          });
        });
        comboRatioData.sort((a, b) => (a.correctPct - b.correctPct) || (b.attempts - a.attempts));
        comboAttemptData = comboStatsEntries
          .map(entry => {
            const displayLabel = entry.shortcut ? `${entry.label} (${entry.shortcut})` : entry.label;
            const baseHistory = entry.history.length
              ? entry.history
              : ((comboFallbackByKey[entry.key] && comboFallbackByKey[entry.key].history) || []);
            const normalizedHistory = baseHistory.map((item, idx) => ({
              attempt: typeof item.attempt === "number" ? item.attempt : idx + 1,
              success: item.success === false ? false : true,
              timestamp: typeof item.timestamp === "number" ? item.timestamp : 0
            }));
            return {
              label: entry.label,
              shortcut: entry.shortcut || "",
              displayLabel,
              history: normalizedHistory
            };
          })
          .filter(entry => entry.history.length)
          .sort((a, b) => (b.history.length - a.history.length) || a.label.localeCompare(b.label));
        comboStatsEntries.forEach(entry => statsKeySet.add(entry.key));
        comboFallbackEntries.forEach(entry => {
          if (statsKeySet.has(entry.key) || !entry.history.length) return;
          const displayLabel = entry.shortcut ? `${entry.label} (${entry.shortcut})` : entry.label;
          comboAttemptData.push({
            label: entry.label,
            shortcut: entry.shortcut || "",
            displayLabel,
            history: entry.history.slice()
          });
        });
        comboAttemptData = comboAttemptData
          .filter(entry => entry.history.length)
          .sort((a, b) => (b.history.length - a.history.length) || a.label.localeCompare(b.label));
      } else {
        const fallbackEntries = comboFallbackEntries;
        comboRatioData = fallbackEntries
          .filter(row => row.attempts > 0)
          .map(row => {
            const correct = Math.max(0, row.attempts - row.misses);
            const correctPct = Math.round((correct / row.attempts) * 100);
            const displayLabel = row.shortcut ? `${row.label} (${row.shortcut})` : row.label;
            return {
              label: row.label,
              shortcut: row.shortcut || "",
              displayLabel,
              attempts: row.attempts,
              correctPct,
              wrongPct: Math.max(0, 100 - correctPct)
            };
          })
          .sort((a, b) => (a.correctPct - b.correctPct) || (b.attempts - a.attempts));
        comboAttemptData = fallbackEntries
          .filter(entry => Array.isArray(entry.history) && entry.history.length)
          .map(entry => {
            const displayLabel = entry.shortcut ? `${entry.label} (${entry.shortcut})` : entry.label;
            return {
              label: entry.label,
              shortcut: entry.shortcut || "",
              displayLabel,
              history: entry.history.slice()
            };
          })
          .sort((a, b) => (b.history.length - a.history.length) || a.label.localeCompare(b.label));
      }
      const sectionAccuracyData = sectionRows
        .filter(row => row.attempts > 0)
        .map(row => {
          const correctPct = row.attempts ? Math.round((row.correct / row.attempts) * 100) : 0;
          return {
            label: row.name,
            attempts: row.attempts,
            correctPct,
            wrongPct: Math.max(0, 100 - correctPct)
          };
        })
        .sort((a, b) => (a.correctPct - b.correctPct) || (b.attempts - a.attempts));
      renderReportTabs({
        errorChartData,
        sectionScoreData,
        practiceData,
        comboRatioData,
        sectionAccuracyData,
        comboAttemptData,
        toughestPrompts,
        solidPrompts,
        sectionChallenge,
        sectionSuccess,
        totalChecks,
        totalPerfect
      });
    }

    function renderReportTabs(payload) {
      disposeReportCharts();
      reportContent.innerHTML = "";
      switch (activeReportTab) {
        case "combos":
          renderComboTab(payload);
          break;
        case "sections":
          renderSectionTab(payload);
          break;
        default:
          renderOverviewTab(payload);
          break;
      }
    }

    function renderOverviewTab(payload) {
      const { totalChecks, totalPerfect, sectionSuccess = [], sectionChallenge = [], toughestPrompts = [], solidPrompts = [], practiceData = [], comboRatioData = [] } = payload;
      const highlightBlock = document.createElement("div");
      highlightBlock.className = "report-block";
      const highlightGrid = document.createElement("div");
      highlightGrid.className = "report-highlights";
      highlightGrid.appendChild(buildHighlightCard("Gesamt-Checks", totalChecks, null, true));
      highlightGrid.appendChild(buildHighlightCard("Fehlerfreie Abschnitte", totalPerfect, null, true));
      if (sectionSuccess[0]) {
        const topSection = sectionSuccess[0];
        const subtitle = `${topSection.name} (${topSection.successes} fehlerfreie Läufe)`;
        highlightGrid.appendChild(buildHighlightCard("Abschnitt mit den meisten fehlerfreien Läufen", subtitle));
      }
      if (sectionChallenge[0]) {
        highlightGrid.appendChild(buildHighlightCard("Grösste Baustelle", `${sectionChallenge[0].name} (${sectionChallenge[0].misses} Fehler)`, "bad"));
      }
      if (toughestPrompts[0]) {
        const trickyLabel = formatPromptLabel(toughestPrompts[0].prompt);
        const trickySuffix = `${toughestPrompts[0].misses} Fehlversuche`;
        highlightGrid.appendChild(buildHighlightCard("Kniffligste Kombination", `${trickyLabel} (${trickySuffix})`, "bad"));
      }
      highlightBlock.appendChild(highlightGrid);
      reportContent.appendChild(highlightBlock);

      const insightBlock = document.createElement("div");
      insightBlock.className = "report-block";
      insightBlock.appendChild(buildBlockHeading("Quick Insights", "💡"));
      const insights = [];
      if (sectionChallenge[0]) {
        insights.push(`🧠 ${sectionChallenge[0].name}: ${sectionChallenge[0].misses} Fehlversuche registriert.`);
      }
      if (toughestPrompts[0]) {
        const trickyLabel = formatPromptLabel(toughestPrompts[0].prompt);
        const trickySection = toughestPrompts[0].sectionName ? ` (${toughestPrompts[0].sectionName})` : "";
        insights.push(`⚠️ ${trickyLabel}${trickySection} stolpert am häufigsten.`);
      }
      if (solidPrompts[0]) {
        const solidLabel = formatPromptLabel(solidPrompts[0].prompt);
        insights.push(`✅ ${solidLabel} sitzt (${solidPrompts[0].attempts} fehlerfreie Versuche).`);
      }
      if (practiceData[0]) {
        insights.push(`🔁 ${practiceData[0].label} wurde ${practiceData[0].value}x geübt.`);
      }
      if (comboRatioData.length) {
        const weakest = comboRatioData[0];
        const strongest = comboRatioData[comboRatioData.length - 1];
        if (weakest) {
          const weakLabel = weakest.displayLabel || formatPromptLabel(weakest.label);
          insights.push(`📉 ${weakLabel} braucht noch Sicherheit (${weakest.correctPct}% Trefferquote).`);
        }
        if (strongest && strongest !== weakest) {
          const strongLabel = strongest.displayLabel || formatPromptLabel(strongest.label);
          insights.push(`📈 ${strongLabel} ist deine stärkste Kombination (${strongest.correctPct}% Trefferquote).`);
        }
      }
      if (insights.length) {
        const list = document.createElement("ul");
        list.className = "report-insights";
        insights.slice(0, 5).forEach(text => {
          const li = document.createElement("li");
          li.textContent = text;
          list.appendChild(li);
        });
        insightBlock.appendChild(list);
      } else {
        const empty = document.createElement("p");
        empty.className = "small";
        empty.textContent = "Noch keine Auswertungen vorhanden.";
        insightBlock.appendChild(empty);
      }
      reportContent.appendChild(insightBlock);
    }

    function renderComboTab(payload) {
      const { toughestPrompts = [], solidPrompts = [], comboRatioData = [], errorChartData = [], comboAttemptData = [] } = payload;
      const hasContent = toughestPrompts.length || solidPrompts.length || comboRatioData.length || errorChartData.length;
      if (!hasContent) {
        const msg = document.createElement("p");
        msg.className = "small";
        msg.textContent = "Noch keine Kombinationsdaten vorhanden.";
        reportContent.appendChild(msg);
        return;
      }
      reportContent.appendChild(buildReportBlock("Fehlerhäufigste Kombinationen", "⚠️", toughestPrompts, ["Abschnitt", "Kombination", "Fehlversuche"], row => [
        row.sectionName,
        formatPromptLabel(row.prompt),
        `${row.misses}/${row.attempts}`
      ], "Keine Fehler bisher 🎉"));
      reportContent.appendChild(buildReportBlock("Starke Kombinationen", "✅", solidPrompts, ["Abschnitt", "Kombination", "Versuche"], row => [
        row.sectionName,
        formatPromptLabel(row.prompt),
        row.attempts
      ], "Noch keine perfekten Serien."));
      const chartEntries = [];
      if (comboRatioData.length) {
        const ratioCard = createChartCard("Trefferquote pro Kombination", "🟢", "reportChartCombosTab");
        chartEntries.push({ card: ratioCard, render: () => renderComboRatioChart(comboRatioData, "reportChartCombosTab") });
      }
      if (errorChartData.length) {
        const errorCard = createChartCard("Fehlversuche je Kombination", "⚠️", "reportChartErrorsTab");
        chartEntries.push({ card: errorCard, render: () => renderErrorComboChart(errorChartData, "reportChartErrorsTab") });
      }
      if (chartEntries.length) {
        const grid = document.createElement("div");
        grid.className = "report-chart-grid";
        chartEntries.forEach(entry => grid.appendChild(entry.card));
        reportContent.appendChild(grid);
        chartEntries.forEach(entry => entry.render());
      }
      if (comboAttemptData.length) {
        const attemptCard = createChartCard("Versuchshistorie pro Kombination", "🎯", "reportChartComboAttempts");
        reportContent.appendChild(attemptCard);
        renderComboAttemptChart(comboAttemptData, "reportChartComboAttempts");
      }
    }

    function renderSectionTab(payload) {
      const { sectionChallenge = [], sectionSuccess = [], practiceData = [], sectionScoreData = [], sectionAccuracyData = [] } = payload;
      const hasContent = sectionChallenge.length || sectionSuccess.length || practiceData.length || sectionScoreData.length || sectionAccuracyData.length;
      if (!hasContent) {
        const msg = document.createElement("p");
        msg.className = "small";
        msg.textContent = "Noch keine Abschnittsdaten vorhanden.";
        reportContent.appendChild(msg);
        return;
      }
      reportContent.appendChild(buildReportBlock("Abschnitte mit Verbesserungsbedarf", "🧠", sectionChallenge, ["Abschnitt", "Checks", "Fehler"], row => [
        row.name,
        row.checks,
        row.misses
      ], "Noch keine Auswertungen."));
      reportContent.appendChild(buildReportBlock("Fehlerfreie Abschnitte", "🏅", sectionSuccess, ["Abschnitt", "Fehlerfreie Läufe", "Bestes Ergebnis"], row => [
        row.name,
        row.successes,
        row.bestScore + "%"
      ], "Noch keine erfolgreichen Läufe."));
      const chartEntries = [];
      if (practiceData.length) {
        const practiceCard = createChartCard("Meist geübte Abschnitte", "📘", "reportChartPracticeTab");
        chartEntries.push({ card: practiceCard, render: () => renderPracticeChart(practiceData, "reportChartPracticeTab") });
      }
      if (sectionScoreData.length) {
        const scoreCard = createChartCard("Top-Ergebnisse je Abschnitt", "🏅", "reportChartScoresTab");
        chartEntries.push({ card: scoreCard, render: () => renderScoreChart(sectionScoreData.map(row => ({ name: row.label, bestScore: row.value })), "reportChartScoresTab") });
      }
      let accuracyCardEntry = null;
      if (sectionAccuracyData.length) {
        const perfCard = createChartCard("Performance pro Abschnitt", "📈", "reportChartSectionPerformance");
        chartEntries.push({ card: perfCard, render: () => renderSectionPerformanceChart(sectionAccuracyData, "reportChartSectionPerformance") });
        accuracyCardEntry = {
          card: createChartCard("Trefferquote je Abschnitt", "📊", "reportChartSectionAccuracy"),
          render: () => renderComboRatioChart(sectionAccuracyData, "reportChartSectionAccuracy")
        };
      }
      if (chartEntries.length) {
        const grid = document.createElement("div");
        grid.className = "report-chart-grid";
        chartEntries.forEach(entry => grid.appendChild(entry.card));
        reportContent.appendChild(grid);
        chartEntries.forEach(entry => entry.render());
      }
      if (accuracyCardEntry) {
        reportContent.appendChild(accuracyCardEntry.card);
        accuracyCardEntry.render();
      }
    }

    function buildReportBlock(title, icon, rows, headers, formatter, emptyText) {
      const block = document.createElement("div");
      block.className = "report-block";
      block.appendChild(buildBlockHeading(title, icon || "📘"));
      if (!rows.length) {
        const info = document.createElement("p");
        info.className = "small";
        info.textContent = emptyText;
        block.appendChild(info);
        return block;
      }
      const table = document.createElement("table");
      table.className = "report-table";
      const colgroup = document.createElement("colgroup");
      ["col-40", "col-40", "col-20"].forEach(cls => {
        const colEl = document.createElement("col");
        colEl.className = cls;
        colgroup.appendChild(colEl);
      });
      table.appendChild(colgroup);
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      headers.forEach((text) => {
        const th = document.createElement("th");
        th.textContent = text;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = document.createElement("tbody");
      rows.forEach(row => {
        const tr = document.createElement("tr");
        formatter(row).forEach((value) => {
          const td = document.createElement("td");
          td.textContent = value;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      block.appendChild(table);
      return block;
    }

    function buildHighlightCard(label, value, variant, emphasized) {
      const card = document.createElement("div");
      card.className = `highlight-card${variant === "bad" ? " bad" : ""}`;
      const lbl = document.createElement("span");
      lbl.className = "highlight-label";
      lbl.textContent = label;
      const val = document.createElement("span");
      val.className = `highlight-value${emphasized ? " emphasized" : ""}`;
      val.textContent = value || value === 0 ? value : "-";
      card.appendChild(lbl);
      card.appendChild(val);
      return card;
    }

    function buildBlockHeading(text, icon) {
      const heading = document.createElement("h3");
      const iconSpan = document.createElement("span");
      iconSpan.className = "report-icon";
      iconSpan.textContent = icon || "";
      heading.appendChild(iconSpan);
      const textNode = document.createElement("span");
      textNode.textContent = text;
      heading.appendChild(textNode);
      return heading;
    }

    function createChartCard(title, icon, containerId) {
      const block = document.createElement("div");
      block.className = "report-block chart-card";
      block.appendChild(buildBlockHeading(title, icon || "📈"));
      const shell = document.createElement("div");
      shell.id = containerId;
      shell.className = "chart-shell";
      block.appendChild(shell);
      return block;
    }

    function disposeReportCharts() {
      while (activeReportCharts.length) {
        const chart = activeReportCharts.pop();
        if (chart && typeof chart.destroy === "function") {
          chart.destroy();
        }
      }
    }

    function mountReportChart(containerId, options) {
      if (typeof ApexCharts === "undefined") return null;
      const container = document.getElementById(containerId);
      if (!container) return null;
      while (container.firstChild) container.removeChild(container.firstChild);
      const chart = new ApexCharts(container, options);
      chart.render();
      activeReportCharts.push(chart);
      return chart;
    }

    function renderScoreChart(sectionRows, containerId) {
      if (typeof ApexCharts === "undefined" || !sectionRows.length) return;
      const seriesData = sectionRows
        .filter(row => row.bestScore > 0)
        .sort((a, b) => b.bestScore - a.bestScore)
        .slice(0, 8)
        .map(row => ({ name: row.name, score: Math.min(100, row.bestScore || 0) }))
        .reverse();
      if (!seriesData.length) {
        const container = document.getElementById(containerId);
        if (container) container.innerHTML = "<p class=\"small\">Noch keine Ergebnisse für dieses Chart.</p>";
        return;
      }
      const options = {
        chart: {
          type: "bar",
          height: 320,
          foreColor: "#e2e8f0",
          background: "transparent",
          toolbar: { show: false }
        },
        series: [{
          name: "Bestes Ergebnis",
          data: seriesData.map(entry => entry.score)
        }],
        plotOptions: {
          bar: {
            horizontal: true,
            barHeight: "60%",
            borderRadius: 6,
            colors: {
              ranges: [{
                from: 0,
                to: 100,
                color: "#34d399"
              }]
            }
          }
        },
        xaxis: {
          categories: seriesData.map(entry => entry.name),
          max: 100,
          labels: {
            formatter: val => `${Math.round(val)}%`
          }
        },
        grid: {
          borderColor: "rgba(148,163,184,0.2)"
        },
        tooltip: {
          y: {
            formatter: val => `${val}%`
          }
        },
        dataLabels: {
          enabled: true,
          formatter: val => `${val}%`,
          style: {
            colors: ["#0f172a"]
          },
          dropShadow: {
            enabled: true,
            top: 1,
            left: 1,
            blur: 1
          }
        },
        colors: ["#34d399"]
      };
      mountReportChart(containerId, options);
    }

    function renderErrorComboChart(rows, containerId) {
      if (typeof ApexCharts === "undefined" || !rows.length) return;
      const labelSet = rows.map(row => row.displayLabel || formatPromptLabel(row.label));
      const sectionSet = rows.map(row => row.section || "");
      const values = rows.map(row => row.value || 0);
      const options = {
        chart: {
          type: "bar",
          height: 320,
          foreColor: "#e2e8f0",
          background: "transparent",
          toolbar: { show: false }
        },
        series: [{
          name: "Fehlversuche",
          data: values
        }],
        plotOptions: {
          bar: {
            horizontal: true,
            barHeight: "55%",
            borderRadius: 6,
            colors: {
              ranges: [{
                from: 0,
                to: Math.max(...values, 1),
                color: "#f87171"
              }]
            }
          }
        },
        xaxis: {
          categories: labelSet
        },
        tooltip: {
          y: {
            formatter: val => `${val} Fehlversuche`
          },
          x: {
            formatter: (_, opts) => {
              const idx = opts.dataPointIndex;
              return `${labelSet[idx]}${sectionSet[idx] ? ` (${sectionSet[idx]})` : ""}`;
            }
          }
        },
        grid: { borderColor: "rgba(148,163,184,0.2)" },
        dataLabels: { enabled: true }
      };
      mountReportChart(containerId, options);
    }

    function renderPracticeChart(rows, containerId) {
      if (typeof ApexCharts === "undefined" || !rows.length) return;
      const categories = rows.map(row => row.label);
      const values = rows.map(row => row.value || 0);
      const height = Math.max(360, rows.length * 32 + 120);
      const options = {
        chart: {
          type: "bar",
          height,
          foreColor: "#e2e8f0",
          background: "transparent",
          toolbar: { show: false }
        },
        series: [{
          name: "Checks",
          data: values
        }],
        plotOptions: {
          bar: {
            horizontal: true,
            barHeight: "65%",
            borderRadius: 8
          }
        },
        xaxis: {
          forceNiceScale: true,
          labels: {
            formatter: val => `${val}`
          }
        },
        yaxis: {
          categories,
          labels: {
            maxWidth: 220
          }
        },
        dataLabels: {
          enabled: true,
          formatter: val => `${val}`,
          style: { colors: ["#0f172a"] }
        },
        colors: ["#60a5fa"],
        grid: { borderColor: "rgba(148,163,184,0.15)" }
      };
      mountReportChart(containerId, options);
    }

    function renderSectionPerformanceChart(rows, containerId) {
      if (typeof ApexCharts === "undefined" || !rows.length) return;
      const dataset = rows
        .filter(entry => entry && typeof entry.correctPct === "number" && entry.label)
        .map(entry => ({
          label: entry.label,
          pct: Math.max(0, Math.min(100, entry.correctPct || 0))
        }));
      if (!dataset.length) {
        const container = document.getElementById(containerId);
        if (container) container.innerHTML = "<p class=\"small\">Noch keine Daten für dieses Chart.</p>";
        return;
      }
      const sorted = dataset.slice().sort((a, b) => a.label.localeCompare(b.label, "de", { numeric: true }));
      const augmented = [...sorted, { label: "Diagram Endnode", pct: 0, spacer: true }];
      const labels = augmented.map(item => item.label);
      const points = augmented.map((item, index) => ({ x: item.pct, y: index, spacer: Boolean(item.spacer) }));
      const maxIndex = Math.max(0, points.length - 1);
      const height = Math.max(380, points.length * 70 + 120);
      const options = {
        chart: {
          type: "area",
          height,
          foreColor: "#e2e8f0",
          background: "transparent",
          toolbar: { show: false },
          zoom: { enabled: false }
        },
        series: [{
          name: "Performance",
          data: points
        }],
        stroke: {
          width: 3,
          curve: "straight",
          colors: ["#d97706"]
        },
        markers: {
          size: 7,
          colors: ["#0f172a"],
          strokeColors: "#f59e0b",
          strokeWidth: 3
        },
        fill: {
          type: "solid",
          colors: ["#fbbf24"],
          opacity: 0.18
        },
        grid: {
          borderColor: "rgba(148,163,184,0.2)",
          xaxis: { lines: { show: true } },
          yaxis: { lines: { show: true } }
        },
        dataLabels: {
          enabled: true,
          formatter: (_, opts) => {
            const point = points[opts.dataPointIndex];
            if (!point || point.spacer) return "";
            return `${Math.round(point.x)}%`;
          },
          style: { colors: ["#0f172a"] },
          background: {
            enabled: true,
            borderWidth: 0,
            opacity: 0.2
          }
        },
        xaxis: {
          type: "numeric",
          min: 0,
          max: 100,
          tickAmount: 5,
          title: { text: "Performance (Richtig %)" },
          labels: {
            formatter: val => `${Math.round(Math.max(0, val))}%`
          }
        },
        yaxis: {
          min: 0,
          max: maxIndex,
          tickAmount: maxIndex,
          labels: {
            formatter: value => {
              const idx = Math.round(value);
              return labels[idx] || "";
            },
            trim: false,
            maxWidth: 220
          },
          title: { text: "Abschnitt" }
        },
        tooltip: {
          shared: false,
          intersect: true,
          custom: ({ seriesIndex, dataPointIndex, w }) => {
            const point = w.config.series[seriesIndex].data[dataPointIndex];
            const label = labels[dataPointIndex] || "";
            if (!point || !label || point.spacer) return "";
            return `<div class="apexcharts-tooltip-title">${label}</div><div class="apexcharts-tooltip-text">${Math.round(point.x)}% richtig</div>`;
          }
        }
      };
      mountReportChart(containerId, options);
    }

    function renderComboAttemptChart(rows, containerId) {
      if (typeof ApexCharts === "undefined") return;
      const hasComboStats = state.comboStats && typeof state.comboStats === "object" && Object.keys(state.comboStats).length;
      const filteredRows = Array.isArray(rows)
        ? rows.filter(row => Array.isArray(row.history) && row.history.length)
        : [];
      const canonicalRows = !filteredRows.length && hasComboStats
        ? Object.values(state.comboStats)
            .filter(entry => Array.isArray(entry.history) && entry.history.length)
            .map(entry => ({
              label: entry.label,
              displayLabel: entry.shortcut ? `${entry.label} (${entry.shortcut})` : entry.label,
              history: entry.history.map((item, idx) => ({
                attempt: typeof item.attempt === "number" ? item.attempt : idx + 1,
                success: item.success === false ? false : true
              }))
            }))
        : filteredRows;
      if (!canonicalRows.length) {
        const container = document.getElementById(containerId);
        if (container) container.innerHTML = "<p class=\"small\">Noch keine aufgezeichneten Versuche.</p>";
        return;
      }
      const rowsWithSpacer = [
        { label: "", displayLabel: "", history: [] },
        ...canonicalRows
      ];
      const labels = rowsWithSpacer.map(row => row.displayLabel || formatPromptLabel(row.label));
      const successPoints = [];
      const failPoints = [];
      let maxAttempt = 0;
      rowsWithSpacer.forEach((row, rowIndex) => {
        const history = Array.isArray(row.history) ? row.history : [];
        history.forEach((entry, idx) => {
          const attemptNumber = typeof entry.attempt === "number" ? entry.attempt : idx + 1;
          const point = {
            x: attemptNumber,
            y: rowIndex,
            combo: labels[rowIndex],
            attempt: attemptNumber
          };
          if (entry.success === false) {
            failPoints.push(point);
          } else {
            successPoints.push(point);
          }
          if (attemptNumber > maxAttempt) {
            maxAttempt = attemptNumber;
          }
        });
      });
      if (!successPoints.length && !failPoints.length) {
        const container = document.getElementById(containerId);
        if (container) container.innerHTML = "<p class=\"small\">Noch keine aufgezeichneten Versuche.</p>";
        return;
      }
      const resolvedMaxAttempt = Math.max(1, maxAttempt);
      const minAxisSpan = 6;
      const axisMax = Math.max(minAxisSpan, resolvedMaxAttempt);
      const tickSteps = Math.max(1, Math.min(12, axisMax) - 1);
      const effectiveRowCount = rowsWithSpacer.length;
      const height = Math.max(360, effectiveRowCount * 34 + 160);
      const options = {
        chart: {
          type: "scatter",
          height,
          foreColor: "#e2e8f0",
          background: "transparent",
          toolbar: { show: false },
          zoom: { enabled: false },
          animations: { enabled: false }
        },
        series: [
          { name: "Richtig", data: successPoints },
          { name: "Falsch", data: failPoints }
        ],
        colors: ["#22c55e", "#f87171"],
        markers: {
          size: 9,
          strokeWidth: 0,
          hover: { size: 10 }
        },
        grid: { borderColor: "rgba(148,163,184,0.15)" },
        xaxis: {
          type: "numeric",
          min: 1,
          max: axisMax,
          tickAmount: tickSteps,
          title: { text: "Versuch" },
          labels: {
            formatter: val => Math.max(0, Math.round(val))
          }
        },
        yaxis: {
          min: 0,
          max: Math.max(0, effectiveRowCount - 1),
          tickAmount: Math.max(0, effectiveRowCount - 1),
          labels: {
            offsetX: -8,
            formatter: (value) => {
              const idx = Math.round(value);
              return labels[idx] || "";
            },
            trim: false,
            maxWidth: 260
          },
          tooltip: { enabled: false }
        },
        tooltip: {
          shared: false,
          intersect: true,
          custom: ({ series, seriesIndex, dataPointIndex, w }) => {
            const data = w.config.series[seriesIndex].data[dataPointIndex];
            if (!data) return "";
            const status = seriesIndex === 0 ? "Richtig" : "Falsch";
            return `<div class="apexcharts-tooltip-title">${data.combo}</div><div class="apexcharts-tooltip-text">${status} · Versuch ${data.attempt}</div>`;
          }
        },
        legend: {
          position: "top",
          horizontalAlign: "left"
        }
      };
      mountReportChart(containerId, options);
    }

    function renderComboRatioChart(rows, containerId) {
      if (typeof ApexCharts === "undefined" || !rows.length) return;
      const height = Math.max(340, rows.length * 32 + 100);
      const categories = rows.map(row => row.displayLabel || formatPromptLabel(row.label));
      const correctSeries = rows.map(row => row.correctPct);
      const wrongSeries = rows.map(row => row.wrongPct);
      const options = {
        chart: {
          type: "bar",
          stacked: true,
          height,
          foreColor: "#e2e8f0",
          background: "transparent",
          toolbar: { show: false }
        },
        series: [
          { name: "Richtig", data: correctSeries },
          { name: "Falsch", data: wrongSeries }
        ],
        plotOptions: {
          bar: {
            horizontal: true,
            barHeight: "55%",
            borderRadius: 6
          }
        },
        colors: ["#22c55e", "#f87171"],
        xaxis: {
          categories,
          max: 100,
          labels: {
            formatter: val => `${Math.round(val)}%`
          }
        },
        tooltip: {
          shared: true,
          intersect: false,
          y: {
            formatter: val => `${val}%`
          },
          x: {
            formatter: (_, opts) => {
              const idx = opts.dataPointIndex;
              const entry = rows[idx];
              return entry && (entry.displayLabel || formatPromptLabel(entry.label)) || "";
            }
          }
        },
        grid: { borderColor: "rgba(148,163,184,0.2)" },
        dataLabels: {
          enabled: true,
          formatter: val => `${val}%`,
          style: { colors: ["#0f172a"] }
        },
        legend: {
          position: "top"
        }
      };
      mountReportChart(containerId, options);
    }

    function getOwnedBattleSkills() {
      return state.skills
        .map(skill => updateSkillDerivedStats({ ...skill }))
        .filter(skill => skill && skill.tier > 0)
        .sort((a, b) => {
          if (b.tier !== a.tier) return b.tier - a.tier;
          const timeDiff = (b.lastObtainedAt || b.createdAt || 0) - (a.lastObtainedAt || a.createdAt || 0);
          if (timeDiff !== 0) return timeDiff;
          return a.name.localeCompare(b.name);
        });
    }

    function setupBattleSkills(hero, enemy) {
      const owned = getOwnedBattleSkills().slice(0, 9);
      const combosActive = DEFAULT_SKILL_INPUT_MODE === "hotkeys" && skillHotkeyPool.length;
      const usedCombos = new Set();
      battleSkillStates = owned.map((skill, index) => {
        const entry = {
          key: skill.key,
          skill,
          used: false
        };
        const bonusPercent = Number(skill.overcapBonusPercent || 0);
        const tierLabel = bonusPercent > 0 ? `Tier ${skill.tier} +${bonusPercent}%` : `Tier ${skill.tier}`;
        entry.displayLabel = `${skill.name} (${tierLabel})`;
        if (combosActive) {
          assignRandomCombo(entry, usedCombos);
          if (entry.comboId) usedCombos.add(entry.comboId);
        } else {
          entry.mode = "legacy";
          entry.hotkeyDisplay = String(index + 1);
          entry.legacyKey = index + 1;
        }
        return entry;
      });
      resetSkillKeyTracking();
      currentBattleContext = { hero, enemy };
      renderBattleSkillBar();
    }

    function renderBattleSkillBar() {
      if (!battleSkillBar) return;
      battleSkillBar.innerHTML = "";
      if (!battleSkillStates.length) {
        const info = document.createElement("span");
        info.className = "battle-skill-desc";
        const combosActive = DEFAULT_SKILL_INPUT_MODE === "hotkeys" && skillHotkeyPool.length > 0;
        const message = state.skills.length
          ? (combosActive ? "Skills bereit - nutze die angezeigten Hotkeys." : "Skills bereit - starte einen Kampf und nutze 1-9.")
          : "Noch keine Skills freigeschaltet.";
        info.textContent = message;
        battleSkillBar.appendChild(info);
        return;
      }
      const heroState = currentBattleContext ? currentBattleContext.hero : null;
      const heroShieldCharges = heroState ? Number(heroState.shieldWallCharges || 0) : 0;
      battleSkillStates.forEach(entry => {
        const card = document.createElement("div");
        card.className = "battle-skill";
        if (entry.used) card.classList.add("used");
        const cooldown = heroState ? getHeroSkillCooldown(heroState, entry.skill.key) : 0;
        const shieldLocked = entry.skill.key === SHIELD_SKILL_KEY && heroShieldCharges > 0;
        const skillLocked = shieldLocked || cooldown > 0;
        if (skillLocked) card.classList.add("skill-locked");
        const button = document.createElement("button");
        button.disabled = entry.used || !battleInProgress || !currentBattleContext || skillLocked;
        const hotkeyBadge = document.createElement("span");
        hotkeyBadge.className = "battle-skill-hotkey";
        hotkeyBadge.textContent = entry.hotkeyDisplay;
        const label = document.createElement("span");
        label.textContent = entry.displayLabel;
        button.appendChild(hotkeyBadge);
        button.appendChild(label);
        button.addEventListener("click", event => {
          if (DEFAULT_SKILL_INPUT_MODE === "hotkeys") {
            event.preventDefault();
            if (battleResult) {
              battleResult.textContent = "Nutze den eingeblendeten Hotkey, um Skills zu aktivieren.";
            }
            if (battleKnight) {
              spawnStatusText(battleKnight, "Hotkey nutzen", "buff");
            }
            return;
          }
          activateBattleSkill(entry);
        });
        card.appendChild(button);
        const effectValue = getSkillEffectivePower(entry.skill);
        const bonusPercent = Number(entry.skill.overcapBonusPercent || 0);
        const desc = document.createElement("span");
        desc.className = "battle-skill-desc";
        let effectText = "";
        const bonusDescriptor = bonusPercent > 0 ? ` (+${bonusPercent}%)` : "";
        switch (entry.skill.effect) {
          case "damage":
            effectText = `Fügt sofort ${effectValue} Schaden zu${bonusDescriptor}.`;
            if (entry.skill.key === STORM_SKILL_KEY && !cooldown) {
              effectText += ` (Cooldown ${SKILL_COOLDOWN_DEFAULT} Runden)`;
            }
            break;
          case "heal":
            effectText = `Heilt ${effectValue} HP${bonusDescriptor}.`;
            if (entry.skill.key === HEALING_SKILL_KEY && !cooldown) {
              effectText += ` (Cooldown ${SKILL_COOLDOWN_DEFAULT} Runden)`;
            }
            break;
          case "buff_atk":
            if (entry.skill.key === "kampfrausch") {
              effectText = `Erhöht ATK um ${effectValue} für ${SKILL_COOLDOWN_DEFAULT} Runden${bonusDescriptor}.`;
            } else {
              effectText = `Erhöht ATK um ${effectValue} für den Kampf${bonusDescriptor}.`;
            }
            break;
          case "debuff_enemy":
            effectText = `Senkt Gegner-ATK um ${effectValue}${bonusDescriptor}.`;
            break;
          case "shield_wall":
            effectText = `Erhöht DEF um ${effectValue} für ${SHIELD_WALL_MAX_CHARGES} gegnerische Angriffe${bonusDescriptor}.`;
            break;
          default:
            effectText = entry.skill.description || "Aktivierter Skill.";
        }
        if (shieldLocked) {
          effectText += " (aktiv)";
        } else if (cooldown > 0) {
          const roundsText = cooldown === 1 ? "1 Runde" : `${cooldown} Runden`;
          effectText += ` (Cooldown ${roundsText})`;
        }
        const tierDetail = bonusPercent > 0 ? `Tier ${entry.skill.tier} +${bonusPercent}%` : `Tier ${entry.skill.tier}`;
        const detailLabel = `${entry.skill.name} (${tierDetail})`;
        desc.textContent = effectText ? `${detailLabel} - ${effectText}` : detailLabel;
        card.appendChild(desc);
        battleSkillBar.appendChild(card);
      });
    }

    function renderBattleWeaponSlots() {
      const applySlot = (el, slotKey) => {
        if (!el) return;
        const item = getEquippedItemForSlot(slotKey);
        if (!item) {
          el.innerHTML = "";
          el.dataset.empty = "true";
          el.removeAttribute("title");
          el.setAttribute("aria-hidden", "true");
          el.removeAttribute("aria-label");
          el.style.transform = "";
          return;
        }
        el.dataset.empty = "false";
        el.innerHTML = getItemIcon(item.icon, item.key);
        const iconKey = String(item.icon || "").toLowerCase();
        const itemKey = String(item.key || "").toLowerCase();
        const isShield = iconKey.includes("shield") || itemKey.includes("shield");
        el.style.transform = isShield ? "" : "rotate(180deg)";
        if (slotKey === "offhand") {
          el.style.bottom = isShield ? "104px" : "70px";
        } else {
          el.style.bottom = "70px";
        }
        const label = item.name || getSlotButtonLabel(slotKey);
        el.title = label;
        el.setAttribute("aria-hidden", "false");
        el.setAttribute("aria-label", `${getSlotButtonLabel(slotKey)}: ${label}`);
      };
      applySlot(battleWeaponSlot1, "weapon");
      applySlot(battleWeaponSlot2, "offhand");
    }

    function clearBattleSkills() {
      battleSkillStates = [];
      currentBattleContext = null;
      resetSkillKeyTracking();
      renderBattleSkillBar();
    }

    function activateBattleSkill(entry) {
      if (!battleInProgress || !currentBattleContext) return;
      if (!entry || entry.used) return;
      const { hero, enemy } = currentBattleContext;
      if (entry.skill.key === SHIELD_SKILL_KEY && hero.shieldWallCharges > 0) {
        spawnStatusText(battleKnight, "Schutzwall aktiv", "buff");
        if (battleResult) battleResult.textContent = entry.skill.name + " ist bereits aktiv.";
        return;
      }
      const existingCooldown = getHeroSkillCooldown(hero, entry.skill.key);
      if (existingCooldown > 0) {
        const roundsText = existingCooldown === 1 ? "1 Runde" : `${existingCooldown} Runden`;
        spawnStatusText(battleKnight, `Cooldown ${roundsText}`, "buff");
        if (battleResult) battleResult.textContent = entry.skill.name + " ist im Cooldown.";
        return;
      }
      const power = getSkillEffectivePower(entry.skill);
      let resultText = entry.skill.name + " aktiviert.";
      switch (entry.skill.effect) {
        case "damage": {
          const applySkillDamage = () => {
            applyDamage(enemy, power);
            spawnDamageNumber(battleEnemy, power, "enemy", false);
            updateHpUi(hero, enemy);
          };
          if (entry.skill.key === STORM_SKILL_KEY) {
            triggerStormSkillEffect(battleEnemy, () => {
              applySkillDamage();
            });
          } else {
            applySkillDamage();
          }
          if (entry.skill.key === STORM_SKILL_KEY) {
            resultText = entry.skill.name + " beschwört einen Blitz für " + power + " Schaden (Cooldown " + SKILL_COOLDOWN_DEFAULT + " Runden).";
          } else {
            resultText = entry.skill.name + " verursacht " + power + " zusätzlichen Schaden.";
          }
          break;
        }
        case "heal": {
          const missing = Math.max(0, hero.maxHp - hero.hp);
          const healAmount = Math.min(power, missing);
          hero.hp = Math.min(hero.maxHp, hero.hp + power);
          updateHpUi(hero, enemy);
          if (healAmount > 0) {
            spawnDamageNumber(battleKnight, healAmount, "hero", false, "heal");
          } else {
            spawnStatusText(battleKnight, "HP voll", "buff");
          }
          if (entry.skill.key === HEALING_SKILL_KEY) {
            triggerHealingSkillEffect();
            resultText = entry.skill.name + " heilt " + healAmount + " HP und befindet sich für " + SKILL_COOLDOWN_DEFAULT + " Runden im Cooldown.";
          } else {
            resultText = entry.skill.name + " heilt " + healAmount + " HP.";
          }
          break;
        }
        case "buff_atk": {
          if (entry.skill.key === "kampfrausch") {
            applyTempAtkBuff(hero, power, SKILL_COOLDOWN_DEFAULT, entry.skill.key);
            spawnStatusText(battleKnight, "+ATK " + power, "buff");
            resultText = entry.skill.name + " erhöht deine ATK um " + power + " für " + SKILL_COOLDOWN_DEFAULT + " Runden.";
          } else {
            hero.atk = Math.max(1, hero.atk + power);
            hero.variance = Math.max(1, hero.variance || 1);
            spawnStatusText(battleKnight, "+ATK " + power, "buff");
            resultText = entry.skill.name + " erhöht deine ATK um " + power + " für diesen Kampf.";
          }
          break;
        }
        case "debuff_enemy": {
          const before = enemy.atk;
          enemy.atk = Math.max(1, enemy.atk - power);
          const reduced = before - enemy.atk;
          spawnStatusText(battleEnemy, "-ATK " + reduced, "debuff");
          resultText = entry.skill.name + " senkt die ATK des Gegners um " + reduced + ".";
          break;
        }
        case "shield_wall": {
          applyShieldWallBuff(hero, power);
          resultText = entry.skill.name + " errichtet einen Schutzwall (+DEF " + power + " für " + SHIELD_WALL_MAX_CHARGES + " Angriffe).";
          break;
        }
        default: {
          spawnStatusText(battleKnight, entry.skill.name, "buff");
          break;
        }
      }
      setHeroSkillCooldown(hero, entry.skill.key, SKILL_COOLDOWN_DEFAULT);
      battleSkillUseCount += 1;
      if (entry.mode === "combo") {
        const usedByOthers = new Set();
        battleSkillStates.forEach(other => {
          if (other !== entry && other.mode === "combo" && other.comboId) {
            usedByOthers.add(other.comboId);
          }
        });
        assignRandomCombo(entry, usedByOthers, entry.comboId);
        entry.used = false;
        resetSkillKeyTracking();
      } else {
        entry.used = true;
      }
      renderBattleSkillBar();
      if (battleResult) battleResult.textContent = resultText;
    }

    function useBattleSkillByLegacyKey(key) {
      const entry = battleSkillStates.find(state => state.mode === "legacy" && state.legacyKey === key && !state.used);
      if (entry) {
        activateBattleSkill(entry);
        return true;
      }
      return false;
    }

    const OPTIONAL_MODIFIER_KEYS = new Set(["CTRL", "ALT", "SHIFT", "WIN"]);

    function comboMatchesActiveKeys(comboSet) {
      if (!comboSet || !comboSet.size) return false;
      for (const key of comboSet) {
        if (!activeSkillKeys.has(key)) return false;
      }
      for (const key of activeSkillKeys) {
        if (comboSet.has(key)) continue;
        if (OPTIONAL_MODIFIER_KEYS.has(key)) continue;
        return false;
      }
      return true;
    }

    function tryActivateSkillCombos(event) {
      if (!battleSkillStates.length) return false;
      let triggered = false;
      battleSkillStates.forEach(entry => {
        if (entry.mode !== "combo" || entry.used) return;
        if (activeSkillComboLatch.has(entry.comboId)) return;
        if (!comboMatchesActiveKeys(entry.comboSet)) return;
        event.preventDefault();
        if (typeof event.stopPropagation === "function") event.stopPropagation();
        if (typeof event.stopImmediatePropagation === "function") event.stopImmediatePropagation();
        activeSkillComboLatch.add(entry.comboId);
        activateBattleSkill(entry);
        triggered = true;
      });
      return triggered;
    }

    function handleBattleKeyDown(event) {
      if (shouldBlockProtectedShortcut(event)) {
        event.preventDefault();
      }
      if (!battleSimulation || battleSimulation.classList.contains("hidden")) return;
      if (!currentBattleContext) return;
      const normalized = normalizeEventKey(event.key);
      if (!normalized) return;
      if (normalized === "ALT") {
        event.preventDefault();
      }
      activeSkillKeys.add(normalized);
      if (event.repeat) return;
      if (normalized.length === 1 && /[0-9]/.test(normalized)) {
        const keyNum = Number(normalized);
        if (keyNum >= 1 && keyNum <= 9 && useBattleSkillByLegacyKey(keyNum)) {
          event.preventDefault();
          return;
        }
      }
      tryActivateSkillCombos(event);
    }

    function handleBattleKeyUp(event) {
      const normalized = normalizeEventKey(event.key);
      if (!normalized) return;
      activeSkillKeys.delete(normalized);
      if (!activeSkillComboLatch.size) return;
      const release = [];
      activeSkillComboLatch.forEach(comboId => {
        const entry = battleSkillStates.find(state => state.mode === "combo" && state.comboId === comboId);
        if (!entry) {
          release.push(comboId);
          return;
        }
        const stillPressed = Array.from(entry.comboSet).every(token => activeSkillKeys.has(token));
        if (!stillPressed) release.push(comboId);
      });
      release.forEach(id => activeSkillComboLatch.delete(id));
    }

    const PROTECTED_SHORTCUTS = [
      { ctrl: true, key: "c" },
      { ctrl: true, key: "x" },
      { ctrl: true, key: "v" },
      { ctrl: true, key: "s" },
      { ctrl: true, key: "z" },
      { ctrl: true, key: "y" },
      { ctrl: true, key: "a" },
      { ctrl: true, key: "p" },
      { ctrl: true, key: "f" },
      { ctrl: true, key: "n" },
      { ctrl: true, key: "o" },
      { ctrl: true, key: "Escape" },
      { ctrl: true, key: "Home" },
      { ctrl: true, key: "End" },
      { alt: true, key: "Tab" },
      { meta: true, key: "Tab" },
      { meta: true, key: "d" },
      { meta: true, key: "e" },
      { meta: true, key: "s" },
      { meta: true, key: "ArrowUp" },
      { meta: true, key: "ArrowDown" },
      { meta: true, key: "ArrowLeft" },
      { meta: true, key: "ArrowRight" },
      { ctrl: true, shift: true, key: "Escape" },
      { meta: true, key: "l" },
      { meta: true, key: "r" },
      { meta: true, key: "i" },
      { meta: true, key: "v" },
      { meta: true, shift: true, key: "s" },
      { meta: true, key: "." }
    ];

    function normalizeShortcutKey(key) {
      if (!key) return "";
      return key.length === 1 ? key.toLowerCase() : key;
    }

    function matchesProtectedShortcut(event, shortcut) {
      if (!!shortcut.ctrl !== event.ctrlKey) return false;
      if (!!shortcut.alt !== event.altKey) return false;
      if (!!shortcut.meta !== event.metaKey) return false;
      if (!!shortcut.shift !== event.shiftKey) return false;
      if (shortcut.key && shortcut.key.startsWith("Arrow")) {
        return event.key === shortcut.key;
      }
      const shortcutKey = normalizeShortcutKey(shortcut.key);
      const eventKey = normalizeShortcutKey(event.key);
      return shortcutKey === eventKey;
    }

    function shouldBlockProtectedShortcut(event) {
      return PROTECTED_SHORTCUTS.some(shortcut => matchesProtectedShortcut(event, shortcut));
    }

    document.addEventListener("keydown", handleBattleKeyDown);
    document.addEventListener("keyup", handleBattleKeyUp);
    window.addEventListener("blur", resetSkillKeyTracking);

    if (battleNextBtn) {
      battleNextBtn.addEventListener("click", () => {
        if (battleInProgress) return;
        const targetLevel = Number(battleNextBtn.dataset.targetLevel || "0");
        if (!targetLevel) return;
        startBattle(targetLevel);
      });
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && battleSimulation && !battleSimulation.classList.contains("hidden")) {
        hideBattleSimulation(true);
      }
    });
    async function startBattle(level) {
      if (battleInProgress) return;
      if (level > state.battleUnlocked) return;
      const enemyBlueprint = ENEMIES[level];
      if (!enemyBlueprint) return;
      if (typeof window !== "undefined" && window.scrollTo) {
        window.scrollTo({ top: 0, behavior: "smooth" });
      }
      const hero = createHeroState();
      const enemy = createEnemyState(enemyBlueprint);
      battleInProgress = true;
      prepareBattleSimulation(hero, enemy, level);
      setupBattleSkills(hero, enemy);
      updateHpUi(hero, enemy);
      resetBattleLog("Kampf gegen " + enemy.name + " (Rang " + level + ") gestartet.");
      let heroWon = false;
      try {
        heroWon = await runBattleLoop(hero, enemy);
      } finally {
        battleInProgress = false;
      }
      finishBattle(hero, enemy, level, heroWon);
    }

    function prepareBattleSimulation(heroState, enemyState, level) {
      if (!battleSimulation) return;
      showBattleSimulation();
      clearBattleSideState();
      battleSkillUseCount = 0;
      resetBattleReward();
      if (battleResult) battleResult.textContent = "Der Kampf beginnt!";
      if (battleNextBtn) {
        battleNextBtn.classList.add("hidden");
        battleNextBtn.removeAttribute("data-target-level");
      }
      const theme = getBattleTheme(Math.max(1, level || enemyState?.level || 1));
      if (battleArena) battleArena.setAttribute("data-battle-theme", theme);
      const enemyName = enemyState && enemyState.name ? enemyState.name : "Gegner";
      if (battleTitle) battleTitle.textContent = "Kampf gegen " + enemyName + " (Rang " + level + ")";
      if (battleEnemyName) battleEnemyName.textContent = enemyName;
      if (battleKnight) battleKnight.classList.remove("attacking-left", "attacking-right", "hit");
      if (battleEnemy) {
        battleEnemy.classList.remove("attacking-left", "attacking-right", "hit");
        ENEMY_VARIANTS.forEach(variant => battleEnemy.classList.remove(variant));
        if (enemyState && enemyState.variant) battleEnemy.classList.add(enemyState.variant);
      }
      updateBattleSimulationCards(heroState, enemyState, level);
      resetBattleArena();
    }
    function updateBattleSimulationCards(heroState, enemyState, level) {
      if (heroState) {
        if (modalHeroName) modalHeroName.textContent = heroState.name || "Shortcut Knight";
        if (modalHeroAtk) modalHeroAtk.textContent = String(Math.max(0, heroState.atk || 0));
        if (modalHeroDef) modalHeroDef.textContent = String(Math.max(0, heroState.def || 0));
        const gearCount = getEquippedItems().length;
        const critPercent = Math.round(Math.max(0, heroState.crit || 0) * 100);
        const variance = Math.max(0, heroState.variance || 0);
        if (modalHeroVarBadge) modalHeroVarBadge.textContent = `Var ±${variance}`;
        if (modalHeroCritBadge) modalHeroCritBadge.textContent = `Krit ${critPercent}%`;
      }
      if (enemyState) {
        updateActiveEnemyArt(enemyState);
        if (modalEnemyName) modalEnemyName.textContent = enemyState.name || "Gegner";
        if (modalEnemyTrait) modalEnemyTrait.textContent = describeEnemyTrait(enemyState);
        if (modalEnemyAtk) modalEnemyAtk.textContent = String(Math.max(0, enemyState.atk || 0));
        if (modalEnemyDef) modalEnemyDef.textContent = String(Math.max(0, enemyState.def || 0));
        const enemyCritPercent = Math.round(Math.max(0, enemyState.crit || 0) * 100);
        const enemyVariance = Math.max(0, enemyState.variance || 0);
        if (modalEnemyVarBadge) modalEnemyVarBadge.textContent = `Var ±${enemyVariance}`;
        if (modalEnemyCritBadge) modalEnemyCritBadge.textContent = `Krit ${enemyCritPercent}%`;
        if (modalEnemyMeta) modalEnemyMeta.textContent = "";
      }
    }

    function showBattleSimulation() {
      if (!battleSimulation) return;
      cancelBattleSimHide();
      battleSimulation.classList.remove("hidden");
      if (battleSkillBar) battleSkillBar.hidden = false;
    }

    function hideBattleSimulation(force = false) {
      if (!battleSimulation) return;
      if (battleInProgress && !force) return;
      cancelBattleSimHide();
      battleSimulation.classList.add("hidden");
      if (battleSkillBar) battleSkillBar.hidden = true;
      clearBattleSkills();
    }

    function cancelBattleSimHide() {
      if (!battleSimHideTimer) return;
      clearTimeout(battleSimHideTimer);
      battleSimHideTimer = null;
    }

    function scheduleBattleSimHide(hasReward = true) {
      cancelBattleSimHide();
      const delay = hasReward ? 8000 : 3000;
      battleSimHideTimer = setTimeout(() => {
        hideBattleSimulation(true);
      }, delay);
    }

    function resetBattleArena() {
      if (!battleArena) return;
      battleArena.querySelectorAll(".damage-float").forEach(el => el.remove());
      battleArena.querySelectorAll(".battle-victory-chest").forEach(el => el.remove());
      removeShieldWallOverlay();
      removeFrenzyAura();
      if (battleEnemy) {
        battleEnemy.classList.remove("defeated");
      }
      if (battleKnight) {
        battleKnight.classList.remove("defeated");
      }
    }

    function resetBattleReward() {
      if (!battleReward) return;
      battleReward.hidden = true;
      battleReward.classList.remove("visible");
      if (battleRewardText) battleRewardText.textContent = "";
      if (battleRewardBreakdown) battleRewardBreakdown.textContent = "";
    }

    function showBattleReward(totalCoins, baseReward, skillReward) {
      if (!battleReward) return;
      const base = Math.max(0, baseReward || 0);
      const skills = Math.max(0, skillReward || 0);
      const rawTotal = base + skills;
      const bonusExtra = Math.max(0, (totalCoins || 0) - rawTotal);
      if (battleRewardText) {
        battleRewardText.textContent = `+${totalCoins} Coins`;
      }
      if (battleRewardBreakdown) {
        const baseText = `Basis +${base}`;
        const skillText = `Skills +${skills}`;
        const bonusText = bonusExtra ? ` • Bonus +${bonusExtra}` : "";
        battleRewardBreakdown.textContent = `${baseText} • ${skillText}${bonusText}`;
      }
      battleReward.hidden = false;
      battleReward.classList.remove("visible");
      void battleReward.offsetWidth;
      battleReward.classList.add("visible");
    }

    function animateEnemyDefeat() {
      if (!battleEnemy) return;
      battleEnemy.classList.add("defeated");
    }

    function animateHeroDefeat() {
      if (!battleKnight) return;
      battleKnight.classList.add("defeated");
    }

    function spawnArenaChestReward(finalReward) {
      if (!battleArena) return;
      const existing = battleArena.querySelector(".battle-victory-chest");
      if (existing) existing.remove();
      const chest = document.createElement("div");
      chest.className = "battle-victory-chest";
      chest.innerHTML = `
        <object class="chest-svg" type="image/svg+xml" data="assets/chest.svg" aria-label="Belohnung"></object>
      `;
      battleArena.appendChild(chest);
      requestAnimationFrame(() => chest.classList.add("visible"));
      const coinDelay = 4300;
      if (finalReward > 0) {
        setTimeout(() => {
          spawnCoinAnimation(finalReward, chest, "gain");
        }, coinDelay);
      }
      setTimeout(() => chest.classList.remove("visible"), 5200);
      setTimeout(() => chest.remove(), 6200);
    }

    function createHeroState() {
      const baseHp = getHeroMaxHp();
      return {
        name: "Ritter",
        maxHp: baseHp,
        hp: baseHp,
        atk: Math.max(1, state.atk),
        def: Math.max(0, state.def),
        variance: Math.max(1, Math.floor(Math.max(1, state.atk) / 4)),
        crit: 0.18,
        critDamageBonusPercent: Math.max(0, state.critDamagePercent || 0),
        shieldWallCharges: 0,
        shieldWallBonus: 0,
        skillCooldowns: Object.create(null),
        activeAtkBuffs: []
      };
    }

    function createEnemyState(blueprint) {
      return {
        name: blueprint.name,
        maxHp: blueprint.hp,
        hp: blueprint.hp,
        atk: blueprint.atk,
        def: blueprint.def,
        variance: blueprint.variance || 1,
        crit: blueprint.crit || 0.1,
        variant: blueprint.variant || "goblin",
        icon: blueprint.icon || getEnemyIconKey(blueprint)
      };
    }

    async function runBattleLoop(hero, enemy) {
      let attacker = hero;
      let defender = enemy;
      let attackerEl = battleKnight;
      let defenderEl = battleEnemy;
      while (hero.hp > 0 && enemy.hp > 0) {
        setActiveBattleSide(attacker === hero);
        const { amount, crit } = calculateDamage(attacker, defender);
        playAttack(attackerEl, defenderEl);
        applyDamage(defender, amount);
        pulseBattleSide(defender === hero);
        spawnDamageNumber(defenderEl, amount, defender === hero ? "hero" : "enemy", crit);
        if (defender === hero && hero.shieldWallCharges > 0) {
          consumeShieldWallCharge(hero);
        }
        const attackerName = attacker === hero ? "Ritter" : enemy.name;
        const defenderName = defender === hero ? "Ritter" : enemy.name;
        const critNote = crit ? " (Kritisch!)" : "";
        pushBattleLog(`${attackerName} trifft ${defenderName} für ${amount} Schaden${critNote}.`, attacker === hero ? "hero" : "enemy");
        updateHpUi(hero, enemy);
        await delay(680);
        if (attacker === hero) {
          tickHeroSkillCooldowns(hero);
          tickHeroBuffs(hero);
        }
        if (defender.hp <= 0) break;
        [attacker, defender] = attacker === hero ? [enemy, hero] : [hero, enemy];
        [attackerEl, defenderEl] = attackerEl === battleKnight ? [battleEnemy, battleKnight] : [battleKnight, battleEnemy];
        await delay(220);
      }
      clearBattleSideState();
      return enemy.hp <= 0;
    }

    function finishBattle(hero, enemy, level, heroWon) {
      const remainingHeroHp = Math.max(0, Math.round(hero.hp));
      if (heroWon) {
        animateEnemyDefeat();
        state.battleClears[level] = true;
        const nextLevel = level + 1;
        let unlockText = "";
        if (ENEMIES[nextLevel]) {
          if (state.battleUnlocked < nextLevel) {
            state.battleUnlocked = nextLevel;
            unlockText = " Nächstes Level freigeschaltet.";
          }
          if (battleNextBtn) {
            battleNextBtn.dataset.targetLevel = String(nextLevel);
            battleNextBtn.textContent = "Rang " + nextLevel + " " + ENEMIES[nextLevel].name + " starten";
            battleNextBtn.classList.remove("hidden");
          }
        } else if (battleNextBtn) {
          battleNextBtn.classList.add("hidden");
          battleNextBtn.removeAttribute("data-target-level");
        }
        if (battleResult) battleResult.textContent = "Sieg! Der Ritter besiegt " + enemy.name + "." + unlockText;
        pushBattleLog("Ritter besiegt " + enemy.name + ". Verbleibende HP: " + remainingHeroHp + ".", "hero");
        if (unlockText) {
          pushBattleLog("Rang " + nextLevel + " freigeschaltet.", "system");
        }
        const baseReward = BATTLE_LEVEL_REWARDS[level] || 0;
        const skillReward = battleSkillUseCount;
        const totalReward = baseReward + skillReward;
        const finalReward = totalReward > 0 ? applyCoinBonus(totalReward) : 0;
        if (finalReward > 0) {
          state.coins += finalReward;
          showBattleReward(finalReward, baseReward, skillReward);
          pushBattleLog(`Belohnung: +${finalReward} Coins (Basis ${baseReward} • Skills ${skillReward}).`, "system");
          coinAnimationSuppressOnce = true;
          updateUI();
        } else {
          resetBattleReward();
        }
        spawnArenaChestReward(finalReward);
        scheduleBattleSimHide(finalReward > 0);
      } else {
        animateHeroDefeat();
        if (battleResult) battleResult.textContent = "Niederlage gegen " + enemy.name + ". Versuche es erneut.";
        pushBattleLog(enemy.name + " besiegt den Ritter. Versuche es erneut.", "enemy");
        if (battleNextBtn) {
          battleNextBtn.classList.add("hidden");
          battleNextBtn.removeAttribute("data-target-level");
        }
        resetBattleReward();
        scheduleBattleSimHide(false);
      }
      battleSkillUseCount = 0;
      removeShieldWallOverlay();
      removeFrenzyAura();
      updateBattleButtons();
      currentBattleContext = null;
      renderBattleSkillBar();
      saveState();
      updateBattlePreview();
    }

    function updateBattleButtons() {
      if (!battleButtons || !battleButtons.length) return;
      battleButtons.forEach(btn => {
        const base = btn.dataset.label || btn.textContent;
        const level = Number(btn.dataset.enemy || "0");
        if (!level) return;
        const locked = level > state.battleUnlocked;
        const cleared = Boolean(state.battleClears && state.battleClears[level]);
        let label = base;
        if (locked) {
          label += " (gesperrt)";
        } else if (cleared) {
          label += " (gewonnen)";
        }
        btn.textContent = label;
        btn.disabled = locked;
      });
    }

    function updateHpUi(hero, enemy) {
      updateBar(heroHpFill, heroHpValue, hero.hp, hero.maxHp);
      updateBar(enemyHpFill, enemyHpValue, enemy.hp, enemy.maxHp);
    }

    function updateBar(fillEl, valueEl, hp, max) {
      if (!fillEl || !valueEl || !max) return;
      const clampedHp = Math.max(0, Math.round(hp));
      const clampedMax = Math.max(1, Math.round(max));
      const pct = Math.max(0, Math.min(1, clampedHp / clampedMax));
      fillEl.style.width = (pct * 100).toFixed(0) + "%";
      valueEl.textContent = clampedHp + " / " + clampedMax;
    }

    function calculateDamage(attacker, defender) {
      const variance = attacker.variance || 0;
      const spread = variance ? (Math.floor(Math.random() * (variance * 2 + 1)) - variance) : 0;
      const defenderBaseDef = defender ? Math.max(0, defender.def || 0) : 0;
      const defenderShieldBonus = (defender && defender.shieldWallCharges > 0) ? Math.max(0, defender.shieldWallBonus || 0) : 0;
      let amount = attacker.atk + spread - (defenderBaseDef + defenderShieldBonus);
      let crit = false;
      if (attacker.crit && Math.random() < attacker.crit) {
        crit = true;
        const bonusPercent = Math.max(0, attacker.critDamageBonusPercent || 0);
        const critMultiplier = 1.5 * (1 + bonusPercent / 100);
        amount = Math.round(amount * critMultiplier) + 1;
      }
      amount = Math.max(1, amount);
      return { amount, crit };
    }

    function applyDamage(target, amount) {
      target.hp = Math.max(0, target.hp - amount);
    }

    function playAttack(attackerEl, defenderEl) {
      if (!attackerEl || !defenderEl) return;
      const attackClass = attackerEl === battleKnight ? "attacking-left" : "attacking-right";
      attackerEl.classList.remove("attacking-left", "attacking-right");
      defenderEl.classList.remove("hit");
      void attackerEl.offsetWidth;
      void defenderEl.offsetWidth;
      attackerEl.classList.add(attackClass);
      defenderEl.classList.add("hit");
      setTimeout(() => attackerEl.classList.remove("attacking-left", "attacking-right"), 520);
      setTimeout(() => defenderEl.classList.remove("hit"), 420);
    }

    function triggerStormSkillEffect(targetEl, onImpact) {
      const impactFn = typeof onImpact === "function" ? onImpact : null;
      if (!battleArena || !targetEl) {
        if (impactFn) impactFn();
        return;
      }
      const container = document.createElement("div");
      container.className = "storm-strike";
      container.innerHTML = STORM_STRIKE_SVG;
      const arenaRect = battleArena.getBoundingClientRect();
      const targetRect = targetEl.getBoundingClientRect();
      const size = Math.max(180, Math.min(260, (targetRect.width || 80) * 2.4));
      container.style.setProperty("--storm-size", `${size}px`);
      const left = (targetRect.left + targetRect.width / 2) - arenaRect.left - size / 2;
      const top = Math.max(12, targetRect.top - arenaRect.top - size * 0.8);
      container.style.left = `${left}px`;
      container.style.top = `${top}px`;
      battleArena.appendChild(container);
      const impactDelay = 420;
      if (impactFn) {
        setTimeout(() => impactFn(), impactDelay);
      }
      setTimeout(() => {
        container.remove();
      }, 1400);
    }

    function triggerHealingSkillEffect() {
      if (!battleKnight) return;
      const wave = document.createElement("div");
      wave.className = "healing-wave";
      wave.innerHTML = HEALING_WAVE_SVG;
      battleKnight.appendChild(wave);
      setTimeout(() => wave.remove(), 1500);
    }

    function showFrenzyAura() {
      if (!battleKnight) return;
      if (!frenzyAuraEl) {
        frenzyAuraEl = document.createElement("div");
        frenzyAuraEl.className = "frenzy-aura";
        frenzyAuraEl.innerHTML = FRENZY_AURA_SVG;
        battleKnight.appendChild(frenzyAuraEl);
      }
    }

    function removeFrenzyAura() {
      if (frenzyAuraEl) {
        frenzyAuraEl.remove();
        frenzyAuraEl = null;
      }
    }

    function showShieldWallOverlay(charges, bonus) {
      if (!battleKnight) return;
      if (shieldWallRemoveTimer) {
        clearTimeout(shieldWallRemoveTimer);
        shieldWallRemoveTimer = null;
      }
      if (!shieldWallOverlayEl) {
        shieldWallOverlayEl = document.createElement("div");
        shieldWallOverlayEl.className = "shield-wall-overlay";
        shieldWallOverlayEl.innerHTML = SHIELD_WALL_SVG;
        shieldWallCounterEl = document.createElement("div");
        shieldWallCounterEl.className = "shield-wall-counter";
        shieldWallOverlayEl.appendChild(shieldWallCounterEl);
        battleKnight.appendChild(shieldWallOverlayEl);
      }
      shieldWallOverlayEl.dataset.charges = String(charges);
      shieldWallOverlayEl.dataset.bonus = String(bonus);
      shieldWallOverlayEl.classList.remove("hit", "spent");
      shieldWallOverlayEl.classList.add("active");
      updateShieldWallCounter(charges);
    }

    function updateShieldWallCounter(charges) {
      if (shieldWallCounterEl) {
        shieldWallCounterEl.textContent = charges > 0 ? `x${charges}` : "";
      }
      if (shieldWallOverlayEl) {
        shieldWallOverlayEl.dataset.charges = String(Math.max(0, charges || 0));
      }
    }

    function pulseShieldWallOverlay(charges) {
      updateShieldWallCounter(charges);
      if (!shieldWallOverlayEl) return;
      shieldWallOverlayEl.classList.remove("hit");
      void shieldWallOverlayEl.offsetWidth;
      shieldWallOverlayEl.classList.add("hit");
      if (!charges) {
        shieldWallOverlayEl.classList.add("spent");
        if (shieldWallRemoveTimer) clearTimeout(shieldWallRemoveTimer);
        shieldWallRemoveTimer = setTimeout(removeShieldWallOverlay, 450);
      }
    }

    function removeShieldWallOverlay() {
      if (shieldWallRemoveTimer) {
        clearTimeout(shieldWallRemoveTimer);
        shieldWallRemoveTimer = null;
      }
      if (shieldWallOverlayEl) {
        shieldWallOverlayEl.remove();
        shieldWallOverlayEl = null;
      }
      shieldWallCounterEl = null;
    }

    function ensureHeroCooldowns(hero) {
      if (!hero) return null;
      if (!hero.skillCooldowns || typeof hero.skillCooldowns !== "object") {
        hero.skillCooldowns = Object.create(null);
      }
      return hero.skillCooldowns;
    }

    function getHeroSkillCooldown(hero, skillKey) {
      if (!hero || !skillKey) return 0;
      const cooldowns = ensureHeroCooldowns(hero);
      return Math.max(0, Number(cooldowns[skillKey] || 0));
    }

    function setHeroSkillCooldown(hero, skillKey, rounds = SKILL_COOLDOWN_DEFAULT) {
      if (!hero || !skillKey) return;
      const cooldowns = ensureHeroCooldowns(hero);
      cooldowns[skillKey] = Math.max(0, Math.floor(rounds));
      renderBattleSkillBar();
    }

    function tickHeroSkillCooldowns(hero) {
      if (!hero || !hero.skillCooldowns) return;
      let changed = false;
      Object.keys(hero.skillCooldowns).forEach(key => {
        const next = Math.max(0, Number(hero.skillCooldowns[key] || 0) - 1);
        if (next <= 0) {
          delete hero.skillCooldowns[key];
          changed = true;
        } else if (next !== hero.skillCooldowns[key]) {
          hero.skillCooldowns[key] = next;
          changed = true;
        }
      });
      if (changed) renderBattleSkillBar();
    }

    function applyShieldWallBuff(hero, bonus) {
      if (!hero) return;
      const effectiveBonus = Math.max(1, Math.round(bonus));
      hero.shieldWallBonus = effectiveBonus;
      hero.shieldWallCharges = SHIELD_WALL_MAX_CHARGES;
      showShieldWallOverlay(hero.shieldWallCharges, effectiveBonus);
      spawnStatusText(battleKnight, "+DEF " + effectiveBonus, "buff");
      renderBattleSkillBar();
    }

    function consumeShieldWallCharge(hero) {
      if (!hero || !hero.shieldWallCharges) return;
      hero.shieldWallCharges = Math.max(0, hero.shieldWallCharges - 1);
      pulseShieldWallOverlay(hero.shieldWallCharges);
      if (hero.shieldWallCharges <= 0) {
        hero.shieldWallBonus = 0;
      }
      renderBattleSkillBar();
    }

    function updateBattleHeroStatsDisplay(hero) {
      if (!hero) return;
      if (battleHeroAtkStat) battleHeroAtkStat.textContent = String(Math.max(0, Math.round(hero.atk || 0)));
      if (modalHeroAtk) modalHeroAtk.textContent = String(Math.max(0, Math.round(hero.atk || 0)));
    }

    function applyTempAtkBuff(hero, amount, rounds, source) {
      if (!hero) return;
      const buffRounds = Math.max(1, Math.floor(rounds || SKILL_COOLDOWN_DEFAULT));
      hero.atk = Math.max(1, hero.atk + amount);
      hero.variance = Math.max(1, Math.floor(Math.max(1, hero.atk) / 4));
      if (!Array.isArray(hero.activeAtkBuffs)) hero.activeAtkBuffs = [];
      hero.activeAtkBuffs.push({
        key: source || "buff",
        amount,
        rounds: buffRounds
      });
      if (source === FRENZY_SKILL_KEY) {
        showFrenzyAura();
      }
      updateBattleHeroStatsDisplay(hero);
    }

    function tickHeroBuffs(hero) {
      if (!hero || !Array.isArray(hero.activeAtkBuffs) || !hero.activeAtkBuffs.length) {
        removeFrenzyAura();
        return;
      }
      let changed = false;
      hero.activeAtkBuffs.forEach(buff => {
        buff.rounds -= 1;
        if (buff.rounds <= 0) {
          hero.atk = Math.max(1, hero.atk - buff.amount);
          changed = true;
        }
      });
      hero.activeAtkBuffs = hero.activeAtkBuffs.filter(buff => buff.rounds > 0);
      if (!hero.activeAtkBuffs.some(buff => buff.key === FRENZY_SKILL_KEY)) {
        removeFrenzyAura();
      }
      if (changed) {
        hero.variance = Math.max(1, Math.floor(Math.max(1, hero.atk) / 4));
        updateBattleHeroStatsDisplay(hero);
      }
    }

    function spawnDamageNumber(targetEl, amount, targetType, crit, effect = "damage") {
      if (!battleArena || !targetEl) return;
      const float = document.createElement("div");
      float.className = "damage-float";
      float.classList.add(targetType === "hero" ? "hero-hit" : "enemy-hit");
      if (effect === "heal") {
        float.classList.add("heal");
        float.textContent = "+" + amount;
      } else if (crit) {
        float.classList.add("crit");
        float.textContent = "-" + amount + "!";
      } else {
        float.textContent = "-" + amount;
      }
      const arenaRect = battleArena.getBoundingClientRect();
      const targetRect = targetEl.getBoundingClientRect();
      const offsetX = (targetRect.left + targetRect.width / 2) - arenaRect.left + (Math.random() * 30 - 15);
      const offsetY = (targetRect.top + targetRect.height / 2) - arenaRect.top - 10 + (Math.random() * 12 - 6);
      float.style.left = `${offsetX}px`;
      float.style.top = `${offsetY}px`;
      battleArena.appendChild(float);
      setTimeout(() => float.remove(), 950);
    }

    function spawnStatusText(targetEl, text, variant = "buff") {
      if (!battleArena || !targetEl) return;
      const float = document.createElement("div");
      float.className = "status-float";
      float.classList.add(variant);
      float.textContent = text;
      const arenaRect = battleArena.getBoundingClientRect();
      const targetRect = targetEl.getBoundingClientRect();
      const offsetX = (targetRect.left + targetRect.width / 2) - arenaRect.left + (Math.random() * 24 - 12);
      const offsetY = (targetRect.top + targetRect.height / 2) - arenaRect.top - 16 + (Math.random() * 10 - 5);
      float.style.left = `${offsetX}px`;
      float.style.top = `${offsetY}px`;
      battleArena.appendChild(float);
      setTimeout(() => float.remove(), 950);
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    ensureSkillInventory();
    ensureKnightInventory();
    renderBattleButtons();
    clearBattleSkills();
    updateBattleButtons();
    recalcStats();
    updateUI();
    updateOverallSummary();
resetBattleLog("Wähle einen Kampf um die Simulation zu starten.");
  </script>
</body>
</html>
